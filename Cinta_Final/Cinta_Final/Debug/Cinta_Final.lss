
Cinta_Final.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  00001110  000011a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001110  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000279  0080010a  0080010a  000011ae  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000011ae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000011e0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000158  00000000  00000000  00001220  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001cc7  00000000  00000000  00001378  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b82  00000000  00000000  0000303f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000e11  00000000  00000000  00003bc1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003dc  00000000  00000000  000049d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009cf  00000000  00000000  00004db0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000009cd  00000000  00000000  0000577f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000140  00000000  00000000  0000614c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
       4:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       8:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      28:	0c 94 36 01 	jmp	0x26c	; 0x26c <__vector_10>
      2c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__vector_11>
      30:	0c 94 01 01 	jmp	0x202	; 0x202 <__vector_12>
      34:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      40:	0c 94 7d 01 	jmp	0x2fa	; 0x2fa <__vector_16>
      44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      48:	0c 94 a1 01 	jmp	0x342	; 0x342 <__vector_18>
      4c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      54:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      58:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      5c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      60:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      64:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      68:	a2 03       	fmuls	r18, r18
      6a:	b0 03       	fmuls	r19, r16
      6c:	c8 03       	fmulsu	r20, r16
      6e:	dd 03       	fmulsu	r21, r21
      70:	f2 03       	fmuls	r23, r18
      72:	00 04       	cpc	r0, r0
      74:	25 04       	cpc	r2, r5

00000076 <__ctors_end>:
      76:	11 24       	eor	r1, r1
      78:	1f be       	out	0x3f, r1	; 63
      7a:	cf ef       	ldi	r28, 0xFF	; 255
      7c:	d8 e0       	ldi	r29, 0x08	; 8
      7e:	de bf       	out	0x3e, r29	; 62
      80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
      82:	11 e0       	ldi	r17, 0x01	; 1
      84:	a0 e0       	ldi	r26, 0x00	; 0
      86:	b1 e0       	ldi	r27, 0x01	; 1
      88:	e0 e1       	ldi	r30, 0x10	; 16
      8a:	f1 e1       	ldi	r31, 0x11	; 17
      8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
      8e:	05 90       	lpm	r0, Z+
      90:	0d 92       	st	X+, r0
      92:	aa 30       	cpi	r26, 0x0A	; 10
      94:	b1 07       	cpc	r27, r17
      96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
      98:	23 e0       	ldi	r18, 0x03	; 3
      9a:	aa e0       	ldi	r26, 0x0A	; 10
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
      a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
      a2:	a3 38       	cpi	r26, 0x83	; 131
      a4:	b2 07       	cpc	r27, r18
      a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
      a8:	0e 94 2e 06 	call	0xc5c	; 0xc5c <main>
      ac:	0c 94 86 08 	jmp	0x110c	; 0x110c <_exit>

000000b0 <__bad_interrupt>:
      b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <HCSR04_AddNew>:

//variable interna estatica
static _sHCSR04Handle *mySensor;		//puntero a la estructura _sHCSR04Handle. Se usa como variable auxiliar para manipular los datos de los sensores ultrasónicos HCSR04.

unsigned int HCSR04_AddNew(void (*WritePin_HCSR04)(uint8_t value), uint32_t ticks)
{
      b4:	cf 92       	push	r12
      b6:	df 92       	push	r13
      b8:	ef 92       	push	r14
      ba:	ff 92       	push	r15
      bc:	cf 93       	push	r28
      be:	df 93       	push	r29
      c0:	ec 01       	movw	r28, r24
      c2:	6a 01       	movw	r12, r20
      c4:	7b 01       	movw	r14, r22
	mySensor = (_sHCSR04Handle *)malloc(sizeof(_sHCSR04Handle));	//myHandleAux almacena un nuevo sensor dinámicamente, por lo que myHandleAux apunta a la nueva estructura creada.
      c6:	8f e0       	ldi	r24, 0x0F	; 15
      c8:	90 e0       	ldi	r25, 0x00	; 0
      ca:	0e 94 65 07 	call	0xeca	; 0xeca <malloc>
      ce:	fc 01       	movw	r30, r24
      d0:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
      d4:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>

	mySensor->WritePin = WritePin_HCSR04;
      d8:	d1 83       	std	Z+1, r29	; 0x01
      da:	c0 83       	st	Z, r28
	mySensor->ticks = ticks;
      dc:	c2 86       	std	Z+10, r12	; 0x0a
      de:	d3 86       	std	Z+11, r13	; 0x0b
      e0:	e4 86       	std	Z+12, r14	; 0x0c
      e2:	f5 86       	std	Z+13, r15	; 0x0d
	mySensor->flags.byte = 0;								
      e4:	16 86       	std	Z+14, r1	; 0x0e
	mySensor->lastDistanceUs = 0;
      e6:	11 86       	std	Z+9, r1	; 0x09
      e8:	10 86       	std	Z+8, r1	; 0x08
	mySensor->usTimeRise = 0;
      ea:	15 82       	std	Z+5, r1	; 0x05
      ec:	14 82       	std	Z+4, r1	; 0x04
	mySensor->usTimeFall = 0;
      ee:	17 82       	std	Z+7, r1	; 0x07
      f0:	16 82       	std	Z+6, r1	; 0x06
	mySensor->WritePin(0);		
      f2:	80 e0       	ldi	r24, 0x00	; 0
      f4:	fe 01       	movw	r30, r28
      f6:	09 95       	icall
	
	return (unsigned int)mySensor;
}
      f8:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <__data_end>
      fc:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <__data_end+0x1>
     100:	df 91       	pop	r29
     102:	cf 91       	pop	r28
     104:	ff 90       	pop	r15
     106:	ef 90       	pop	r14
     108:	df 90       	pop	r13
     10a:	cf 90       	pop	r12
     10c:	08 95       	ret

0000010e <HCSR04_Start>:
//}


void HCSR04_Start(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     10e:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     112:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
	
	mySensor->WritePin(1);					
     116:	dc 01       	movw	r26, r24
     118:	ed 91       	ld	r30, X+
     11a:	fc 91       	ld	r31, X
     11c:	81 e0       	ldi	r24, 0x01	; 1
     11e:	09 95       	icall
     120:	08 95       	ret

00000122 <HCSR04_TriggerReady>:
	
}

void HCSR04_TriggerReady(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     122:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     126:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
	
	mySensor->WritePin(0);
     12a:	dc 01       	movw	r26, r24
     12c:	ed 91       	ld	r30, X+
     12e:	fc 91       	ld	r31, X
     130:	80 e0       	ldi	r24, 0x00	; 0
     132:	09 95       	icall
     134:	08 95       	ret

00000136 <HCSR04_RiseEdgeTime>:
}

void HCSR04_RiseEdgeTime(unsigned int handleHCSR04, uint16_t usTimeRise)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     136:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     13a:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>

	mySensor->usTimeRise = usTimeRise;	//Cargo cuando se pone en RISE
     13e:	fc 01       	movw	r30, r24
     140:	75 83       	std	Z+5, r23	; 0x05
     142:	64 83       	std	Z+4, r22	; 0x04
	mySensor->flags.byte = 0;
     144:	16 86       	std	Z+14, r1	; 0x0e
     146:	08 95       	ret

00000148 <HCSR04_FallEdgeTime>:

}

void HCSR04_FallEdgeTime(unsigned int handleHCSR04, uint16_t usTimeFall)
{
     148:	fc 01       	movw	r30, r24
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     14a:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     14e:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>

	mySensor->usTimeFall = usTimeFall;	//Cargo cuando se pone en Fall 
     152:	77 83       	std	Z+7, r23	; 0x07
     154:	66 83       	std	Z+6, r22	; 0x06
	mySensor->flags.bit.EDGEREADY = 1;
     156:	86 85       	ldd	r24, Z+14	; 0x0e
     158:	81 60       	ori	r24, 0x01	; 1
     15a:	86 87       	std	Z+14, r24	; 0x0e
     15c:	08 95       	ret

0000015e <task_HCSR>:
	
}

void task_HCSR()
{
	if (mySensor != NULL)
     15e:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <__data_end>
     162:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <__data_end+0x1>
     166:	30 97       	sbiw	r30, 0x00	; 0
     168:	11 f1       	breq	.+68     	; 0x1ae <task_HCSR+0x50>
	{
		if (mySensor->flags.bit.EDGEREADY) //¿el sensor midió? Esto indica que ya se recibieron los dos flancos (rising y falling) y se puede calcular el tiempo que tardó el eco en volver = la distancia.
     16a:	86 85       	ldd	r24, Z+14	; 0x0e
     16c:	80 ff       	sbrs	r24, 0
     16e:	1f c0       	rjmp	.+62     	; 0x1ae <task_HCSR+0x50>
		{
			mySensor->flags.byte = 0;
     170:	16 86       	std	Z+14, r1	; 0x0e
			
			if(mySensor->usTimeRise < mySensor->usTimeFall){ //si no hubo overflow
     172:	24 81       	ldd	r18, Z+4	; 0x04
     174:	35 81       	ldd	r19, Z+5	; 0x05
     176:	86 81       	ldd	r24, Z+6	; 0x06
     178:	97 81       	ldd	r25, Z+7	; 0x07
     17a:	28 17       	cp	r18, r24
     17c:	39 07       	cpc	r19, r25
     17e:	28 f4       	brcc	.+10     	; 0x18a <task_HCSR+0x2c>
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise; //distancia medida
     180:	82 1b       	sub	r24, r18
     182:	93 0b       	sbc	r25, r19
     184:	91 87       	std	Z+9, r25	; 0x09
     186:	80 87       	std	Z+8, r24	; 0x08
     188:	05 c0       	rjmp	.+10     	; 0x194 <task_HCSR+0x36>
				}else{ //hubo overflow
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise + 0xFFFF; //para corregir
     18a:	82 1b       	sub	r24, r18
     18c:	93 0b       	sbc	r25, r19
     18e:	01 97       	sbiw	r24, 0x01	; 1
     190:	91 87       	std	Z+9, r25	; 0x09
     192:	80 87       	std	Z+8, r24	; 0x08
			}
			
			if(mySensor->lastDistanceUs > 11764) //2 metros
     194:	80 85       	ldd	r24, Z+8	; 0x08
     196:	91 85       	ldd	r25, Z+9	; 0x09
     198:	85 3f       	cpi	r24, 0xF5	; 245
     19a:	9d 42       	sbci	r25, 0x2D	; 45
     19c:	20 f0       	brcs	.+8      	; 0x1a6 <task_HCSR+0x48>
				mySensor->lastDistanceUs = 0xFFFF;
     19e:	8f ef       	ldi	r24, 0xFF	; 255
     1a0:	9f ef       	ldi	r25, 0xFF	; 255
     1a2:	91 87       	std	Z+9, r25	; 0x09
     1a4:	80 87       	std	Z+8, r24	; 0x08
			
			sensorMeasure(mySensor->lastDistanceUs);
     1a6:	80 85       	ldd	r24, Z+8	; 0x08
     1a8:	91 85       	ldd	r25, Z+9	; 0x09
     1aa:	0e 94 94 04 	call	0x928	; 0x928 <sensorMeasure>
     1ae:	08 95       	ret

000001b0 <WritePin_HCSR>:
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
	}
}

void WritePin_HCSR(uint8_t value){
	if (value)
     1b0:	88 23       	and	r24, r24
     1b2:	21 f0       	breq	.+8      	; 0x1bc <WritePin_HCSR+0xc>
	PORTB |= (1<<TRIGGER);				// Sets a HIGH state (1) in the TRIGGER pin
     1b4:	85 b1       	in	r24, 0x05	; 5
     1b6:	82 60       	ori	r24, 0x02	; 2
     1b8:	85 b9       	out	0x05, r24	; 5
     1ba:	08 95       	ret
	else
	PORTB &= ~(1<<TRIGGER);				// Sets a LOW state (0) in the TRIGGER pin
     1bc:	85 b1       	in	r24, 0x05	; 5
     1be:	8d 7f       	andi	r24, 0xFD	; 253
     1c0:	85 b9       	out	0x05, r24	; 5
     1c2:	08 95       	ret

000001c4 <__vector_11>:

/* END Constant in Flash -----------------------------------------------------*/


/* Function ISR --------------------------------------------------------------*/
ISR(TIMER1_COMPA_vect){
     1c4:	1f 92       	push	r1
     1c6:	0f 92       	push	r0
     1c8:	0f b6       	in	r0, 0x3f	; 63
     1ca:	0f 92       	push	r0
     1cc:	11 24       	eor	r1, r1
     1ce:	8f 93       	push	r24
     1d0:	9f 93       	push	r25
     1d2:	ef 93       	push	r30
     1d4:	ff 93       	push	r31
	
	/*		Con el OCR1B en 20000 , cuento cada 10ms		*/
	IS10MS=TRUE;
     1d6:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     1da:	81 60       	ori	r24, 0x01	; 1
     1dc:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <flag0>
	OCR1A += 19999;
     1e0:	e8 e8       	ldi	r30, 0x88	; 136
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	91 81       	ldd	r25, Z+1	; 0x01
     1e8:	81 5e       	subi	r24, 0xE1	; 225
     1ea:	91 4b       	sbci	r25, 0xB1	; 177
     1ec:	91 83       	std	Z+1, r25	; 0x01
     1ee:	80 83       	st	Z, r24
	
}
     1f0:	ff 91       	pop	r31
     1f2:	ef 91       	pop	r30
     1f4:	9f 91       	pop	r25
     1f6:	8f 91       	pop	r24
     1f8:	0f 90       	pop	r0
     1fa:	0f be       	out	0x3f, r0	; 63
     1fc:	0f 90       	pop	r0
     1fe:	1f 90       	pop	r1
     200:	18 95       	reti

00000202 <__vector_12>:

ISR(TIMER1_COMPB_vect){
     202:	1f 92       	push	r1
     204:	0f 92       	push	r0
     206:	0f b6       	in	r0, 0x3f	; 63
     208:	0f 92       	push	r0
     20a:	11 24       	eor	r1, r1
     20c:	2f 93       	push	r18
     20e:	3f 93       	push	r19
     210:	4f 93       	push	r20
     212:	5f 93       	push	r21
     214:	6f 93       	push	r22
     216:	7f 93       	push	r23
     218:	8f 93       	push	r24
     21a:	9f 93       	push	r25
     21c:	af 93       	push	r26
     21e:	bf 93       	push	r27
     220:	ef 93       	push	r30
     222:	ff 93       	push	r31
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
}

static inline void on_timer1_compb_hcsr(){
	HCSR04_TriggerReady(HCSR_1);					//Pongo en LOW el Trigger
     224:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <HCSR_1>
     228:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <HCSR_1+0x1>
     22c:	0e 94 91 00 	call	0x122	; 0x122 <HCSR04_TriggerReady>
	TIFR1 |= (1<<ICF1);								// Timer/Counter1 Output Compare A Match Flag enabled
     230:	86 b3       	in	r24, 0x16	; 22
     232:	80 62       	ori	r24, 0x20	; 32
     234:	86 bb       	out	0x16, r24	; 22
	TCCR1B = (1 << ICNC1) | (1 << ICES1);			// Input Capture Noise Canceler and Input Capture Edge Select activated
     236:	e1 e8       	ldi	r30, 0x81	; 129
     238:	f0 e0       	ldi	r31, 0x00	; 0
     23a:	80 ec       	ldi	r24, 0xC0	; 192
     23c:	80 83       	st	Z, r24
	TCCR1B |= (1 << CS11);							// Prescaler definition (x8): CS12 = 0 and CS10 = 0
     23e:	80 81       	ld	r24, Z
     240:	82 60       	ori	r24, 0x02	; 2
     242:	80 83       	st	Z, r24
	TIMSK1 = (1<<ICIE1) | (1<<OCIE1A);				// Input Capture Interrupt and Output Compare A Match Interrupt enabled <---
     244:	82 e2       	ldi	r24, 0x22	; 34
     246:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	
	on_timer1_compb_hcsr();
	
}
     24a:	ff 91       	pop	r31
     24c:	ef 91       	pop	r30
     24e:	bf 91       	pop	r27
     250:	af 91       	pop	r26
     252:	9f 91       	pop	r25
     254:	8f 91       	pop	r24
     256:	7f 91       	pop	r23
     258:	6f 91       	pop	r22
     25a:	5f 91       	pop	r21
     25c:	4f 91       	pop	r20
     25e:	3f 91       	pop	r19
     260:	2f 91       	pop	r18
     262:	0f 90       	pop	r0
     264:	0f be       	out	0x3f, r0	; 63
     266:	0f 90       	pop	r0
     268:	1f 90       	pop	r1
     26a:	18 95       	reti

0000026c <__vector_10>:

ISR(TIMER1_CAPT_vect){
     26c:	1f 92       	push	r1
     26e:	0f 92       	push	r0
     270:	0f b6       	in	r0, 0x3f	; 63
     272:	0f 92       	push	r0
     274:	11 24       	eor	r1, r1
     276:	2f 93       	push	r18
     278:	3f 93       	push	r19
     27a:	4f 93       	push	r20
     27c:	5f 93       	push	r21
     27e:	6f 93       	push	r22
     280:	7f 93       	push	r23
     282:	8f 93       	push	r24
     284:	9f 93       	push	r25
     286:	af 93       	push	r26
     288:	bf 93       	push	r27
     28a:	ef 93       	push	r30
     28c:	ff 93       	push	r31
}

static inline void on_timer1_capt_hcsr(){
	if (TCCR1B & (1<<ICES1)){						// Si ICES1 = 1  el Timer va a capturar en el flanco de subida (rising edge).
     28e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
     292:	86 ff       	sbrs	r24, 6
     294:	10 c0       	rjmp	.+32     	; 0x2b6 <__vector_10+0x4a>
		
		TCCR1B = (1 << ICNC1) | (1 << CS11);		//preparo para capturar el flanco de bajada
     296:	82 e8       	ldi	r24, 0x82	; 130
     298:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
		HCSR04_RiseEdgeTime(HCSR_1, ICR1 >> 1);		//[[ ICR1 >> 1  ==  ICR1 / 2 ]] -> En ICR1 almacena el valor de TCNT1, Es decir, guardo el momento en que llego el RISE. Como ICR1 obtiene un tick cada 500ns, si contó 3000 ticks, se hace la cuenta 3000 * 0,5us = 1500us. (500ns = 0,5us = 1/2).
     29c:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2a0:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2a4:	76 95       	lsr	r23
     2a6:	67 95       	ror	r22
     2a8:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <HCSR_1>
     2ac:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <HCSR_1+0x1>
     2b0:	0e 94 9b 00 	call	0x136	; 0x136 <HCSR04_RiseEdgeTime>
     2b4:	11 c0       	rjmp	.+34     	; 0x2d8 <__vector_10+0x6c>
		}else{										// Falling edge is used as trigger

		TIMSK1 &= ~_BV(ICIE1);						//desactivo la interrupcion por input capture
     2b6:	ef e6       	ldi	r30, 0x6F	; 111
     2b8:	f0 e0       	ldi	r31, 0x00	; 0
     2ba:	80 81       	ld	r24, Z
     2bc:	8f 7d       	andi	r24, 0xDF	; 223
     2be:	80 83       	st	Z, r24
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
     2c0:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2c4:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2c8:	76 95       	lsr	r23
     2ca:	67 95       	ror	r22
     2cc:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <HCSR_1>
     2d0:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <HCSR_1+0x1>
     2d4:	0e 94 a4 00 	call	0x148	; 0x148 <HCSR04_FallEdgeTime>
	
	on_timer1_capt_hcsr();
	
}
     2d8:	ff 91       	pop	r31
     2da:	ef 91       	pop	r30
     2dc:	bf 91       	pop	r27
     2de:	af 91       	pop	r26
     2e0:	9f 91       	pop	r25
     2e2:	8f 91       	pop	r24
     2e4:	7f 91       	pop	r23
     2e6:	6f 91       	pop	r22
     2e8:	5f 91       	pop	r21
     2ea:	4f 91       	pop	r20
     2ec:	3f 91       	pop	r19
     2ee:	2f 91       	pop	r18
     2f0:	0f 90       	pop	r0
     2f2:	0f be       	out	0x3f, r0	; 63
     2f4:	0f 90       	pop	r0
     2f6:	1f 90       	pop	r1
     2f8:	18 95       	reti

000002fa <__vector_16>:

ISR(TIMER0_OVF_vect){
     2fa:	1f 92       	push	r1
     2fc:	0f 92       	push	r0
     2fe:	0f b6       	in	r0, 0x3f	; 63
     300:	0f 92       	push	r0
     302:	11 24       	eor	r1, r1
     304:	2f 93       	push	r18
     306:	3f 93       	push	r19
     308:	4f 93       	push	r20
     30a:	5f 93       	push	r21
     30c:	6f 93       	push	r22
     30e:	7f 93       	push	r23
     310:	8f 93       	push	r24
     312:	9f 93       	push	r25
     314:	af 93       	push	r26
     316:	bf 93       	push	r27
     318:	ef 93       	push	r30
     31a:	ff 93       	push	r31
	
	writeServo();
     31c:	0e 94 f3 06 	call	0xde6	; 0xde6 <writeServo>
	
}
     320:	ff 91       	pop	r31
     322:	ef 91       	pop	r30
     324:	bf 91       	pop	r27
     326:	af 91       	pop	r26
     328:	9f 91       	pop	r25
     32a:	8f 91       	pop	r24
     32c:	7f 91       	pop	r23
     32e:	6f 91       	pop	r22
     330:	5f 91       	pop	r21
     332:	4f 91       	pop	r20
     334:	3f 91       	pop	r19
     336:	2f 91       	pop	r18
     338:	0f 90       	pop	r0
     33a:	0f be       	out	0x3f, r0	; 63
     33c:	0f 90       	pop	r0
     33e:	1f 90       	pop	r1
     340:	18 95       	reti

00000342 <__vector_18>:

ISR(USART_RX_vect){
     342:	1f 92       	push	r1
     344:	0f 92       	push	r0
     346:	0f b6       	in	r0, 0x3f	; 63
     348:	0f 92       	push	r0
     34a:	11 24       	eor	r1, r1
     34c:	8f 93       	push	r24
     34e:	9f 93       	push	r25
     350:	af 93       	push	r26
     352:	bf 93       	push	r27
     354:	ef 93       	push	r30
     356:	ff 93       	push	r31
	dataRx.buff[dataRx.indexW++] = UDR0;
     358:	e6 e3       	ldi	r30, 0x36	; 54
     35a:	f2 e0       	ldi	r31, 0x02	; 2
     35c:	a0 81       	ld	r26, Z
     35e:	b1 81       	ldd	r27, Z+1	; 0x01
     360:	83 81       	ldd	r24, Z+3	; 0x03
     362:	91 e0       	ldi	r25, 0x01	; 1
     364:	98 0f       	add	r25, r24
     366:	93 83       	std	Z+3, r25	; 0x03
     368:	a8 0f       	add	r26, r24
     36a:	b1 1d       	adc	r27, r1
     36c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     370:	8c 93       	st	X, r24
	dataRx.indexW &= dataRx.mask;
     372:	85 81       	ldd	r24, Z+5	; 0x05
     374:	93 81       	ldd	r25, Z+3	; 0x03
     376:	89 23       	and	r24, r25
     378:	83 83       	std	Z+3, r24	; 0x03
}
     37a:	ff 91       	pop	r31
     37c:	ef 91       	pop	r30
     37e:	bf 91       	pop	r27
     380:	af 91       	pop	r26
     382:	9f 91       	pop	r25
     384:	8f 91       	pop	r24
     386:	0f 90       	pop	r0
     388:	0f be       	out	0x3f, r0	; 63
     38a:	0f 90       	pop	r0
     38c:	1f 90       	pop	r1
     38e:	18 95       	reti

00000390 <ini_ports>:
void ini_ports(){
	
	/************************************************************************/
	/*								OUTPUTS                                 */
	/************************************************************************/
	DDRB = ((1 << LED_BI)| (1 << SV1) | (1 << SV2) | (1<<TRIGGER));
     390:	8a e3       	ldi	r24, 0x3A	; 58
     392:	84 b9       	out	0x04, r24	; 4
	DDRD = (1 << SV0);
     394:	80 e8       	ldi	r24, 0x80	; 128
     396:	8a b9       	out	0x0a, r24	; 10
	
	/************************************************************************/
	/*								INPUTS                                  */
	/************************************************************************/
	DDRB &= ~(1<<ECHO);
     398:	84 b1       	in	r24, 0x04	; 4
     39a:	8e 7f       	andi	r24, 0xFE	; 254
     39c:	84 b9       	out	0x04, r24	; 4
	DDRD &= ~((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     39e:	8a b1       	in	r24, 0x0a	; 10
     3a0:	83 7c       	andi	r24, 0xC3	; 195
     3a2:	8a b9       	out	0x0a, r24	; 10
	
	/*						Activo Pull ups internos						*/
	PORTB = (1<<ECHO);
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	85 b9       	out	0x05, r24	; 5
	PORTD = ((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3a8:	8c e3       	ldi	r24, 0x3C	; 60
     3aa:	8b b9       	out	0x0b, r24	; 11
     3ac:	08 95       	ret

000003ae <ini_timer1>:
/************************************************************************/
/*		Timer 1 es funcional al HCSR y a la accion cada 10ms            */
/************************************************************************/
void ini_timer1(){
	
	TCCR1A = 0x00;
     3ae:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
	/* Configuro noise canceler del input capture, el flanco del input capture y prescaler en 8 (f = 16MHz / 8 = 2MHz ? 1 tick = 0.5 µs) */
	TCCR1B = 0xC2;
     3b2:	82 ec       	ldi	r24, 0xC2	; 194
     3b4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
	TCNT1 = 0x00;
     3b8:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     3bc:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
	/*	Activo la interrupcion por comparador b	*/
	TIMSK1 = (1<<OCIE1A);
     3c0:	82 e0       	ldi	r24, 0x02	; 2
     3c2:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	/* Le doy un valor al comparador B	*/
	OCR1A = 19999;
     3c6:	8f e1       	ldi	r24, 0x1F	; 31
     3c8:	9e e4       	ldi	r25, 0x4E	; 78
     3ca:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     3ce:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
	TIFR1 = TIFR1;
     3d2:	86 b3       	in	r24, 0x16	; 22
     3d4:	86 bb       	out	0x16, r24	; 22
     3d6:	08 95       	ret

000003d8 <ini_timer0>:
/************************************************************************/
/*			Timer 0 funcional a generar el pwm de los servos			*/
/************************************************************************/
void ini_timer0(){
	
	TCCR0A = 0;
     3d8:	14 bc       	out	0x24, r1	; 36
	TCNT0 = 0;
     3da:	16 bc       	out	0x26, r1	; 38
	/*	Pongo las banderas en 0 con TIFR	*/
	TIFR0 = 0x07;
     3dc:	87 e0       	ldi	r24, 0x07	; 7
     3de:	85 bb       	out	0x15, r24	; 21
	/*	Habilito la interrupcion por TOV	*/
	TIMSK0 = (1<<TOIE0);
     3e0:	81 e0       	ldi	r24, 0x01	; 1
     3e2:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
	/*	Prescaler en 8 , obtengo el cuentas de 500ns, tov a 500*256 = 128us		*/
	TCCR0B = (1<<CS01);
     3e6:	82 e0       	ldi	r24, 0x02	; 2
     3e8:	85 bd       	out	0x25, r24	; 37
     3ea:	08 95       	ret

000003ec <ini_USART>:
	
}

void ini_USART(uint8_t ubrr){
	UBRR0H = 0;
     3ec:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = ubrr;
     3f0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	UCSR0A = 0xFE; //inicializo todas las banderas excepto el multiprocesor
     3f4:	8e ef       	ldi	r24, 0xFE	; 254
     3f6:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	UCSR0B =   0x98; // (1<<RXCIE0) | (1<<RXEN0)|(1<<TXEN0); //Activo las banderas de interrupcion de recepcion y la habilitacion del rx y tx
     3fa:	88 e9       	ldi	r24, 0x98	; 152
     3fc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
     400:	86 e0       	ldi	r24, 0x06	; 6
     402:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     406:	08 95       	ret

00000408 <IR_Init>:
	
}

void IR_Init(IRDebounce *ir) {
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     408:	20 e0       	ldi	r18, 0x00	; 0
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	0c c0       	rjmp	.+24     	; 0x426 <IR_Init+0x1e>
		ir[globalIndex].state = IR_RISING;
     40e:	f9 01       	movw	r30, r18
     410:	ee 0f       	add	r30, r30
     412:	ff 1f       	adc	r31, r31
     414:	ee 0f       	add	r30, r30
     416:	ff 1f       	adc	r31, r31
     418:	e8 0f       	add	r30, r24
     41a:	f9 1f       	adc	r31, r25
     41c:	10 82       	st	Z, r1
		ir[globalIndex].last_sample = 0;
     41e:	12 82       	std	Z+2, r1	; 0x02
		ir[globalIndex].stateConfirmed = 0;
     420:	11 82       	std	Z+1, r1	; 0x01
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
	
}

void IR_Init(IRDebounce *ir) {
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     422:	2f 5f       	subi	r18, 0xFF	; 255
     424:	3f 4f       	sbci	r19, 0xFF	; 255
     426:	24 30       	cpi	r18, 0x04	; 4
     428:	31 05       	cpc	r19, r1
     42a:	8c f3       	brlt	.-30     	; 0x40e <IR_Init+0x6>
		ir[globalIndex].state = IR_RISING;
		ir[globalIndex].last_sample = 0;
		ir[globalIndex].stateConfirmed = 0;
	}
}
     42c:	08 95       	ret

0000042e <IR_Update>:

void IR_Update(IRDebounce *ir, uint8_t sample) {
     42e:	fc 01       	movw	r30, r24
	switch (ir->state) {
     430:	80 81       	ld	r24, Z
     432:	81 30       	cpi	r24, 0x01	; 1
     434:	89 f0       	breq	.+34     	; 0x458 <IR_Update+0x2a>
     436:	28 f0       	brcs	.+10     	; 0x442 <IR_Update+0x14>
     438:	82 30       	cpi	r24, 0x02	; 2
     43a:	b1 f0       	breq	.+44     	; 0x468 <IR_Update+0x3a>
     43c:	83 30       	cpi	r24, 0x03	; 3
     43e:	01 f1       	breq	.+64     	; 0x480 <IR_Update+0x52>
     440:	26 c0       	rjmp	.+76     	; 0x48e <IR_Update+0x60>
		case IR_RISING:
		if (sample == 1 && ir->last_sample == 1){
     442:	61 30       	cpi	r22, 0x01	; 1
     444:	31 f4       	brne	.+12     	; 0x452 <IR_Update+0x24>
     446:	82 81       	ldd	r24, Z+2	; 0x02
     448:	81 30       	cpi	r24, 0x01	; 1
     44a:	19 f4       	brne	.+6      	; 0x452 <IR_Update+0x24>
			ir->state = IR_UP;
     44c:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x01;
     44e:	81 83       	std	Z+1, r24	; 0x01
     450:	20 c0       	rjmp	.+64     	; 0x492 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     452:	83 e0       	ldi	r24, 0x03	; 3
     454:	80 83       	st	Z, r24
     456:	1d c0       	rjmp	.+58     	; 0x492 <IR_Update+0x64>
		}
		break;

		case IR_UP:
		if (sample == 0){
     458:	61 11       	cpse	r22, r1
     45a:	03 c0       	rjmp	.+6      	; 0x462 <IR_Update+0x34>
			ir->state = IR_FALLING;
     45c:	82 e0       	ldi	r24, 0x02	; 2
     45e:	80 83       	st	Z, r24
     460:	18 c0       	rjmp	.+48     	; 0x492 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     462:	81 e0       	ldi	r24, 0x01	; 1
     464:	80 83       	st	Z, r24
     466:	15 c0       	rjmp	.+42     	; 0x492 <IR_Update+0x64>
		}
		break;

		case IR_FALLING:
		if (sample == 0 && ir->last_sample == 0){
     468:	61 11       	cpse	r22, r1
     46a:	07 c0       	rjmp	.+14     	; 0x47a <IR_Update+0x4c>
     46c:	82 81       	ldd	r24, Z+2	; 0x02
     46e:	81 11       	cpse	r24, r1
     470:	04 c0       	rjmp	.+8      	; 0x47a <IR_Update+0x4c>
			ir->state = IR_DOWN;
     472:	83 e0       	ldi	r24, 0x03	; 3
     474:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x00;
     476:	11 82       	std	Z+1, r1	; 0x01
     478:	0c c0       	rjmp	.+24     	; 0x492 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     47a:	81 e0       	ldi	r24, 0x01	; 1
     47c:	80 83       	st	Z, r24
     47e:	09 c0       	rjmp	.+18     	; 0x492 <IR_Update+0x64>
		}
		break;

		case IR_DOWN:
		if (sample == 1){
     480:	61 30       	cpi	r22, 0x01	; 1
     482:	11 f4       	brne	.+4      	; 0x488 <IR_Update+0x5a>
			ir->state = IR_RISING;
     484:	10 82       	st	Z, r1
     486:	05 c0       	rjmp	.+10     	; 0x492 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     488:	83 e0       	ldi	r24, 0x03	; 3
     48a:	80 83       	st	Z, r24
     48c:	02 c0       	rjmp	.+4      	; 0x492 <IR_Update+0x64>
		}
		break;
		default:
		ir->state = IR_UP;
     48e:	81 e0       	ldi	r24, 0x01	; 1
     490:	80 83       	st	Z, r24
		break;
	}

	ir->last_sample = sample;
     492:	62 83       	std	Z+2, r22	; 0x02
     494:	08 95       	ret

00000496 <IR_GetState>:
}

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}
     496:	fc 01       	movw	r30, r24
     498:	81 81       	ldd	r24, Z+1	; 0x01
     49a:	08 95       	ret

0000049c <putHeaderOnTx>:
			dataTx->indexR &= dataTx->mask;
		}
	}
}

uint8_t putHeaderOnTx(_sTx  *dataTx, _eCmd ID, uint8_t frameLength){
     49c:	fc 01       	movw	r30, r24
	dataTx->chk = 0;
     49e:	15 82       	std	Z+5, r1	; 0x05
	dataTx->buff[dataTx->indexW++]='U';
     4a0:	a0 81       	ld	r26, Z
     4a2:	b1 81       	ldd	r27, Z+1	; 0x01
     4a4:	83 81       	ldd	r24, Z+3	; 0x03
     4a6:	91 e0       	ldi	r25, 0x01	; 1
     4a8:	98 0f       	add	r25, r24
     4aa:	93 83       	std	Z+3, r25	; 0x03
     4ac:	a8 0f       	add	r26, r24
     4ae:	b1 1d       	adc	r27, r1
     4b0:	85 e5       	ldi	r24, 0x55	; 85
     4b2:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4b4:	84 81       	ldd	r24, Z+4	; 0x04
     4b6:	93 81       	ldd	r25, Z+3	; 0x03
     4b8:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='N';
     4ba:	a0 81       	ld	r26, Z
     4bc:	b1 81       	ldd	r27, Z+1	; 0x01
     4be:	81 e0       	ldi	r24, 0x01	; 1
     4c0:	89 0f       	add	r24, r25
     4c2:	83 83       	std	Z+3, r24	; 0x03
     4c4:	a9 0f       	add	r26, r25
     4c6:	b1 1d       	adc	r27, r1
     4c8:	8e e4       	ldi	r24, 0x4E	; 78
     4ca:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4cc:	84 81       	ldd	r24, Z+4	; 0x04
     4ce:	93 81       	ldd	r25, Z+3	; 0x03
     4d0:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='E';
     4d2:	a0 81       	ld	r26, Z
     4d4:	b1 81       	ldd	r27, Z+1	; 0x01
     4d6:	81 e0       	ldi	r24, 0x01	; 1
     4d8:	89 0f       	add	r24, r25
     4da:	83 83       	std	Z+3, r24	; 0x03
     4dc:	a9 0f       	add	r26, r25
     4de:	b1 1d       	adc	r27, r1
     4e0:	85 e4       	ldi	r24, 0x45	; 69
     4e2:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4e4:	84 81       	ldd	r24, Z+4	; 0x04
     4e6:	93 81       	ldd	r25, Z+3	; 0x03
     4e8:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='R';
     4ea:	a0 81       	ld	r26, Z
     4ec:	b1 81       	ldd	r27, Z+1	; 0x01
     4ee:	81 e0       	ldi	r24, 0x01	; 1
     4f0:	89 0f       	add	r24, r25
     4f2:	83 83       	std	Z+3, r24	; 0x03
     4f4:	a9 0f       	add	r26, r25
     4f6:	b1 1d       	adc	r27, r1
     4f8:	82 e5       	ldi	r24, 0x52	; 82
     4fa:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4fc:	84 81       	ldd	r24, Z+4	; 0x04
     4fe:	93 81       	ldd	r25, Z+3	; 0x03
     500:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=frameLength+1;
     502:	a0 81       	ld	r26, Z
     504:	b1 81       	ldd	r27, Z+1	; 0x01
     506:	81 e0       	ldi	r24, 0x01	; 1
     508:	89 0f       	add	r24, r25
     50a:	83 83       	std	Z+3, r24	; 0x03
     50c:	a9 0f       	add	r26, r25
     50e:	b1 1d       	adc	r27, r1
     510:	4f 5f       	subi	r20, 0xFF	; 255
     512:	4c 93       	st	X, r20
	dataTx->indexW &= dataTx->mask;
     514:	84 81       	ldd	r24, Z+4	; 0x04
     516:	93 81       	ldd	r25, Z+3	; 0x03
     518:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=':';
     51a:	a0 81       	ld	r26, Z
     51c:	b1 81       	ldd	r27, Z+1	; 0x01
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	89 0f       	add	r24, r25
     522:	83 83       	std	Z+3, r24	; 0x03
     524:	a9 0f       	add	r26, r25
     526:	b1 1d       	adc	r27, r1
     528:	8a e3       	ldi	r24, 0x3A	; 58
     52a:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     52c:	84 81       	ldd	r24, Z+4	; 0x04
     52e:	93 81       	ldd	r25, Z+3	; 0x03
     530:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=ID;
     532:	a0 81       	ld	r26, Z
     534:	b1 81       	ldd	r27, Z+1	; 0x01
     536:	81 e0       	ldi	r24, 0x01	; 1
     538:	89 0f       	add	r24, r25
     53a:	83 83       	std	Z+3, r24	; 0x03
     53c:	a9 0f       	add	r26, r25
     53e:	b1 1d       	adc	r27, r1
     540:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     542:	94 81       	ldd	r25, Z+4	; 0x04
     544:	83 81       	ldd	r24, Z+3	; 0x03
     546:	98 23       	and	r25, r24
     548:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= (frameLength+1);
     54a:	95 81       	ldd	r25, Z+5	; 0x05
     54c:	49 27       	eor	r20, r25
	dataTx->chk ^= ('U' ^'N' ^'E' ^'R' ^ID ^':') ;
     54e:	64 27       	eor	r22, r20
     550:	86 e3       	ldi	r24, 0x36	; 54
     552:	86 27       	eor	r24, r22
     554:	85 83       	std	Z+5, r24	; 0x05
	return  dataTx->chk;
}
     556:	08 95       	ret

00000558 <putByteOnTx>:
uint8_t putByteOnTx(_sTx *dataTx, uint8_t byte)
{
     558:	fc 01       	movw	r30, r24
	dataTx->buff[dataTx->indexW++]=byte;
     55a:	a0 81       	ld	r26, Z
     55c:	b1 81       	ldd	r27, Z+1	; 0x01
     55e:	83 81       	ldd	r24, Z+3	; 0x03
     560:	91 e0       	ldi	r25, 0x01	; 1
     562:	98 0f       	add	r25, r24
     564:	93 83       	std	Z+3, r25	; 0x03
     566:	a8 0f       	add	r26, r24
     568:	b1 1d       	adc	r27, r1
     56a:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     56c:	94 81       	ldd	r25, Z+4	; 0x04
     56e:	83 81       	ldd	r24, Z+3	; 0x03
     570:	98 23       	and	r25, r24
     572:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= byte;
     574:	85 81       	ldd	r24, Z+5	; 0x05
     576:	86 27       	eor	r24, r22
     578:	85 83       	std	Z+5, r24	; 0x05
	return dataTx->chk;
}
     57a:	08 95       	ret

0000057c <decodeCommand>:
void decodeCommand(_sRx *dataRx, _sTx *dataTx){
     57c:	0f 93       	push	r16
     57e:	1f 93       	push	r17
     580:	cf 93       	push	r28
     582:	df 93       	push	r29
     584:	eb 01       	movw	r28, r22
	switch(dataRx->buff[dataRx->indexData]){
     586:	dc 01       	movw	r26, r24
     588:	ed 91       	ld	r30, X+
     58a:	fc 91       	ld	r31, X
     58c:	11 97       	sbiw	r26, 0x01	; 1
     58e:	14 96       	adiw	r26, 0x04	; 4
     590:	8c 91       	ld	r24, X
     592:	e8 0f       	add	r30, r24
     594:	f1 1d       	adc	r31, r1
     596:	60 81       	ld	r22, Z
     598:	68 3a       	cpi	r22, 0xA8	; 168
     59a:	78 f4       	brcc	.+30     	; 0x5ba <decodeCommand+0x3e>
     59c:	64 3a       	cpi	r22, 0xA4	; 164
     59e:	08 f0       	brcs	.+2      	; 0x5a2 <decodeCommand+0x26>
     5a0:	b9 c0       	rjmp	.+370    	; 0x714 <decodeCommand+0x198>
     5a2:	63 3a       	cpi	r22, 0xA3	; 163
     5a4:	08 f0       	brcs	.+2      	; 0x5a8 <decodeCommand+0x2c>
     5a6:	43 c0       	rjmp	.+134    	; 0x62e <decodeCommand+0xb2>
     5a8:	60 3a       	cpi	r22, 0xA0	; 160
     5aa:	08 f0       	brcs	.+2      	; 0x5ae <decodeCommand+0x32>
     5ac:	b3 c0       	rjmp	.+358    	; 0x714 <decodeCommand+0x198>
     5ae:	60 31       	cpi	r22, 0x10	; 16
     5b0:	01 f1       	breq	.+64     	; 0x5f2 <decodeCommand+0x76>
     5b2:	62 31       	cpi	r22, 0x12	; 18
     5b4:	09 f0       	breq	.+2      	; 0x5b8 <decodeCommand+0x3c>
     5b6:	a2 c0       	rjmp	.+324    	; 0x6fc <decodeCommand+0x180>
     5b8:	ad c0       	rjmp	.+346    	; 0x714 <decodeCommand+0x198>
     5ba:	6e 3d       	cpi	r22, 0xDE	; 222
     5bc:	09 f4       	brne	.+2      	; 0x5c0 <decodeCommand+0x44>
     5be:	aa c0       	rjmp	.+340    	; 0x714 <decodeCommand+0x198>
     5c0:	20 f4       	brcc	.+8      	; 0x5ca <decodeCommand+0x4e>
     5c2:	6a 3a       	cpi	r22, 0xAA	; 170
     5c4:	09 f4       	brne	.+2      	; 0x5c8 <decodeCommand+0x4c>
     5c6:	51 c0       	rjmp	.+162    	; 0x66a <decodeCommand+0xee>
     5c8:	99 c0       	rjmp	.+306    	; 0x6fc <decodeCommand+0x180>
     5ca:	60 3f       	cpi	r22, 0xF0	; 240
     5cc:	21 f0       	breq	.+8      	; 0x5d6 <decodeCommand+0x5a>
     5ce:	61 3f       	cpi	r22, 0xF1	; 241
     5d0:	09 f0       	breq	.+2      	; 0x5d4 <decodeCommand+0x58>
     5d2:	94 c0       	rjmp	.+296    	; 0x6fc <decodeCommand+0x180>
     5d4:	9f c0       	rjmp	.+318    	; 0x714 <decodeCommand+0x198>
		case ALIVE:
		putHeaderOnTx(dataTx, ALIVE, 2);
     5d6:	42 e0       	ldi	r20, 0x02	; 2
     5d8:	60 ef       	ldi	r22, 0xF0	; 240
     5da:	ce 01       	movw	r24, r28
     5dc:	0e 94 4e 02 	call	0x49c	; 0x49c <putHeaderOnTx>
		putByteOnTx(dataTx, ACK );
     5e0:	6d e0       	ldi	r22, 0x0D	; 13
     5e2:	ce 01       	movw	r24, r28
     5e4:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
		putByteOnTx(dataTx, dataTx->chk);
     5e8:	6d 81       	ldd	r22, Y+5	; 0x05
     5ea:	ce 01       	movw	r24, r28
     5ec:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
		break;
     5f0:	91 c0       	rjmp	.+290    	; 0x714 <decodeCommand+0x198>
		case FIRMWARE:
		break;
		case LEDSTATUS:
		myWord.ui16[0] = IR_GetState(&ir_sensor[0]);
     5f2:	81 e5       	ldi	r24, 0x51	; 81
     5f4:	92 e0       	ldi	r25, 0x02	; 2
     5f6:	0e 94 4b 02 	call	0x496	; 0x496 <IR_GetState>
     5fa:	0d e4       	ldi	r16, 0x4D	; 77
     5fc:	12 e0       	ldi	r17, 0x02	; 2
     5fe:	90 e0       	ldi	r25, 0x00	; 0
     600:	f8 01       	movw	r30, r16
     602:	91 83       	std	Z+1, r25	; 0x01
     604:	80 83       	st	Z, r24
		putHeaderOnTx(dataTx, LEDSTATUS, 3);
     606:	43 e0       	ldi	r20, 0x03	; 3
     608:	60 e1       	ldi	r22, 0x10	; 16
     60a:	ce 01       	movw	r24, r28
     60c:	0e 94 4e 02 	call	0x49c	; 0x49c <putHeaderOnTx>
		putByteOnTx(dataTx, myWord.ui8[0] );
     610:	d8 01       	movw	r26, r16
     612:	6c 91       	ld	r22, X
     614:	ce 01       	movw	r24, r28
     616:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
		putByteOnTx(dataTx, myWord.ui8[1] );
     61a:	f8 01       	movw	r30, r16
     61c:	61 81       	ldd	r22, Z+1	; 0x01
     61e:	ce 01       	movw	r24, r28
     620:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
		putByteOnTx(dataTx, dataTx->chk);
     624:	6d 81       	ldd	r22, Y+5	; 0x05
     626:	ce 01       	movw	r24, r28
     628:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
		break;
     62c:	73 c0       	rjmp	.+230    	; 0x714 <decodeCommand+0x198>
		case SERVOANGLE:
		break;
		case CONFIGSERVO:
		break;
		case GETDISTANCE:
			myWord.ui16[0]	= globalDistance;
     62e:	0d e4       	ldi	r16, 0x4D	; 77
     630:	12 e0       	ldi	r17, 0x02	; 2
     632:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <globalDistance>
     636:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <globalDistance+0x1>
     63a:	d8 01       	movw	r26, r16
     63c:	8d 93       	st	X+, r24
     63e:	9c 93       	st	X, r25
			putHeaderOnTx(dataTx, GETDISTANCE, 3);
     640:	43 e0       	ldi	r20, 0x03	; 3
     642:	63 ea       	ldi	r22, 0xA3	; 163
     644:	ce 01       	movw	r24, r28
     646:	0e 94 4e 02 	call	0x49c	; 0x49c <putHeaderOnTx>
			putByteOnTx(dataTx, myWord.ui8[0]);
     64a:	f8 01       	movw	r30, r16
     64c:	60 81       	ld	r22, Z
     64e:	ce 01       	movw	r24, r28
     650:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     654:	d8 01       	movw	r26, r16
     656:	11 96       	adiw	r26, 0x01	; 1
     658:	6c 91       	ld	r22, X
     65a:	ce 01       	movw	r24, r28
     65c:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     660:	6d 81       	ldd	r22, Y+5	; 0x05
     662:	ce 01       	movw	r24, r28
     664:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
		break;
     668:	55 c0       	rjmp	.+170    	; 0x714 <decodeCommand+0x198>
		case GETSPEED:
		break;
		case STARTSTOP:
		break;
		case NEWBOX:
			myWord.ui8[0]=boxToTx;
     66a:	0d e4       	ldi	r16, 0x4D	; 77
     66c:	12 e0       	ldi	r17, 0x02	; 2
     66e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <boxToTx>
     672:	f8 01       	movw	r30, r16
     674:	80 83       	st	Z, r24
			putHeaderOnTx(dataTx, NEWBOX, 8);
     676:	48 e0       	ldi	r20, 0x08	; 8
     678:	6a ea       	ldi	r22, 0xAA	; 170
     67a:	ce 01       	movw	r24, r28
     67c:	0e 94 4e 02 	call	0x49c	; 0x49c <putHeaderOnTx>
			putByteOnTx(dataTx, myWord.ui8[0]);
     680:	d8 01       	movw	r26, r16
     682:	6c 91       	ld	r22, X
     684:	ce 01       	movw	r24, r28
     686:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			myWord.ui16[0]	= globalDistance;
     68a:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <globalDistance>
     68e:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <globalDistance+0x1>
     692:	68 2f       	mov	r22, r24
     694:	f8 01       	movw	r30, r16
     696:	80 83       	st	Z, r24
     698:	91 83       	std	Z+1, r25	; 0x01
			putByteOnTx(dataTx, myWord.ui8[0]);
     69a:	ce 01       	movw	r24, r28
     69c:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     6a0:	d8 01       	movw	r26, r16
     6a2:	11 96       	adiw	r26, 0x01	; 1
     6a4:	6c 91       	ld	r22, X
     6a6:	ce 01       	movw	r24, r28
     6a8:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			myWord.ui16[0] = IR_GetState(&ir_sensor[0]);
     6ac:	81 e5       	ldi	r24, 0x51	; 81
     6ae:	92 e0       	ldi	r25, 0x02	; 2
     6b0:	0e 94 4b 02 	call	0x496	; 0x496 <IR_GetState>
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	68 2f       	mov	r22, r24
     6b8:	f8 01       	movw	r30, r16
     6ba:	91 83       	std	Z+1, r25	; 0x01
     6bc:	80 83       	st	Z, r24
			putByteOnTx(dataTx, myWord.ui8[0]);
     6be:	ce 01       	movw	r24, r28
     6c0:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     6c4:	d8 01       	movw	r26, r16
     6c6:	11 96       	adiw	r26, 0x01	; 1
     6c8:	6c 91       	ld	r22, X
     6ca:	ce 01       	movw	r24, r28
     6cc:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			myWord.ui16[0] = Numbox;
     6d0:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <Numbox>
     6d4:	90 91 29 01 	lds	r25, 0x0129	; 0x800129 <Numbox+0x1>
     6d8:	68 2f       	mov	r22, r24
     6da:	f8 01       	movw	r30, r16
     6dc:	80 83       	st	Z, r24
     6de:	91 83       	std	Z+1, r25	; 0x01
			putByteOnTx(dataTx, myWord.ui8[0]);
     6e0:	ce 01       	movw	r24, r28
     6e2:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     6e6:	d8 01       	movw	r26, r16
     6e8:	11 96       	adiw	r26, 0x01	; 1
     6ea:	6c 91       	ld	r22, X
     6ec:	ce 01       	movw	r24, r28
     6ee:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     6f2:	6d 81       	ldd	r22, Y+5	; 0x05
     6f4:	ce 01       	movw	r24, r28
     6f6:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
			
		break;
     6fa:	0c c0       	rjmp	.+24     	; 0x714 <decodeCommand+0x198>

		default:
		putHeaderOnTx(dataTx, (_eCmd)dataRx->buff[dataRx->indexData], 2);
     6fc:	42 e0       	ldi	r20, 0x02	; 2
     6fe:	ce 01       	movw	r24, r28
     700:	0e 94 4e 02 	call	0x49c	; 0x49c <putHeaderOnTx>
		putByteOnTx(dataTx,UNKNOWN );
     704:	6f ef       	ldi	r22, 0xFF	; 255
     706:	ce 01       	movw	r24, r28
     708:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
		putByteOnTx(dataTx, dataTx->chk);
     70c:	6d 81       	ldd	r22, Y+5	; 0x05
     70e:	ce 01       	movw	r24, r28
     710:	0e 94 ac 02 	call	0x558	; 0x558 <putByteOnTx>
		break;
		
	}
}
     714:	df 91       	pop	r29
     716:	cf 91       	pop	r28
     718:	1f 91       	pop	r17
     71a:	0f 91       	pop	r16
     71c:	08 95       	ret

0000071e <decodeHeader>:
void decodeHeader(_sRx *dataRx){
     71e:	dc 01       	movw	r26, r24
	uint8_t auxIndex=dataRx->indexW;
     720:	13 96       	adiw	r26, 0x03	; 3
     722:	2c 91       	ld	r18, X
     724:	13 97       	sbiw	r26, 0x03	; 3
	while(dataRx->indexR != auxIndex){
     726:	c9 c0       	rjmp	.+402    	; 0x8ba <__DATA_REGION_LENGTH__+0xba>
		switch(dataRx->header)
     728:	18 96       	adiw	r26, 0x08	; 8
     72a:	ec 91       	ld	r30, X
     72c:	18 97       	sbiw	r26, 0x08	; 8
     72e:	4e 2f       	mov	r20, r30
     730:	50 e0       	ldi	r21, 0x00	; 0
     732:	47 30       	cpi	r20, 0x07	; 7
     734:	51 05       	cpc	r21, r1
     736:	08 f0       	brcs	.+2      	; 0x73a <decodeHeader+0x1c>
     738:	b2 c0       	rjmp	.+356    	; 0x89e <__DATA_REGION_LENGTH__+0x9e>
     73a:	fa 01       	movw	r30, r20
     73c:	ec 5c       	subi	r30, 0xCC	; 204
     73e:	ff 4f       	sbci	r31, 0xFF	; 255
     740:	0c 94 50 07 	jmp	0xea0	; 0xea0 <__tablejump2__>
		{
			case HEADER_U:
			if(dataRx->buff[dataRx->indexR] == 'U'){
     744:	ed 91       	ld	r30, X+
     746:	fc 91       	ld	r31, X
     748:	11 97       	sbiw	r26, 0x01	; 1
     74a:	e8 0f       	add	r30, r24
     74c:	f1 1d       	adc	r31, r1
     74e:	80 81       	ld	r24, Z
     750:	85 35       	cpi	r24, 0x55	; 85
     752:	09 f0       	breq	.+2      	; 0x756 <decodeHeader+0x38>
     754:	a7 c0       	rjmp	.+334    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
				dataRx->header = HEADER_N;
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	18 96       	adiw	r26, 0x08	; 8
     75a:	8c 93       	st	X, r24
     75c:	18 97       	sbiw	r26, 0x08	; 8
     75e:	a2 c0       	rjmp	.+324    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
			}
			break;
			case HEADER_N:
			if(dataRx->buff[dataRx->indexR] == 'N'){
     760:	ed 91       	ld	r30, X+
     762:	fc 91       	ld	r31, X
     764:	11 97       	sbiw	r26, 0x01	; 1
     766:	e8 0f       	add	r30, r24
     768:	f1 1d       	adc	r31, r1
     76a:	90 81       	ld	r25, Z
     76c:	9e 34       	cpi	r25, 0x4E	; 78
     76e:	29 f4       	brne	.+10     	; 0x77a <decodeHeader+0x5c>
				dataRx->header = HEADER_E;
     770:	82 e0       	ldi	r24, 0x02	; 2
     772:	18 96       	adiw	r26, 0x08	; 8
     774:	8c 93       	st	X, r24
     776:	18 97       	sbiw	r26, 0x08	; 8
     778:	95 c0       	rjmp	.+298    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
				}else{
				if(dataRx->buff[dataRx->indexR] != 'U'){
     77a:	95 35       	cpi	r25, 0x55	; 85
     77c:	09 f4       	brne	.+2      	; 0x780 <decodeHeader+0x62>
     77e:	92 c0       	rjmp	.+292    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
					dataRx->header = HEADER_U;
     780:	18 96       	adiw	r26, 0x08	; 8
     782:	1c 92       	st	X, r1
     784:	18 97       	sbiw	r26, 0x08	; 8
					dataRx->indexR--;
     786:	81 50       	subi	r24, 0x01	; 1
     788:	12 96       	adiw	r26, 0x02	; 2
     78a:	8c 93       	st	X, r24
     78c:	12 97       	sbiw	r26, 0x02	; 2
     78e:	8a c0       	rjmp	.+276    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
				}
			}
			break;
			case HEADER_E:
			if(dataRx->buff[dataRx->indexR] == 'E'){
     790:	ed 91       	ld	r30, X+
     792:	fc 91       	ld	r31, X
     794:	11 97       	sbiw	r26, 0x01	; 1
     796:	e8 0f       	add	r30, r24
     798:	f1 1d       	adc	r31, r1
     79a:	90 81       	ld	r25, Z
     79c:	95 34       	cpi	r25, 0x45	; 69
     79e:	29 f4       	brne	.+10     	; 0x7aa <decodeHeader+0x8c>
				dataRx->header = HEADER_R;
     7a0:	83 e0       	ldi	r24, 0x03	; 3
     7a2:	18 96       	adiw	r26, 0x08	; 8
     7a4:	8c 93       	st	X, r24
     7a6:	18 97       	sbiw	r26, 0x08	; 8
     7a8:	7d c0       	rjmp	.+250    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
				}else{
				dataRx->header = HEADER_U;
     7aa:	18 96       	adiw	r26, 0x08	; 8
     7ac:	1c 92       	st	X, r1
     7ae:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     7b0:	81 50       	subi	r24, 0x01	; 1
     7b2:	12 96       	adiw	r26, 0x02	; 2
     7b4:	8c 93       	st	X, r24
     7b6:	12 97       	sbiw	r26, 0x02	; 2
     7b8:	75 c0       	rjmp	.+234    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
			}
			break;
			case HEADER_R:
			if(dataRx->buff[dataRx->indexR] == 'R'){
     7ba:	ed 91       	ld	r30, X+
     7bc:	fc 91       	ld	r31, X
     7be:	11 97       	sbiw	r26, 0x01	; 1
     7c0:	e8 0f       	add	r30, r24
     7c2:	f1 1d       	adc	r31, r1
     7c4:	90 81       	ld	r25, Z
     7c6:	92 35       	cpi	r25, 0x52	; 82
     7c8:	29 f4       	brne	.+10     	; 0x7d4 <decodeHeader+0xb6>
				dataRx->header = NBYTES;
     7ca:	84 e0       	ldi	r24, 0x04	; 4
     7cc:	18 96       	adiw	r26, 0x08	; 8
     7ce:	8c 93       	st	X, r24
     7d0:	18 97       	sbiw	r26, 0x08	; 8
     7d2:	68 c0       	rjmp	.+208    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
				}else{
				dataRx->header = HEADER_U;
     7d4:	18 96       	adiw	r26, 0x08	; 8
     7d6:	1c 92       	st	X, r1
     7d8:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     7da:	81 50       	subi	r24, 0x01	; 1
     7dc:	12 96       	adiw	r26, 0x02	; 2
     7de:	8c 93       	st	X, r24
     7e0:	12 97       	sbiw	r26, 0x02	; 2
     7e2:	60 c0       	rjmp	.+192    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
			}
			break;
			case NBYTES:
			dataRx->nBytes=dataRx->buff[dataRx->indexR];
     7e4:	ed 91       	ld	r30, X+
     7e6:	fc 91       	ld	r31, X
     7e8:	11 97       	sbiw	r26, 0x01	; 1
     7ea:	e8 0f       	add	r30, r24
     7ec:	f1 1d       	adc	r31, r1
     7ee:	80 81       	ld	r24, Z
     7f0:	17 96       	adiw	r26, 0x07	; 7
     7f2:	8c 93       	st	X, r24
     7f4:	17 97       	sbiw	r26, 0x07	; 7
			dataRx->header = TOKEN;
     7f6:	85 e0       	ldi	r24, 0x05	; 5
     7f8:	18 96       	adiw	r26, 0x08	; 8
     7fa:	8c 93       	st	X, r24
     7fc:	18 97       	sbiw	r26, 0x08	; 8
			break;
     7fe:	52 c0       	rjmp	.+164    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
			case TOKEN:
			if(dataRx->buff[dataRx->indexR] == ':'){
     800:	ed 91       	ld	r30, X+
     802:	fc 91       	ld	r31, X
     804:	11 97       	sbiw	r26, 0x01	; 1
     806:	e8 0f       	add	r30, r24
     808:	f1 1d       	adc	r31, r1
     80a:	90 81       	ld	r25, Z
     80c:	9a 33       	cpi	r25, 0x3A	; 58
     80e:	a9 f4       	brne	.+42     	; 0x83a <__DATA_REGION_LENGTH__+0x3a>
				dataRx->header = PAYLOAD;
     810:	96 e0       	ldi	r25, 0x06	; 6
     812:	18 96       	adiw	r26, 0x08	; 8
     814:	9c 93       	st	X, r25
     816:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexData = dataRx->indexR+1;
     818:	8f 5f       	subi	r24, 0xFF	; 255
				dataRx->indexData &= dataRx->mask;
     81a:	15 96       	adiw	r26, 0x05	; 5
     81c:	9c 91       	ld	r25, X
     81e:	15 97       	sbiw	r26, 0x05	; 5
     820:	89 23       	and	r24, r25
     822:	14 96       	adiw	r26, 0x04	; 4
     824:	8c 93       	st	X, r24
     826:	14 97       	sbiw	r26, 0x04	; 4
				dataRx->chk = 0;
				dataRx->chk ^= ('U' ^'N' ^'E' ^'R' ^dataRx->nBytes ^':') ;
     828:	17 96       	adiw	r26, 0x07	; 7
     82a:	9c 91       	ld	r25, X
     82c:	17 97       	sbiw	r26, 0x07	; 7
     82e:	86 e3       	ldi	r24, 0x36	; 54
     830:	89 27       	eor	r24, r25
     832:	16 96       	adiw	r26, 0x06	; 6
     834:	8c 93       	st	X, r24
     836:	16 97       	sbiw	r26, 0x06	; 6
     838:	35 c0       	rjmp	.+106    	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
				}else{
				dataRx->header = HEADER_U;
     83a:	18 96       	adiw	r26, 0x08	; 8
     83c:	1c 92       	st	X, r1
     83e:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     840:	81 50       	subi	r24, 0x01	; 1
     842:	12 96       	adiw	r26, 0x02	; 2
     844:	8c 93       	st	X, r24
     846:	12 97       	sbiw	r26, 0x02	; 2
     848:	2d c0       	rjmp	.+90     	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
			}
			break;
			case PAYLOAD:
			dataRx->nBytes--;
     84a:	17 96       	adiw	r26, 0x07	; 7
     84c:	9c 91       	ld	r25, X
     84e:	17 97       	sbiw	r26, 0x07	; 7
     850:	91 50       	subi	r25, 0x01	; 1
     852:	17 96       	adiw	r26, 0x07	; 7
     854:	9c 93       	st	X, r25
     856:	17 97       	sbiw	r26, 0x07	; 7
			if(dataRx->nBytes>0){
     858:	99 23       	and	r25, r25
     85a:	71 f0       	breq	.+28     	; 0x878 <__DATA_REGION_LENGTH__+0x78>
				dataRx->chk ^= dataRx->buff[dataRx->indexR];
     85c:	ed 91       	ld	r30, X+
     85e:	fc 91       	ld	r31, X
     860:	11 97       	sbiw	r26, 0x01	; 1
     862:	e8 0f       	add	r30, r24
     864:	f1 1d       	adc	r31, r1
     866:	80 81       	ld	r24, Z
     868:	16 96       	adiw	r26, 0x06	; 6
     86a:	9c 91       	ld	r25, X
     86c:	16 97       	sbiw	r26, 0x06	; 6
     86e:	89 27       	eor	r24, r25
     870:	16 96       	adiw	r26, 0x06	; 6
     872:	8c 93       	st	X, r24
     874:	16 97       	sbiw	r26, 0x06	; 6
     876:	16 c0       	rjmp	.+44     	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
				}else{
				dataRx->header = HEADER_U;
     878:	18 96       	adiw	r26, 0x08	; 8
     87a:	1c 92       	st	X, r1
     87c:	18 97       	sbiw	r26, 0x08	; 8
				if(dataRx->buff[dataRx->indexR] == dataRx->chk)
     87e:	ed 91       	ld	r30, X+
     880:	fc 91       	ld	r31, X
     882:	11 97       	sbiw	r26, 0x01	; 1
     884:	e8 0f       	add	r30, r24
     886:	f1 1d       	adc	r31, r1
     888:	90 81       	ld	r25, Z
     88a:	16 96       	adiw	r26, 0x06	; 6
     88c:	8c 91       	ld	r24, X
     88e:	16 97       	sbiw	r26, 0x06	; 6
     890:	98 13       	cpse	r25, r24
     892:	08 c0       	rjmp	.+16     	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
				dataRx->isComannd = TRUE;
     894:	81 e0       	ldi	r24, 0x01	; 1
     896:	1a 96       	adiw	r26, 0x0a	; 10
     898:	8c 93       	st	X, r24
     89a:	1a 97       	sbiw	r26, 0x0a	; 10
     89c:	03 c0       	rjmp	.+6      	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
			}
			break;
			default:
			dataRx->header = HEADER_U;
     89e:	18 96       	adiw	r26, 0x08	; 8
     8a0:	1c 92       	st	X, r1
     8a2:	18 97       	sbiw	r26, 0x08	; 8
			break;
		}
		dataRx->indexR++;
     8a4:	12 96       	adiw	r26, 0x02	; 2
     8a6:	8c 91       	ld	r24, X
     8a8:	12 97       	sbiw	r26, 0x02	; 2
     8aa:	8f 5f       	subi	r24, 0xFF	; 255
		dataRx->indexR &= dataRx->mask;
     8ac:	15 96       	adiw	r26, 0x05	; 5
     8ae:	9c 91       	ld	r25, X
     8b0:	15 97       	sbiw	r26, 0x05	; 5
     8b2:	89 23       	and	r24, r25
     8b4:	12 96       	adiw	r26, 0x02	; 2
     8b6:	8c 93       	st	X, r24
     8b8:	12 97       	sbiw	r26, 0x02	; 2
		
	}
}
void decodeHeader(_sRx *dataRx){
	uint8_t auxIndex=dataRx->indexW;
	while(dataRx->indexR != auxIndex){
     8ba:	12 96       	adiw	r26, 0x02	; 2
     8bc:	8c 91       	ld	r24, X
     8be:	12 97       	sbiw	r26, 0x02	; 2
     8c0:	28 13       	cpse	r18, r24
     8c2:	32 cf       	rjmp	.-412    	; 0x728 <decodeHeader+0xa>
			break;
		}
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}
     8c4:	08 95       	ret

000008c6 <serialTask>:

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}

void serialTask(_sRx* dataRx, _sTx* dataTx){
     8c6:	0f 93       	push	r16
     8c8:	1f 93       	push	r17
     8ca:	cf 93       	push	r28
     8cc:	df 93       	push	r29
     8ce:	8c 01       	movw	r16, r24
     8d0:	eb 01       	movw	r28, r22
	if(dataRx->isComannd){
     8d2:	fc 01       	movw	r30, r24
     8d4:	82 85       	ldd	r24, Z+10	; 0x0a
     8d6:	88 23       	and	r24, r24
     8d8:	21 f0       	breq	.+8      	; 0x8e2 <serialTask+0x1c>
		dataRx->isComannd=FALSE;
     8da:	12 86       	std	Z+10, r1	; 0x0a
		decodeCommand(dataRx,dataTx);
     8dc:	c8 01       	movw	r24, r16
     8de:	0e 94 be 02 	call	0x57c	; 0x57c <decodeCommand>
	}
	if(dataRx->indexR!=dataRx->indexW){
     8e2:	f8 01       	movw	r30, r16
     8e4:	92 81       	ldd	r25, Z+2	; 0x02
     8e6:	83 81       	ldd	r24, Z+3	; 0x03
     8e8:	98 17       	cp	r25, r24
     8ea:	19 f0       	breq	.+6      	; 0x8f2 <serialTask+0x2c>
		
		decodeHeader(dataRx);
     8ec:	c8 01       	movw	r24, r16
     8ee:	0e 94 8f 03 	call	0x71e	; 0x71e <decodeHeader>
	}
	if (dataTx->indexR!= dataTx->indexW) {
     8f2:	8a 81       	ldd	r24, Y+2	; 0x02
     8f4:	9b 81       	ldd	r25, Y+3	; 0x03
     8f6:	89 17       	cp	r24, r25
     8f8:	91 f0       	breq	.+36     	; 0x91e <__stack+0x1f>
		if (UCSR0A & (1 << UDRE0)) { // Si el buffer de transmisión está vacío
     8fa:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     8fe:	95 ff       	sbrs	r25, 5
     900:	0e c0       	rjmp	.+28     	; 0x91e <__stack+0x1f>
			UDR0 = dataTx->buff[dataTx->indexR++]; // Enviar el dato
     902:	e8 81       	ld	r30, Y
     904:	f9 81       	ldd	r31, Y+1	; 0x01
     906:	91 e0       	ldi	r25, 0x01	; 1
     908:	98 0f       	add	r25, r24
     90a:	9a 83       	std	Y+2, r25	; 0x02
     90c:	e8 0f       	add	r30, r24
     90e:	f1 1d       	adc	r31, r1
     910:	80 81       	ld	r24, Z
     912:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
			dataTx->indexR &= dataTx->mask;
     916:	8c 81       	ldd	r24, Y+4	; 0x04
     918:	9a 81       	ldd	r25, Y+2	; 0x02
     91a:	89 23       	and	r24, r25
     91c:	8a 83       	std	Y+2, r24	; 0x02
		}
	}
}
     91e:	df 91       	pop	r29
     920:	cf 91       	pop	r28
     922:	1f 91       	pop	r17
     924:	0f 91       	pop	r16
     926:	08 95       	ret

00000928 <sensorMeasure>:
	count40ms--;
	count200ms--;
}

void sensorMeasure(uint16_t distance){
	globalDistance=distance;
     928:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <globalDistance+0x1>
     92c:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <globalDistance>
     930:	08 95       	ret

00000932 <addBox>:
}

void addBox(uint16_t distance){
	
		if (globalDistance > 754 && globalDistance < 870) { //5-6,5
     932:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <globalDistance>
     936:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <globalDistance+0x1>
     93a:	9c 01       	movw	r18, r24
     93c:	23 5f       	subi	r18, 0xF3	; 243
     93e:	32 40       	sbci	r19, 0x02	; 2
     940:	23 37       	cpi	r18, 0x73	; 115
     942:	31 05       	cpc	r19, r1
     944:	78 f4       	brcc	.+30     	; 0x964 <addBox+0x32>
			Cajita[Numbox].boxState=isOn;
     946:	e0 91 28 01 	lds	r30, 0x0128	; 0x800128 <Numbox>
     94a:	f0 91 29 01 	lds	r31, 0x0129	; 0x800129 <Numbox+0x1>
     94e:	ee 0f       	add	r30, r30
     950:	ff 1f       	adc	r31, r31
     952:	ef 59       	subi	r30, 0x9F	; 159
     954:	fc 4f       	sbci	r31, 0xFC	; 252
     956:	11 82       	std	Z+1, r1	; 0x01
			Cajita[Numbox].boxSize=SmallBox;
     958:	81 e0       	ldi	r24, 0x01	; 1
     95a:	80 83       	st	Z, r24
			boxToTx = 0x03;
     95c:	83 e0       	ldi	r24, 0x03	; 3
     95e:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <boxToTx>
     962:	39 c0       	rjmp	.+114    	; 0x9d6 <addBox+0xa4>
		}
		else if (globalDistance >= boxSizeconfig.mediumboxC && globalDistance < boxSizeconfig.mediumboxF) { //7 -8,5
     964:	20 91 30 02 	lds	r18, 0x0230	; 0x800230 <boxSizeconfig+0x6>
     968:	30 91 31 02 	lds	r19, 0x0231	; 0x800231 <boxSizeconfig+0x7>
     96c:	82 17       	cp	r24, r18
     96e:	93 07       	cpc	r25, r19
     970:	b0 f0       	brcs	.+44     	; 0x99e <addBox+0x6c>
     972:	20 91 2e 02 	lds	r18, 0x022E	; 0x80022e <boxSizeconfig+0x4>
     976:	30 91 2f 02 	lds	r19, 0x022F	; 0x80022f <boxSizeconfig+0x5>
     97a:	82 17       	cp	r24, r18
     97c:	93 07       	cpc	r25, r19
     97e:	78 f4       	brcc	.+30     	; 0x99e <addBox+0x6c>
			Cajita[Numbox].boxState=isOn;
     980:	e0 91 28 01 	lds	r30, 0x0128	; 0x800128 <Numbox>
     984:	f0 91 29 01 	lds	r31, 0x0129	; 0x800129 <Numbox+0x1>
     988:	ee 0f       	add	r30, r30
     98a:	ff 1f       	adc	r31, r31
     98c:	ef 59       	subi	r30, 0x9F	; 159
     98e:	fc 4f       	sbci	r31, 0xFC	; 252
     990:	11 82       	std	Z+1, r1	; 0x01
			Cajita[Numbox].boxSize=MediumBox;
     992:	82 e0       	ldi	r24, 0x02	; 2
     994:	80 83       	st	Z, r24
			boxToTx = 0x01;
     996:	81 e0       	ldi	r24, 0x01	; 1
     998:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <boxToTx>
     99c:	1c c0       	rjmp	.+56     	; 0x9d6 <addBox+0xa4>
		}
		else if (globalDistance >= boxSizeconfig.largeboxC && globalDistance < boxSizeconfig.largeboxF) { //9-11
     99e:	20 91 34 02 	lds	r18, 0x0234	; 0x800234 <boxSizeconfig+0xa>
     9a2:	30 91 35 02 	lds	r19, 0x0235	; 0x800235 <boxSizeconfig+0xb>
     9a6:	82 17       	cp	r24, r18
     9a8:	93 07       	cpc	r25, r19
     9aa:	a8 f0       	brcs	.+42     	; 0x9d6 <addBox+0xa4>
     9ac:	20 91 32 02 	lds	r18, 0x0232	; 0x800232 <boxSizeconfig+0x8>
     9b0:	30 91 33 02 	lds	r19, 0x0233	; 0x800233 <boxSizeconfig+0x9>
     9b4:	82 17       	cp	r24, r18
     9b6:	93 07       	cpc	r25, r19
     9b8:	70 f4       	brcc	.+28     	; 0x9d6 <addBox+0xa4>
			Cajita[Numbox].boxState=isOn;
     9ba:	e0 91 28 01 	lds	r30, 0x0128	; 0x800128 <Numbox>
     9be:	f0 91 29 01 	lds	r31, 0x0129	; 0x800129 <Numbox+0x1>
     9c2:	ee 0f       	add	r30, r30
     9c4:	ff 1f       	adc	r31, r31
     9c6:	ef 59       	subi	r30, 0x9F	; 159
     9c8:	fc 4f       	sbci	r31, 0xFC	; 252
     9ca:	11 82       	std	Z+1, r1	; 0x01
			Cajita[Numbox].boxSize=LargeBox;
     9cc:	83 e0       	ldi	r24, 0x03	; 3
     9ce:	80 83       	st	Z, r24
			boxToTx = 0x02;
     9d0:	82 e0       	ldi	r24, 0x02	; 2
     9d2:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <boxToTx>
		}
		else if (globalDistance < 290 && globalDistance > Cm15){
			Cajita->boxSize=NotSelected;
		}
		Numbox++;
     9d6:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <Numbox>
     9da:	90 91 29 01 	lds	r25, 0x0129	; 0x800129 <Numbox+0x1>
     9de:	01 96       	adiw	r24, 0x01	; 1
     9e0:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <Numbox+0x1>
     9e4:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <Numbox>
	
		if(Numbox>=bufferBox) //reinicio el buffer
     9e8:	0f 97       	sbiw	r24, 0x0f	; 15
     9ea:	20 f0       	brcs	.+8      	; 0x9f4 <addBox+0xc2>
			Numbox=0;
     9ec:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <Numbox+0x1>
     9f0:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <Numbox>
     9f4:	08 95       	ret

000009f6 <newBox>:
	
}

void newBox(uint16_t distance){
     9f6:	cf 93       	push	r28
     9f8:	df 93       	push	r29
	if(distance<Cm18){
     9fa:	8c 34       	cpi	r24, 0x4C	; 76
     9fc:	24 e0       	ldi	r18, 0x04	; 4
     9fe:	92 07       	cpc	r25, r18
     a00:	00 f5       	brcc	.+64     	; 0xa42 <newBox+0x4c>
     a02:	ec 01       	movw	r28, r24
		if((IR_GetState(&ir_sensor[0]) == 0) && !MEASURINGBOX){
     a04:	81 e5       	ldi	r24, 0x51	; 81
     a06:	92 e0       	ldi	r25, 0x02	; 2
     a08:	0e 94 4b 02 	call	0x496	; 0x496 <IR_GetState>
     a0c:	81 11       	cpse	r24, r1
     a0e:	0e c0       	rjmp	.+28     	; 0xa2c <newBox+0x36>
     a10:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     a14:	81 fd       	sbrc	r24, 1
     a16:	0a c0       	rjmp	.+20     	; 0xa2c <newBox+0x36>
			MEASURINGBOX=TRUE;
     a18:	82 60       	ori	r24, 0x02	; 2
     a1a:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <flag0>
			addBox(distance);
     a1e:	ce 01       	movw	r24, r28
     a20:	0e 94 99 04 	call	0x932	; 0x932 <addBox>
			PORTB ^=(1<<LED_BI);
     a24:	95 b1       	in	r25, 0x05	; 5
     a26:	80 e2       	ldi	r24, 0x20	; 32
     a28:	89 27       	eor	r24, r25
     a2a:	85 b9       	out	0x05, r24	; 5
		}
		if ((IR_GetState(&ir_sensor[0]) == 1)) //si IR no mide
     a2c:	81 e5       	ldi	r24, 0x51	; 81
     a2e:	92 e0       	ldi	r25, 0x02	; 2
     a30:	0e 94 4b 02 	call	0x496	; 0x496 <IR_GetState>
     a34:	81 30       	cpi	r24, 0x01	; 1
     a36:	29 f4       	brne	.+10     	; 0xa42 <newBox+0x4c>
				MEASURINGBOX=FALSE;
     a38:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     a3c:	8d 7f       	andi	r24, 0xFD	; 253
     a3e:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <flag0>

	}
}
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	08 95       	ret

00000a48 <kickBox>:
	
	static uint8_t read1=0;
	static uint8_t read2=0;
	static uint8_t read3=0;
	
	if (IR_GetState(&ir_sensor[1])==0){
     a48:	85 e5       	ldi	r24, 0x55	; 85
     a4a:	92 e0       	ldi	r25, 0x02	; 2
     a4c:	0e 94 4b 02 	call	0x496	; 0x496 <IR_GetState>
     a50:	81 11       	cpse	r24, r1
     a52:	1e c0       	rjmp	.+60     	; 0xa90 <kickBox+0x48>
		if(ir_sensor[1].irType == Cajita[read1].boxSize){
     a54:	90 91 58 02 	lds	r25, 0x0258	; 0x800258 <ir_sensor+0x7>
     a58:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <read1.2097>
     a5c:	f0 e0       	ldi	r31, 0x00	; 0
     a5e:	ee 0f       	add	r30, r30
     a60:	ff 1f       	adc	r31, r31
     a62:	ef 59       	subi	r30, 0x9F	; 159
     a64:	fc 4f       	sbci	r31, 0xFC	; 252
     a66:	80 81       	ld	r24, Z
     a68:	98 13       	cpse	r25, r24
     a6a:	0d c0       	rjmp	.+26     	; 0xa86 <kickBox+0x3e>
			servo_Angle(0,0);
     a6c:	60 e0       	ldi	r22, 0x00	; 0
     a6e:	80 e0       	ldi	r24, 0x00	; 0
     a70:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
			Cajita[read1].boxState=isOut;
     a74:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <read1.2097>
     a78:	f0 e0       	ldi	r31, 0x00	; 0
     a7a:	ee 0f       	add	r30, r30
     a7c:	ff 1f       	adc	r31, r31
     a7e:	ef 59       	subi	r30, 0x9F	; 159
     a80:	fc 4f       	sbci	r31, 0xFC	; 252
     a82:	82 e0       	ldi	r24, 0x02	; 2
     a84:	81 83       	std	Z+1, r24	; 0x01
		}
		read1++;
     a86:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <read1.2097>
     a8a:	8f 5f       	subi	r24, 0xFF	; 255
     a8c:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <read1.2097>
	}
	if (IR_GetState(&ir_sensor[2])==0){
     a90:	89 e5       	ldi	r24, 0x59	; 89
     a92:	92 e0       	ldi	r25, 0x02	; 2
     a94:	0e 94 4b 02 	call	0x496	; 0x496 <IR_GetState>
     a98:	81 11       	cpse	r24, r1
     a9a:	1e c0       	rjmp	.+60     	; 0xad8 <kickBox+0x90>
		if(ir_sensor[2].irType == Cajita[read2].boxSize){
     a9c:	90 91 5c 02 	lds	r25, 0x025C	; 0x80025c <ir_sensor+0xb>
     aa0:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <read2.2098>
     aa4:	f0 e0       	ldi	r31, 0x00	; 0
     aa6:	ee 0f       	add	r30, r30
     aa8:	ff 1f       	adc	r31, r31
     aaa:	ef 59       	subi	r30, 0x9F	; 159
     aac:	fc 4f       	sbci	r31, 0xFC	; 252
     aae:	80 81       	ld	r24, Z
     ab0:	98 13       	cpse	r25, r24
     ab2:	0d c0       	rjmp	.+26     	; 0xace <kickBox+0x86>
			servo_Angle(1,0);
     ab4:	60 e0       	ldi	r22, 0x00	; 0
     ab6:	81 e0       	ldi	r24, 0x01	; 1
     ab8:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
			Cajita[read2].boxState=isOut;
     abc:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <read2.2098>
     ac0:	f0 e0       	ldi	r31, 0x00	; 0
     ac2:	ee 0f       	add	r30, r30
     ac4:	ff 1f       	adc	r31, r31
     ac6:	ef 59       	subi	r30, 0x9F	; 159
     ac8:	fc 4f       	sbci	r31, 0xFC	; 252
     aca:	82 e0       	ldi	r24, 0x02	; 2
     acc:	81 83       	std	Z+1, r24	; 0x01
		}
		read2++;
     ace:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <read2.2098>
     ad2:	8f 5f       	subi	r24, 0xFF	; 255
     ad4:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <read2.2098>
	}
	if (IR_GetState(&ir_sensor[3])==0){
     ad8:	8d e5       	ldi	r24, 0x5D	; 93
     ada:	92 e0       	ldi	r25, 0x02	; 2
     adc:	0e 94 4b 02 	call	0x496	; 0x496 <IR_GetState>
     ae0:	81 11       	cpse	r24, r1
     ae2:	1e c0       	rjmp	.+60     	; 0xb20 <kickBox+0xd8>
		if(ir_sensor[3].irType == Cajita[read3].boxSize){
     ae4:	90 91 60 02 	lds	r25, 0x0260	; 0x800260 <ir_sensor+0xf>
     ae8:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <read3.2099>
     aec:	f0 e0       	ldi	r31, 0x00	; 0
     aee:	ee 0f       	add	r30, r30
     af0:	ff 1f       	adc	r31, r31
     af2:	ef 59       	subi	r30, 0x9F	; 159
     af4:	fc 4f       	sbci	r31, 0xFC	; 252
     af6:	80 81       	ld	r24, Z
     af8:	98 13       	cpse	r25, r24
     afa:	0d c0       	rjmp	.+26     	; 0xb16 <kickBox+0xce>
			servo_Angle(2,0);
     afc:	60 e0       	ldi	r22, 0x00	; 0
     afe:	82 e0       	ldi	r24, 0x02	; 2
     b00:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
			Cajita[read3].boxState=isOut;
     b04:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <read3.2099>
     b08:	f0 e0       	ldi	r31, 0x00	; 0
     b0a:	ee 0f       	add	r30, r30
     b0c:	ff 1f       	adc	r31, r31
     b0e:	ef 59       	subi	r30, 0x9F	; 159
     b10:	fc 4f       	sbci	r31, 0xFC	; 252
     b12:	82 e0       	ldi	r24, 0x02	; 2
     b14:	81 83       	std	Z+1, r24	; 0x01
		}
		read3++;
     b16:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <read3.2099>
     b1a:	8f 5f       	subi	r24, 0xFF	; 255
     b1c:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <read3.2099>
	}
	if(read1>=bufferBox)
     b20:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <read1.2097>
     b24:	8f 30       	cpi	r24, 0x0F	; 15
     b26:	10 f0       	brcs	.+4      	; 0xb2c <kickBox+0xe4>
		read1=0;
     b28:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <read1.2097>
	if(read2>=bufferBox)
     b2c:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <read2.2098>
     b30:	8f 30       	cpi	r24, 0x0F	; 15
     b32:	10 f0       	brcs	.+4      	; 0xb38 <kickBox+0xf0>
		read2=0;
     b34:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <read2.2098>
	if(read3>=bufferBox)
     b38:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <read3.2099>
     b3c:	8f 30       	cpi	r24, 0x0F	; 15
     b3e:	10 f0       	brcs	.+4      	; 0xb44 <kickBox+0xfc>
		read3=0;
     b40:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <read3.2099>
     b44:	08 95       	ret

00000b46 <servoreset>:
	
}
void servoreset(){
	servo_Angle(0,90);
     b46:	6a e5       	ldi	r22, 0x5A	; 90
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
	servo_Angle(1,90);
     b4e:	6a e5       	ldi	r22, 0x5A	; 90
     b50:	81 e0       	ldi	r24, 0x01	; 1
     b52:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
	servo_Angle(2,90);
     b56:	6a e5       	ldi	r22, 0x5A	; 90
     b58:	82 e0       	ldi	r24, 0x02	; 2
     b5a:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
     b5e:	08 95       	ret

00000b60 <every10ms>:
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}

void every10ms(){
     b60:	cf 93       	push	r28
     b62:	df 93       	push	r29
	
	if (!count100ms){		//Si pasaron 100ms
     b64:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <count100ms>
     b68:	81 11       	cpse	r24, r1
     b6a:	1f c0       	rjmp	.+62     	; 0xbaa <every10ms+0x4a>

uint32_t	HCSR_1;
uint16_t	aux16 = 0;

static inline void on_reset_hcsr(){
	aux16 = TCNT1;								// Loads actual time in TCNT1 into aux16
     b6c:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
     b70:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
	aux16 += 20;								// 20*500ns = 10us (tiempo del trigger), Adds 10 (us) to the previously saved time at TCNT1
     b74:	44 96       	adiw	r24, 0x14	; 20
     b76:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <aux16+0x1>
     b7a:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <aux16>
	OCR1B = aux16;								// Then loads the value into OCR1B, generating an Output Compare Interrupt
     b7e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7f808b>
     b82:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7f808a>
	TIFR1 = (1<<OCF1B) | (1<<OCF1A);			// Flag set after the counter value in TCNT1 equals OCR1A and OCR1B
     b86:	86 e0       	ldi	r24, 0x06	; 6
     b88:	86 bb       	out	0x16, r24	; 22
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
     b8a:	84 e0       	ldi	r24, 0x04	; 4
     b8c:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
     b90:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <HCSR_1>
     b94:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <HCSR_1+0x1>
     b98:	0e 94 87 00 	call	0x10e	; 0x10e <HCSR04_Start>
		on_reset_hcsr();
		count100ms = 10;
     b9c:	8a e0       	ldi	r24, 0x0A	; 10
     b9e:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <count100ms>
		PORTB ^= (1<<LED_BI);
     ba2:	95 b1       	in	r25, 0x05	; 5
     ba4:	80 e2       	ldi	r24, 0x20	; 32
     ba6:	89 27       	eor	r24, r25
     ba8:	85 b9       	out	0x05, r24	; 5
	}
	
	if (!count40ms){
     baa:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <count40ms>
     bae:	88 23       	and	r24, r24
     bb0:	81 f0       	breq	.+32     	; 0xbd2 <every10ms+0x72>
     bb2:	1f c0       	rjmp	.+62     	; 0xbf2 <every10ms+0x92>
		for(int i=0;i<4;i++){
			IR_Update(&ir_sensor[i], raw_input[i]);
     bb4:	fe 01       	movw	r30, r28
     bb6:	e8 5b       	subi	r30, 0xB8	; 184
     bb8:	fd 4f       	sbci	r31, 0xFD	; 253
     bba:	ce 01       	movw	r24, r28
     bbc:	88 0f       	add	r24, r24
     bbe:	99 1f       	adc	r25, r25
     bc0:	88 0f       	add	r24, r24
     bc2:	99 1f       	adc	r25, r25
     bc4:	60 81       	ld	r22, Z
     bc6:	8f 5a       	subi	r24, 0xAF	; 175
     bc8:	9d 4f       	sbci	r25, 0xFD	; 253
     bca:	0e 94 17 02 	call	0x42e	; 0x42e <IR_Update>
		count100ms = 10;
		PORTB ^= (1<<LED_BI);
	}
	
	if (!count40ms){
		for(int i=0;i<4;i++){
     bce:	21 96       	adiw	r28, 0x01	; 1
     bd0:	02 c0       	rjmp	.+4      	; 0xbd6 <every10ms+0x76>
     bd2:	c0 e0       	ldi	r28, 0x00	; 0
     bd4:	d0 e0       	ldi	r29, 0x00	; 0
     bd6:	c4 30       	cpi	r28, 0x04	; 4
     bd8:	d1 05       	cpc	r29, r1
     bda:	64 f3       	brlt	.-40     	; 0xbb4 <every10ms+0x54>
			IR_Update(&ir_sensor[i], raw_input[i]);
		}
		count40ms = 4;
     bdc:	84 e0       	ldi	r24, 0x04	; 4
     bde:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <count40ms>
		newBox(globalDistance);
     be2:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <globalDistance>
     be6:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <globalDistance+0x1>
     bea:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <newBox>
		kickBox();
     bee:	0e 94 24 05 	call	0xa48	; 0xa48 <kickBox>
	}
	if (!count200ms){
     bf2:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <count200ms>
     bf6:	81 11       	cpse	r24, r1
     bf8:	05 c0       	rjmp	.+10     	; 0xc04 <every10ms+0xa4>
			servoreset();
     bfa:	0e 94 a3 05 	call	0xb46	; 0xb46 <servoreset>
			count200ms = 75;
     bfe:	8b e4       	ldi	r24, 0x4B	; 75
     c00:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <count200ms>
			
	}
	raw_input[0] = (PIND & (1<<IR0)) ? 1 : 0;
     c04:	89 b1       	in	r24, 0x09	; 9
     c06:	82 fb       	bst	r24, 2
     c08:	88 27       	eor	r24, r24
     c0a:	80 f9       	bld	r24, 0
     c0c:	e8 e4       	ldi	r30, 0x48	; 72
     c0e:	f2 e0       	ldi	r31, 0x02	; 2
     c10:	80 83       	st	Z, r24
	raw_input[1] = (PIND & (1<<IR1)) ? 1 : 0;
     c12:	89 b1       	in	r24, 0x09	; 9
     c14:	83 fb       	bst	r24, 3
     c16:	88 27       	eor	r24, r24
     c18:	80 f9       	bld	r24, 0
     c1a:	81 83       	std	Z+1, r24	; 0x01
	raw_input[2] = (PIND & (1<<IR2)) ? 1 : 0;
     c1c:	89 b1       	in	r24, 0x09	; 9
     c1e:	82 95       	swap	r24
     c20:	81 70       	andi	r24, 0x01	; 1
     c22:	82 83       	std	Z+2, r24	; 0x02
	raw_input[3] = (PIND & (1<<IR3)) ? 1 : 0;
     c24:	89 b1       	in	r24, 0x09	; 9
     c26:	85 fb       	bst	r24, 5
     c28:	88 27       	eor	r24, r24
     c2a:	80 f9       	bld	r24, 0
     c2c:	83 83       	std	Z+3, r24	; 0x03
	
	IS10MS = FALSE;
     c2e:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     c32:	8e 7f       	andi	r24, 0xFE	; 254
     c34:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <flag0>
	count100ms--;
     c38:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <count100ms>
     c3c:	81 50       	subi	r24, 0x01	; 1
     c3e:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <count100ms>
	count40ms--;
     c42:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <count40ms>
     c46:	81 50       	subi	r24, 0x01	; 1
     c48:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <count40ms>
	count200ms--;
     c4c:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <count200ms>
     c50:	81 50       	subi	r24, 0x01	; 1
     c52:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <count200ms>
}
     c56:	df 91       	pop	r29
     c58:	cf 91       	pop	r28
     c5a:	08 95       	ret

00000c5c <main>:
}
/* END Function prototypes user code ------------------------------------------*/

int main(){
	
	cli();
     c5c:	f8 94       	cli

	/* END Local variables -------------------------------------------------------*/


	/* User code Init ------------------------------------------------------------*/
	flag0.byte = 0;
     c5e:	10 92 47 02 	sts	0x0247, r1	; 0x800247 <flag0>
	
	ini_ports();
     c62:	0e 94 c8 01 	call	0x390	; 0x390 <ini_ports>
	ini_timer1();
     c66:	0e 94 d7 01 	call	0x3ae	; 0x3ae <ini_timer1>
	ini_timer0();
     c6a:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <ini_timer0>
	ini_USART(16);
     c6e:	80 e1       	ldi	r24, 0x10	; 16
     c70:	0e 94 f6 01 	call	0x3ec	; 0x3ec <ini_USART>
	
	IR_Init(&ir_sensor[0]);
     c74:	81 e5       	ldi	r24, 0x51	; 81
     c76:	92 e0       	ldi	r25, 0x02	; 2
     c78:	0e 94 04 02 	call	0x408	; 0x408 <IR_Init>
	
	addServo(&PORTD,SV0);
     c7c:	67 e0       	ldi	r22, 0x07	; 7
     c7e:	8b e2       	ldi	r24, 0x2B	; 43
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	0e 94 b1 06 	call	0xd62	; 0xd62 <addServo>
	addServo(&PORTB,SV1);
     c86:	64 e0       	ldi	r22, 0x04	; 4
     c88:	85 e2       	ldi	r24, 0x25	; 37
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	0e 94 b1 06 	call	0xd62	; 0xd62 <addServo>
	addServo(&PORTB,SV2);
     c90:	63 e0       	ldi	r22, 0x03	; 3
     c92:	85 e2       	ldi	r24, 0x25	; 37
     c94:	90 e0       	ldi	r25, 0x00	; 0
     c96:	0e 94 b1 06 	call	0xd62	; 0xd62 <addServo>
	servo_Angle(0,90);
     c9a:	6a e5       	ldi	r22, 0x5A	; 90
     c9c:	80 e0       	ldi	r24, 0x00	; 0
     c9e:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
	servo_Angle(1,90);
     ca2:	6a e5       	ldi	r22, 0x5A	; 90
     ca4:	81 e0       	ldi	r24, 0x01	; 1
     ca6:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
	servo_Angle(2,90);
     caa:	6a e5       	ldi	r22, 0x5A	; 90
     cac:	82 e0       	ldi	r24, 0x02	; 2
     cae:	0e 94 c5 06 	call	0xd8a	; 0xd8a <servo_Angle>
	HCSR_1 = HCSR04_AddNew(&WritePin_HCSR, 16);
     cb2:	40 e1       	ldi	r20, 0x10	; 16
     cb4:	50 e0       	ldi	r21, 0x00	; 0
     cb6:	60 e0       	ldi	r22, 0x00	; 0
     cb8:	70 e0       	ldi	r23, 0x00	; 0
     cba:	88 ed       	ldi	r24, 0xD8	; 216
     cbc:	90 e0       	ldi	r25, 0x00	; 0
     cbe:	0e 94 5a 00 	call	0xb4	; 0xb4 <HCSR04_AddNew>
     cc2:	a0 e0       	ldi	r26, 0x00	; 0
     cc4:	b0 e0       	ldi	r27, 0x00	; 0
     cc6:	80 93 23 01 	sts	0x0123, r24	; 0x800123 <HCSR_1>
     cca:	90 93 24 01 	sts	0x0124, r25	; 0x800124 <HCSR_1+0x1>
     cce:	a0 93 25 01 	sts	0x0125, r26	; 0x800125 <HCSR_1+0x2>
     cd2:	b0 93 26 01 	sts	0x0126, r27	; 0x800126 <HCSR_1+0x3>
	
	Numbox = 0;
     cd6:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <Numbox+0x1>
     cda:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <Numbox>
	
	dataRx.buff = (uint8_t *)buffRx;
     cde:	e6 e3       	ldi	r30, 0x36	; 54
     ce0:	f2 e0       	ldi	r31, 0x02	; 2
     ce2:	8a e2       	ldi	r24, 0x2A	; 42
     ce4:	91 e0       	ldi	r25, 0x01	; 1
     ce6:	91 83       	std	Z+1, r25	; 0x01
     ce8:	80 83       	st	Z, r24
	dataRx.indexR = 0;
     cea:	12 82       	std	Z+2, r1	; 0x02
	dataRx.indexW = 0;
     cec:	13 82       	std	Z+3, r1	; 0x03
	dataRx.header = HEADER_U;
     cee:	10 86       	std	Z+8, r1	; 0x08
	dataRx.mask = RXBUFSIZE - 1;
     cf0:	8f ef       	ldi	r24, 0xFF	; 255
     cf2:	85 83       	std	Z+5, r24	; 0x05
	
	dataTx.buff = buffTx;
     cf4:	e1 e4       	ldi	r30, 0x41	; 65
     cf6:	f2 e0       	ldi	r31, 0x02	; 2
     cf8:	21 e6       	ldi	r18, 0x61	; 97
     cfa:	32 e0       	ldi	r19, 0x02	; 2
     cfc:	31 83       	std	Z+1, r19	; 0x01
     cfe:	20 83       	st	Z, r18
	dataTx.indexR = 0;
     d00:	12 82       	std	Z+2, r1	; 0x02
	dataTx.indexW = 0;
     d02:	13 82       	std	Z+3, r1	; 0x03
	dataTx.mask = TXBUFSIZE -1;
     d04:	84 83       	std	Z+4, r24	; 0x04
	
	boxSizeconfig.smallboxF=Cm15;
     d06:	ea e2       	ldi	r30, 0x2A	; 42
     d08:	f2 e0       	ldi	r31, 0x02	; 2
     d0a:	86 e6       	ldi	r24, 0x66	; 102
     d0c:	93 e0       	ldi	r25, 0x03	; 3
     d0e:	91 83       	std	Z+1, r25	; 0x01
     d10:	80 83       	st	Z, r24
	boxSizeconfig.smallboxC=Cm13;
     d12:	82 ef       	ldi	r24, 0xF2	; 242
     d14:	92 e0       	ldi	r25, 0x02	; 2
     d16:	93 83       	std	Z+3, r25	; 0x03
     d18:	82 83       	std	Z+2, r24	; 0x02
	boxSizeconfig.mediumboxF=Cm13;
     d1a:	95 83       	std	Z+5, r25	; 0x05
     d1c:	84 83       	std	Z+4, r24	; 0x04
	boxSizeconfig.mediumboxC=Cm11;
     d1e:	8e e7       	ldi	r24, 0x7E	; 126
     d20:	92 e0       	ldi	r25, 0x02	; 2
     d22:	97 83       	std	Z+7, r25	; 0x07
     d24:	86 83       	std	Z+6, r24	; 0x06
	boxSizeconfig.largeboxF=Cm11;
     d26:	91 87       	std	Z+9, r25	; 0x09
     d28:	80 87       	std	Z+8, r24	; 0x08
	boxSizeconfig.largeboxC=Cm9;
     d2a:	8a e0       	ldi	r24, 0x0A	; 10
     d2c:	92 e0       	ldi	r25, 0x02	; 2
     d2e:	93 87       	std	Z+11, r25	; 0x0b
     d30:	82 87       	std	Z+10, r24	; 0x0a
	
	ir_sensor[1].irType = SmallBox;
     d32:	e1 e5       	ldi	r30, 0x51	; 81
     d34:	f2 e0       	ldi	r31, 0x02	; 2
     d36:	81 e0       	ldi	r24, 0x01	; 1
     d38:	87 83       	std	Z+7, r24	; 0x07
	ir_sensor[2].irType = MediumBox;
     d3a:	82 e0       	ldi	r24, 0x02	; 2
     d3c:	83 87       	std	Z+11, r24	; 0x0b
	ir_sensor[3].irType = LargeBox;
     d3e:	83 e0       	ldi	r24, 0x03	; 3
     d40:	87 87       	std	Z+15, r24	; 0x0f
	
	/* END User code Init --------------------------------------------------------*/
	sei();
     d42:	78 94       	sei

	while (1){
		/* User Code loop ------------------------------------------------------------*/
		task_HCSR();
     d44:	0e 94 af 00 	call	0x15e	; 0x15e <task_HCSR>
		serialTask(&dataRx,&dataTx);
     d48:	61 e4       	ldi	r22, 0x41	; 65
     d4a:	72 e0       	ldi	r23, 0x02	; 2
     d4c:	86 e3       	ldi	r24, 0x36	; 54
     d4e:	92 e0       	ldi	r25, 0x02	; 2
     d50:	0e 94 63 04 	call	0x8c6	; 0x8c6 <serialTask>
		if (IS10MS)
     d54:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     d58:	80 ff       	sbrs	r24, 0
     d5a:	f4 cf       	rjmp	.-24     	; 0xd44 <main+0xe8>
			every10ms();
     d5c:	0e 94 b0 05 	call	0xb60	; 0xb60 <every10ms>
     d60:	f1 cf       	rjmp	.-30     	; 0xd44 <main+0xe8>

00000d62 <addServo>:
static uint8_t ServN = 0;
volatile static uint8_t is20ms=156;
 
void addServo(volatile uint8_t* PORT,uint8_t Pin){
	
	servoHandle[ServN].pin=Pin;
     d62:	20 91 13 01 	lds	r18, 0x0113	; 0x800113 <ServN>
     d66:	e2 2f       	mov	r30, r18
     d68:	f0 e0       	ldi	r31, 0x00	; 0
     d6a:	af 01       	movw	r20, r30
     d6c:	44 0f       	add	r20, r20
     d6e:	55 1f       	adc	r21, r21
     d70:	44 0f       	add	r20, r20
     d72:	55 1f       	adc	r21, r21
     d74:	e4 0f       	add	r30, r20
     d76:	f5 1f       	adc	r31, r21
     d78:	ec 5e       	subi	r30, 0xEC	; 236
     d7a:	fe 4f       	sbci	r31, 0xFE	; 254
     d7c:	62 83       	std	Z+2, r22	; 0x02
	servoHandle[ServN].port=PORT;
     d7e:	91 83       	std	Z+1, r25	; 0x01
     d80:	80 83       	st	Z, r24
	ServN++;
     d82:	2f 5f       	subi	r18, 0xFF	; 255
     d84:	20 93 13 01 	sts	0x0113, r18	; 0x800113 <ServN>
     d88:	08 95       	ret

00000d8a <servo_Angle>:
}
void servo_Angle(uint8_t servo,uint8_t angulo){
     d8a:	48 2f       	mov	r20, r24
	
	uint16_t riseValue;
	
	riseValue = (uint16_t)angulo * ANGLE_TO_PWM_SLOPE;
     d8c:	85 e7       	ldi	r24, 0x75	; 117
     d8e:	68 9f       	mul	r22, r24
     d90:	90 01       	movw	r18, r0
     d92:	11 24       	eor	r1, r1
	riseValue += ANGLE_TO_PWM_OFFSET;
     d94:	2e 5c       	subi	r18, 0xCE	; 206
     d96:	36 4d       	sbci	r19, 0xD6	; 214
	riseValue /= 180;
     d98:	a3 e8       	ldi	r26, 0x83	; 131
     d9a:	bd e2       	ldi	r27, 0x2D	; 45
     d9c:	0e 94 56 07 	call	0xeac	; 0xeac <__umulhisi3>
     da0:	96 95       	lsr	r25
     da2:	87 95       	ror	r24
     da4:	92 95       	swap	r25
     da6:	82 95       	swap	r24
     da8:	8f 70       	andi	r24, 0x0F	; 15
     daa:	89 27       	eor	r24, r25
     dac:	9f 70       	andi	r25, 0x0F	; 15
     dae:	89 27       	eor	r24, r25
	riseValue += ROUNDING_CORRECTION;
     db0:	9c 01       	movw	r18, r24
     db2:	2b 5f       	subi	r18, 0xFB	; 251
     db4:	3f 4f       	sbci	r19, 0xFF	; 255
	riseValue /= 10;
     db6:	ad ec       	ldi	r26, 0xCD	; 205
     db8:	bc ec       	ldi	r27, 0xCC	; 204
     dba:	0e 94 56 07 	call	0xeac	; 0xeac <__umulhisi3>
     dbe:	96 95       	lsr	r25
     dc0:	87 95       	ror	r24
     dc2:	96 95       	lsr	r25
     dc4:	87 95       	ror	r24
     dc6:	96 95       	lsr	r25
     dc8:	87 95       	ror	r24
		
	servoHandle[servo].dutyCycle = (uint8_t)riseValue;
     dca:	24 2f       	mov	r18, r20
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	f9 01       	movw	r30, r18
     dd0:	ee 0f       	add	r30, r30
     dd2:	ff 1f       	adc	r31, r31
     dd4:	ee 0f       	add	r30, r30
     dd6:	ff 1f       	adc	r31, r31
     dd8:	2e 0f       	add	r18, r30
     dda:	3f 1f       	adc	r19, r31
     ddc:	f9 01       	movw	r30, r18
     dde:	ec 5e       	subi	r30, 0xEC	; 236
     de0:	fe 4f       	sbci	r31, 0xFE	; 254
     de2:	84 83       	std	Z+4, r24	; 0x04
     de4:	08 95       	ret

00000de6 <writeServo>:
}

void writeServo(){
	is20ms--;
     de6:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <is20ms>
     dea:	81 50       	subi	r24, 0x01	; 1
     dec:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <is20ms>
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     df0:	20 e0       	ldi	r18, 0x00	; 0
     df2:	2a c0       	rjmp	.+84     	; 0xe48 <writeServo+0x62>
		servoHandle[counter].cycle--;
     df4:	82 2f       	mov	r24, r18
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	fc 01       	movw	r30, r24
     dfa:	ee 0f       	add	r30, r30
     dfc:	ff 1f       	adc	r31, r31
     dfe:	ee 0f       	add	r30, r30
     e00:	ff 1f       	adc	r31, r31
     e02:	e8 0f       	add	r30, r24
     e04:	f9 1f       	adc	r31, r25
     e06:	ec 5e       	subi	r30, 0xEC	; 236
     e08:	fe 4f       	sbci	r31, 0xFE	; 254
     e0a:	33 81       	ldd	r19, Z+3	; 0x03
     e0c:	31 50       	subi	r19, 0x01	; 1
     e0e:	33 83       	std	Z+3, r19	; 0x03
		if(!servoHandle[counter].cycle)
     e10:	33 81       	ldd	r19, Z+3	; 0x03
     e12:	31 11       	cpse	r19, r1
     e14:	18 c0       	rjmp	.+48     	; 0xe46 <writeServo+0x60>
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
     e16:	fc 01       	movw	r30, r24
     e18:	ee 0f       	add	r30, r30
     e1a:	ff 1f       	adc	r31, r31
     e1c:	ee 0f       	add	r30, r30
     e1e:	ff 1f       	adc	r31, r31
     e20:	8e 0f       	add	r24, r30
     e22:	9f 1f       	adc	r25, r31
     e24:	fc 01       	movw	r30, r24
     e26:	ec 5e       	subi	r30, 0xEC	; 236
     e28:	fe 4f       	sbci	r31, 0xFE	; 254
     e2a:	a0 81       	ld	r26, Z
     e2c:	b1 81       	ldd	r27, Z+1	; 0x01
     e2e:	3c 91       	ld	r19, X
     e30:	81 e0       	ldi	r24, 0x01	; 1
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	02 80       	ldd	r0, Z+2	; 0x02
     e36:	02 c0       	rjmp	.+4      	; 0xe3c <writeServo+0x56>
     e38:	88 0f       	add	r24, r24
     e3a:	99 1f       	adc	r25, r25
     e3c:	0a 94       	dec	r0
     e3e:	e2 f7       	brpl	.-8      	; 0xe38 <writeServo+0x52>
     e40:	80 95       	com	r24
     e42:	83 23       	and	r24, r19
     e44:	8c 93       	st	X, r24
void writeServo(){
	is20ms--;
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     e46:	2f 5f       	subi	r18, 0xFF	; 255
     e48:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ServN>
     e4c:	28 17       	cp	r18, r24
     e4e:	90 f2       	brcs	.-92     	; 0xdf4 <writeServo+0xe>
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
     e50:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <is20ms>
     e54:	99 23       	and	r25, r25
     e56:	e9 f0       	breq	.+58     	; 0xe92 <writeServo+0xac>
     e58:	08 95       	ret
		for(counter = 0; counter < ServN; counter++){
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
     e5a:	e9 2f       	mov	r30, r25
     e5c:	f0 e0       	ldi	r31, 0x00	; 0
     e5e:	9f 01       	movw	r18, r30
     e60:	22 0f       	add	r18, r18
     e62:	33 1f       	adc	r19, r19
     e64:	22 0f       	add	r18, r18
     e66:	33 1f       	adc	r19, r19
     e68:	e2 0f       	add	r30, r18
     e6a:	f3 1f       	adc	r31, r19
     e6c:	ec 5e       	subi	r30, 0xEC	; 236
     e6e:	fe 4f       	sbci	r31, 0xFE	; 254
     e70:	24 81       	ldd	r18, Z+4	; 0x04
     e72:	23 83       	std	Z+3, r18	; 0x03
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
     e74:	a0 81       	ld	r26, Z
     e76:	b1 81       	ldd	r27, Z+1	; 0x01
     e78:	4c 91       	ld	r20, X
     e7a:	21 e0       	ldi	r18, 0x01	; 1
     e7c:	30 e0       	ldi	r19, 0x00	; 0
     e7e:	02 80       	ldd	r0, Z+2	; 0x02
     e80:	02 c0       	rjmp	.+4      	; 0xe86 <writeServo+0xa0>
     e82:	22 0f       	add	r18, r18
     e84:	33 1f       	adc	r19, r19
     e86:	0a 94       	dec	r0
     e88:	e2 f7       	brpl	.-8      	; 0xe82 <writeServo+0x9c>
     e8a:	24 2b       	or	r18, r20
     e8c:	2c 93       	st	X, r18
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
		for(counter = 0; counter < ServN; counter++){
     e8e:	9f 5f       	subi	r25, 0xFF	; 255
     e90:	01 c0       	rjmp	.+2      	; 0xe94 <writeServo+0xae>
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	98 17       	cp	r25, r24
     e96:	08 f3       	brcs	.-62     	; 0xe5a <writeServo+0x74>
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
		}
		is20ms = 156;
     e98:	8c e9       	ldi	r24, 0x9C	; 156
     e9a:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <is20ms>
     e9e:	08 95       	ret

00000ea0 <__tablejump2__>:
     ea0:	ee 0f       	add	r30, r30
     ea2:	ff 1f       	adc	r31, r31
     ea4:	05 90       	lpm	r0, Z+
     ea6:	f4 91       	lpm	r31, Z
     ea8:	e0 2d       	mov	r30, r0
     eaa:	09 94       	ijmp

00000eac <__umulhisi3>:
     eac:	a2 9f       	mul	r26, r18
     eae:	b0 01       	movw	r22, r0
     eb0:	b3 9f       	mul	r27, r19
     eb2:	c0 01       	movw	r24, r0
     eb4:	a3 9f       	mul	r26, r19
     eb6:	70 0d       	add	r23, r0
     eb8:	81 1d       	adc	r24, r1
     eba:	11 24       	eor	r1, r1
     ebc:	91 1d       	adc	r25, r1
     ebe:	b2 9f       	mul	r27, r18
     ec0:	70 0d       	add	r23, r0
     ec2:	81 1d       	adc	r24, r1
     ec4:	11 24       	eor	r1, r1
     ec6:	91 1d       	adc	r25, r1
     ec8:	08 95       	ret

00000eca <malloc>:
     eca:	0f 93       	push	r16
     ecc:	1f 93       	push	r17
     ece:	cf 93       	push	r28
     ed0:	df 93       	push	r29
     ed2:	82 30       	cpi	r24, 0x02	; 2
     ed4:	91 05       	cpc	r25, r1
     ed6:	10 f4       	brcc	.+4      	; 0xedc <malloc+0x12>
     ed8:	82 e0       	ldi	r24, 0x02	; 2
     eda:	90 e0       	ldi	r25, 0x00	; 0
     edc:	e0 91 81 03 	lds	r30, 0x0381	; 0x800381 <__flp>
     ee0:	f0 91 82 03 	lds	r31, 0x0382	; 0x800382 <__flp+0x1>
     ee4:	20 e0       	ldi	r18, 0x00	; 0
     ee6:	30 e0       	ldi	r19, 0x00	; 0
     ee8:	a0 e0       	ldi	r26, 0x00	; 0
     eea:	b0 e0       	ldi	r27, 0x00	; 0
     eec:	30 97       	sbiw	r30, 0x00	; 0
     eee:	19 f1       	breq	.+70     	; 0xf36 <malloc+0x6c>
     ef0:	40 81       	ld	r20, Z
     ef2:	51 81       	ldd	r21, Z+1	; 0x01
     ef4:	02 81       	ldd	r16, Z+2	; 0x02
     ef6:	13 81       	ldd	r17, Z+3	; 0x03
     ef8:	48 17       	cp	r20, r24
     efa:	59 07       	cpc	r21, r25
     efc:	c8 f0       	brcs	.+50     	; 0xf30 <malloc+0x66>
     efe:	84 17       	cp	r24, r20
     f00:	95 07       	cpc	r25, r21
     f02:	69 f4       	brne	.+26     	; 0xf1e <malloc+0x54>
     f04:	10 97       	sbiw	r26, 0x00	; 0
     f06:	31 f0       	breq	.+12     	; 0xf14 <malloc+0x4a>
     f08:	12 96       	adiw	r26, 0x02	; 2
     f0a:	0c 93       	st	X, r16
     f0c:	12 97       	sbiw	r26, 0x02	; 2
     f0e:	13 96       	adiw	r26, 0x03	; 3
     f10:	1c 93       	st	X, r17
     f12:	27 c0       	rjmp	.+78     	; 0xf62 <malloc+0x98>
     f14:	00 93 81 03 	sts	0x0381, r16	; 0x800381 <__flp>
     f18:	10 93 82 03 	sts	0x0382, r17	; 0x800382 <__flp+0x1>
     f1c:	22 c0       	rjmp	.+68     	; 0xf62 <malloc+0x98>
     f1e:	21 15       	cp	r18, r1
     f20:	31 05       	cpc	r19, r1
     f22:	19 f0       	breq	.+6      	; 0xf2a <malloc+0x60>
     f24:	42 17       	cp	r20, r18
     f26:	53 07       	cpc	r21, r19
     f28:	18 f4       	brcc	.+6      	; 0xf30 <malloc+0x66>
     f2a:	9a 01       	movw	r18, r20
     f2c:	bd 01       	movw	r22, r26
     f2e:	ef 01       	movw	r28, r30
     f30:	df 01       	movw	r26, r30
     f32:	f8 01       	movw	r30, r16
     f34:	db cf       	rjmp	.-74     	; 0xeec <malloc+0x22>
     f36:	21 15       	cp	r18, r1
     f38:	31 05       	cpc	r19, r1
     f3a:	f9 f0       	breq	.+62     	; 0xf7a <malloc+0xb0>
     f3c:	28 1b       	sub	r18, r24
     f3e:	39 0b       	sbc	r19, r25
     f40:	24 30       	cpi	r18, 0x04	; 4
     f42:	31 05       	cpc	r19, r1
     f44:	80 f4       	brcc	.+32     	; 0xf66 <malloc+0x9c>
     f46:	8a 81       	ldd	r24, Y+2	; 0x02
     f48:	9b 81       	ldd	r25, Y+3	; 0x03
     f4a:	61 15       	cp	r22, r1
     f4c:	71 05       	cpc	r23, r1
     f4e:	21 f0       	breq	.+8      	; 0xf58 <malloc+0x8e>
     f50:	fb 01       	movw	r30, r22
     f52:	93 83       	std	Z+3, r25	; 0x03
     f54:	82 83       	std	Z+2, r24	; 0x02
     f56:	04 c0       	rjmp	.+8      	; 0xf60 <malloc+0x96>
     f58:	90 93 82 03 	sts	0x0382, r25	; 0x800382 <__flp+0x1>
     f5c:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <__flp>
     f60:	fe 01       	movw	r30, r28
     f62:	32 96       	adiw	r30, 0x02	; 2
     f64:	44 c0       	rjmp	.+136    	; 0xfee <malloc+0x124>
     f66:	fe 01       	movw	r30, r28
     f68:	e2 0f       	add	r30, r18
     f6a:	f3 1f       	adc	r31, r19
     f6c:	81 93       	st	Z+, r24
     f6e:	91 93       	st	Z+, r25
     f70:	22 50       	subi	r18, 0x02	; 2
     f72:	31 09       	sbc	r19, r1
     f74:	39 83       	std	Y+1, r19	; 0x01
     f76:	28 83       	st	Y, r18
     f78:	3a c0       	rjmp	.+116    	; 0xfee <malloc+0x124>
     f7a:	20 91 7f 03 	lds	r18, 0x037F	; 0x80037f <__brkval>
     f7e:	30 91 80 03 	lds	r19, 0x0380	; 0x800380 <__brkval+0x1>
     f82:	23 2b       	or	r18, r19
     f84:	41 f4       	brne	.+16     	; 0xf96 <malloc+0xcc>
     f86:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
     f8a:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
     f8e:	30 93 80 03 	sts	0x0380, r19	; 0x800380 <__brkval+0x1>
     f92:	20 93 7f 03 	sts	0x037F, r18	; 0x80037f <__brkval>
     f96:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     f9a:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     f9e:	21 15       	cp	r18, r1
     fa0:	31 05       	cpc	r19, r1
     fa2:	41 f4       	brne	.+16     	; 0xfb4 <malloc+0xea>
     fa4:	2d b7       	in	r18, 0x3d	; 61
     fa6:	3e b7       	in	r19, 0x3e	; 62
     fa8:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
     fac:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
     fb0:	24 1b       	sub	r18, r20
     fb2:	35 0b       	sbc	r19, r21
     fb4:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <__brkval>
     fb8:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <__brkval+0x1>
     fbc:	e2 17       	cp	r30, r18
     fbe:	f3 07       	cpc	r31, r19
     fc0:	a0 f4       	brcc	.+40     	; 0xfea <malloc+0x120>
     fc2:	2e 1b       	sub	r18, r30
     fc4:	3f 0b       	sbc	r19, r31
     fc6:	28 17       	cp	r18, r24
     fc8:	39 07       	cpc	r19, r25
     fca:	78 f0       	brcs	.+30     	; 0xfea <malloc+0x120>
     fcc:	ac 01       	movw	r20, r24
     fce:	4e 5f       	subi	r20, 0xFE	; 254
     fd0:	5f 4f       	sbci	r21, 0xFF	; 255
     fd2:	24 17       	cp	r18, r20
     fd4:	35 07       	cpc	r19, r21
     fd6:	48 f0       	brcs	.+18     	; 0xfea <malloc+0x120>
     fd8:	4e 0f       	add	r20, r30
     fda:	5f 1f       	adc	r21, r31
     fdc:	50 93 80 03 	sts	0x0380, r21	; 0x800380 <__brkval+0x1>
     fe0:	40 93 7f 03 	sts	0x037F, r20	; 0x80037f <__brkval>
     fe4:	81 93       	st	Z+, r24
     fe6:	91 93       	st	Z+, r25
     fe8:	02 c0       	rjmp	.+4      	; 0xfee <malloc+0x124>
     fea:	e0 e0       	ldi	r30, 0x00	; 0
     fec:	f0 e0       	ldi	r31, 0x00	; 0
     fee:	cf 01       	movw	r24, r30
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	1f 91       	pop	r17
     ff6:	0f 91       	pop	r16
     ff8:	08 95       	ret

00000ffa <free>:
     ffa:	cf 93       	push	r28
     ffc:	df 93       	push	r29
     ffe:	00 97       	sbiw	r24, 0x00	; 0
    1000:	09 f4       	brne	.+2      	; 0x1004 <free+0xa>
    1002:	81 c0       	rjmp	.+258    	; 0x1106 <free+0x10c>
    1004:	fc 01       	movw	r30, r24
    1006:	32 97       	sbiw	r30, 0x02	; 2
    1008:	13 82       	std	Z+3, r1	; 0x03
    100a:	12 82       	std	Z+2, r1	; 0x02
    100c:	a0 91 81 03 	lds	r26, 0x0381	; 0x800381 <__flp>
    1010:	b0 91 82 03 	lds	r27, 0x0382	; 0x800382 <__flp+0x1>
    1014:	10 97       	sbiw	r26, 0x00	; 0
    1016:	81 f4       	brne	.+32     	; 0x1038 <free+0x3e>
    1018:	20 81       	ld	r18, Z
    101a:	31 81       	ldd	r19, Z+1	; 0x01
    101c:	82 0f       	add	r24, r18
    101e:	93 1f       	adc	r25, r19
    1020:	20 91 7f 03 	lds	r18, 0x037F	; 0x80037f <__brkval>
    1024:	30 91 80 03 	lds	r19, 0x0380	; 0x800380 <__brkval+0x1>
    1028:	28 17       	cp	r18, r24
    102a:	39 07       	cpc	r19, r25
    102c:	51 f5       	brne	.+84     	; 0x1082 <free+0x88>
    102e:	f0 93 80 03 	sts	0x0380, r31	; 0x800380 <__brkval+0x1>
    1032:	e0 93 7f 03 	sts	0x037F, r30	; 0x80037f <__brkval>
    1036:	67 c0       	rjmp	.+206    	; 0x1106 <free+0x10c>
    1038:	ed 01       	movw	r28, r26
    103a:	20 e0       	ldi	r18, 0x00	; 0
    103c:	30 e0       	ldi	r19, 0x00	; 0
    103e:	ce 17       	cp	r28, r30
    1040:	df 07       	cpc	r29, r31
    1042:	40 f4       	brcc	.+16     	; 0x1054 <free+0x5a>
    1044:	4a 81       	ldd	r20, Y+2	; 0x02
    1046:	5b 81       	ldd	r21, Y+3	; 0x03
    1048:	9e 01       	movw	r18, r28
    104a:	41 15       	cp	r20, r1
    104c:	51 05       	cpc	r21, r1
    104e:	f1 f0       	breq	.+60     	; 0x108c <free+0x92>
    1050:	ea 01       	movw	r28, r20
    1052:	f5 cf       	rjmp	.-22     	; 0x103e <free+0x44>
    1054:	d3 83       	std	Z+3, r29	; 0x03
    1056:	c2 83       	std	Z+2, r28	; 0x02
    1058:	40 81       	ld	r20, Z
    105a:	51 81       	ldd	r21, Z+1	; 0x01
    105c:	84 0f       	add	r24, r20
    105e:	95 1f       	adc	r25, r21
    1060:	c8 17       	cp	r28, r24
    1062:	d9 07       	cpc	r29, r25
    1064:	59 f4       	brne	.+22     	; 0x107c <free+0x82>
    1066:	88 81       	ld	r24, Y
    1068:	99 81       	ldd	r25, Y+1	; 0x01
    106a:	84 0f       	add	r24, r20
    106c:	95 1f       	adc	r25, r21
    106e:	02 96       	adiw	r24, 0x02	; 2
    1070:	91 83       	std	Z+1, r25	; 0x01
    1072:	80 83       	st	Z, r24
    1074:	8a 81       	ldd	r24, Y+2	; 0x02
    1076:	9b 81       	ldd	r25, Y+3	; 0x03
    1078:	93 83       	std	Z+3, r25	; 0x03
    107a:	82 83       	std	Z+2, r24	; 0x02
    107c:	21 15       	cp	r18, r1
    107e:	31 05       	cpc	r19, r1
    1080:	29 f4       	brne	.+10     	; 0x108c <free+0x92>
    1082:	f0 93 82 03 	sts	0x0382, r31	; 0x800382 <__flp+0x1>
    1086:	e0 93 81 03 	sts	0x0381, r30	; 0x800381 <__flp>
    108a:	3d c0       	rjmp	.+122    	; 0x1106 <free+0x10c>
    108c:	e9 01       	movw	r28, r18
    108e:	fb 83       	std	Y+3, r31	; 0x03
    1090:	ea 83       	std	Y+2, r30	; 0x02
    1092:	49 91       	ld	r20, Y+
    1094:	59 91       	ld	r21, Y+
    1096:	c4 0f       	add	r28, r20
    1098:	d5 1f       	adc	r29, r21
    109a:	ec 17       	cp	r30, r28
    109c:	fd 07       	cpc	r31, r29
    109e:	61 f4       	brne	.+24     	; 0x10b8 <free+0xbe>
    10a0:	80 81       	ld	r24, Z
    10a2:	91 81       	ldd	r25, Z+1	; 0x01
    10a4:	84 0f       	add	r24, r20
    10a6:	95 1f       	adc	r25, r21
    10a8:	02 96       	adiw	r24, 0x02	; 2
    10aa:	e9 01       	movw	r28, r18
    10ac:	99 83       	std	Y+1, r25	; 0x01
    10ae:	88 83       	st	Y, r24
    10b0:	82 81       	ldd	r24, Z+2	; 0x02
    10b2:	93 81       	ldd	r25, Z+3	; 0x03
    10b4:	9b 83       	std	Y+3, r25	; 0x03
    10b6:	8a 83       	std	Y+2, r24	; 0x02
    10b8:	e0 e0       	ldi	r30, 0x00	; 0
    10ba:	f0 e0       	ldi	r31, 0x00	; 0
    10bc:	12 96       	adiw	r26, 0x02	; 2
    10be:	8d 91       	ld	r24, X+
    10c0:	9c 91       	ld	r25, X
    10c2:	13 97       	sbiw	r26, 0x03	; 3
    10c4:	00 97       	sbiw	r24, 0x00	; 0
    10c6:	19 f0       	breq	.+6      	; 0x10ce <free+0xd4>
    10c8:	fd 01       	movw	r30, r26
    10ca:	dc 01       	movw	r26, r24
    10cc:	f7 cf       	rjmp	.-18     	; 0x10bc <free+0xc2>
    10ce:	8d 91       	ld	r24, X+
    10d0:	9c 91       	ld	r25, X
    10d2:	11 97       	sbiw	r26, 0x01	; 1
    10d4:	9d 01       	movw	r18, r26
    10d6:	2e 5f       	subi	r18, 0xFE	; 254
    10d8:	3f 4f       	sbci	r19, 0xFF	; 255
    10da:	82 0f       	add	r24, r18
    10dc:	93 1f       	adc	r25, r19
    10de:	20 91 7f 03 	lds	r18, 0x037F	; 0x80037f <__brkval>
    10e2:	30 91 80 03 	lds	r19, 0x0380	; 0x800380 <__brkval+0x1>
    10e6:	28 17       	cp	r18, r24
    10e8:	39 07       	cpc	r19, r25
    10ea:	69 f4       	brne	.+26     	; 0x1106 <free+0x10c>
    10ec:	30 97       	sbiw	r30, 0x00	; 0
    10ee:	29 f4       	brne	.+10     	; 0x10fa <free+0x100>
    10f0:	10 92 82 03 	sts	0x0382, r1	; 0x800382 <__flp+0x1>
    10f4:	10 92 81 03 	sts	0x0381, r1	; 0x800381 <__flp>
    10f8:	02 c0       	rjmp	.+4      	; 0x10fe <free+0x104>
    10fa:	13 82       	std	Z+3, r1	; 0x03
    10fc:	12 82       	std	Z+2, r1	; 0x02
    10fe:	b0 93 80 03 	sts	0x0380, r27	; 0x800380 <__brkval+0x1>
    1102:	a0 93 7f 03 	sts	0x037F, r26	; 0x80037f <__brkval>
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
    110a:	08 95       	ret

0000110c <_exit>:
    110c:	f8 94       	cli

0000110e <__stop_program>:
    110e:	ff cf       	rjmp	.-2      	; 0x110e <__stop_program>
