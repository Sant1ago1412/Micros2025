
Cinta_Final.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  0000106c  00001100  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000106c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000277  0080010a  0080010a  0000110a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000110a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000113c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000150  00000000  00000000  0000117c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001b00  00000000  00000000  000012cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b6a  00000000  00000000  00002dcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d33  00000000  00000000  00003936  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003dc  00000000  00000000  0000466c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009f7  00000000  00000000  00004a48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a6e  00000000  00000000  0000543f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  00005ead  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
       4:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       8:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      28:	0c 94 36 01 	jmp	0x26c	; 0x26c <__vector_10>
      2c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__vector_11>
      30:	0c 94 01 01 	jmp	0x202	; 0x202 <__vector_12>
      34:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      40:	0c 94 7d 01 	jmp	0x2fa	; 0x2fa <__vector_16>
      44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      48:	0c 94 a1 01 	jmp	0x342	; 0x342 <__vector_18>
      4c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      54:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      58:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      5c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      60:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      64:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      68:	6f 03       	fmul	r22, r23
      6a:	7d 03       	fmul	r23, r21
      6c:	95 03       	fmuls	r17, r21
      6e:	aa 03       	fmulsu	r18, r18
      70:	bf 03       	fmulsu	r19, r23
      72:	cd 03       	fmulsu	r20, r21
      74:	f2 03       	fmuls	r23, r18

00000076 <__ctors_end>:
      76:	11 24       	eor	r1, r1
      78:	1f be       	out	0x3f, r1	; 63
      7a:	cf ef       	ldi	r28, 0xFF	; 255
      7c:	d8 e0       	ldi	r29, 0x08	; 8
      7e:	de bf       	out	0x3e, r29	; 62
      80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
      82:	11 e0       	ldi	r17, 0x01	; 1
      84:	a0 e0       	ldi	r26, 0x00	; 0
      86:	b1 e0       	ldi	r27, 0x01	; 1
      88:	ec e6       	ldi	r30, 0x6C	; 108
      8a:	f0 e1       	ldi	r31, 0x10	; 16
      8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
      8e:	05 90       	lpm	r0, Z+
      90:	0d 92       	st	X+, r0
      92:	aa 30       	cpi	r26, 0x0A	; 10
      94:	b1 07       	cpc	r27, r17
      96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
      98:	23 e0       	ldi	r18, 0x03	; 3
      9a:	aa e0       	ldi	r26, 0x0A	; 10
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
      a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
      a2:	a1 38       	cpi	r26, 0x81	; 129
      a4:	b2 07       	cpc	r27, r18
      a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
      a8:	0e 94 ea 05 	call	0xbd4	; 0xbd4 <main>
      ac:	0c 94 34 08 	jmp	0x1068	; 0x1068 <_exit>

000000b0 <__bad_interrupt>:
      b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <HCSR04_AddNew>:
      b4:	cf 92       	push	r12
      b6:	df 92       	push	r13
      b8:	ef 92       	push	r14
      ba:	ff 92       	push	r15
      bc:	cf 93       	push	r28
      be:	df 93       	push	r29
      c0:	ec 01       	movw	r28, r24
      c2:	6a 01       	movw	r12, r20
      c4:	7b 01       	movw	r14, r22
      c6:	8f e0       	ldi	r24, 0x0F	; 15
      c8:	90 e0       	ldi	r25, 0x00	; 0
      ca:	0e 94 13 07 	call	0xe26	; 0xe26 <malloc>
      ce:	fc 01       	movw	r30, r24
      d0:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
      d4:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
      d8:	d1 83       	std	Z+1, r29	; 0x01
      da:	c0 83       	st	Z, r28
      dc:	c2 86       	std	Z+10, r12	; 0x0a
      de:	d3 86       	std	Z+11, r13	; 0x0b
      e0:	e4 86       	std	Z+12, r14	; 0x0c
      e2:	f5 86       	std	Z+13, r15	; 0x0d
      e4:	16 86       	std	Z+14, r1	; 0x0e
      e6:	11 86       	std	Z+9, r1	; 0x09
      e8:	10 86       	std	Z+8, r1	; 0x08
      ea:	15 82       	std	Z+5, r1	; 0x05
      ec:	14 82       	std	Z+4, r1	; 0x04
      ee:	17 82       	std	Z+7, r1	; 0x07
      f0:	16 82       	std	Z+6, r1	; 0x06
      f2:	80 e0       	ldi	r24, 0x00	; 0
      f4:	fe 01       	movw	r30, r28
      f6:	09 95       	icall
      f8:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <__data_end>
      fc:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <__data_end+0x1>
     100:	df 91       	pop	r29
     102:	cf 91       	pop	r28
     104:	ff 90       	pop	r15
     106:	ef 90       	pop	r14
     108:	df 90       	pop	r13
     10a:	cf 90       	pop	r12
     10c:	08 95       	ret

0000010e <HCSR04_Start>:
     10e:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     112:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
     116:	dc 01       	movw	r26, r24
     118:	ed 91       	ld	r30, X+
     11a:	fc 91       	ld	r31, X
     11c:	81 e0       	ldi	r24, 0x01	; 1
     11e:	09 95       	icall
     120:	08 95       	ret

00000122 <HCSR04_TriggerReady>:
     122:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     126:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
     12a:	dc 01       	movw	r26, r24
     12c:	ed 91       	ld	r30, X+
     12e:	fc 91       	ld	r31, X
     130:	80 e0       	ldi	r24, 0x00	; 0
     132:	09 95       	icall
     134:	08 95       	ret

00000136 <HCSR04_RiseEdgeTime>:
     136:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     13a:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
     13e:	fc 01       	movw	r30, r24
     140:	75 83       	std	Z+5, r23	; 0x05
     142:	64 83       	std	Z+4, r22	; 0x04
     144:	16 86       	std	Z+14, r1	; 0x0e
     146:	08 95       	ret

00000148 <HCSR04_FallEdgeTime>:
     148:	fc 01       	movw	r30, r24
     14a:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     14e:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
     152:	77 83       	std	Z+7, r23	; 0x07
     154:	66 83       	std	Z+6, r22	; 0x06
     156:	86 85       	ldd	r24, Z+14	; 0x0e
     158:	81 60       	ori	r24, 0x01	; 1
     15a:	86 87       	std	Z+14, r24	; 0x0e
     15c:	08 95       	ret

0000015e <task_HCSR>:
     15e:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <__data_end>
     162:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <__data_end+0x1>
     166:	30 97       	sbiw	r30, 0x00	; 0
     168:	11 f1       	breq	.+68     	; 0x1ae <task_HCSR+0x50>
     16a:	86 85       	ldd	r24, Z+14	; 0x0e
     16c:	80 ff       	sbrs	r24, 0
     16e:	1f c0       	rjmp	.+62     	; 0x1ae <task_HCSR+0x50>
     170:	16 86       	std	Z+14, r1	; 0x0e
     172:	24 81       	ldd	r18, Z+4	; 0x04
     174:	35 81       	ldd	r19, Z+5	; 0x05
     176:	86 81       	ldd	r24, Z+6	; 0x06
     178:	97 81       	ldd	r25, Z+7	; 0x07
     17a:	28 17       	cp	r18, r24
     17c:	39 07       	cpc	r19, r25
     17e:	28 f4       	brcc	.+10     	; 0x18a <task_HCSR+0x2c>
     180:	82 1b       	sub	r24, r18
     182:	93 0b       	sbc	r25, r19
     184:	91 87       	std	Z+9, r25	; 0x09
     186:	80 87       	std	Z+8, r24	; 0x08
     188:	05 c0       	rjmp	.+10     	; 0x194 <task_HCSR+0x36>
     18a:	82 1b       	sub	r24, r18
     18c:	93 0b       	sbc	r25, r19
     18e:	01 97       	sbiw	r24, 0x01	; 1
     190:	91 87       	std	Z+9, r25	; 0x09
     192:	80 87       	std	Z+8, r24	; 0x08
     194:	80 85       	ldd	r24, Z+8	; 0x08
     196:	91 85       	ldd	r25, Z+9	; 0x09
     198:	85 3f       	cpi	r24, 0xF5	; 245
     19a:	9d 42       	sbci	r25, 0x2D	; 45
     19c:	20 f0       	brcs	.+8      	; 0x1a6 <task_HCSR+0x48>
     19e:	8f ef       	ldi	r24, 0xFF	; 255
     1a0:	9f ef       	ldi	r25, 0xFF	; 255
     1a2:	91 87       	std	Z+9, r25	; 0x09
     1a4:	80 87       	std	Z+8, r24	; 0x08
     1a6:	80 85       	ldd	r24, Z+8	; 0x08
     1a8:	91 85       	ldd	r25, Z+9	; 0x09
     1aa:	0e 94 61 04 	call	0x8c2	; 0x8c2 <sensorMeasure>
     1ae:	08 95       	ret

000001b0 <WritePin_HCSR>:
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
	}
}

void WritePin_HCSR(uint8_t value){
	if (value)
     1b0:	88 23       	and	r24, r24
     1b2:	21 f0       	breq	.+8      	; 0x1bc <WritePin_HCSR+0xc>
	PORTB |= (1<<TRIGGER);				// Sets a HIGH state (1) in the TRIGGER pin
     1b4:	85 b1       	in	r24, 0x05	; 5
     1b6:	82 60       	ori	r24, 0x02	; 2
     1b8:	85 b9       	out	0x05, r24	; 5
     1ba:	08 95       	ret
	else
	PORTB &= ~(1<<TRIGGER);				// Sets a LOW state (0) in the TRIGGER pin
     1bc:	85 b1       	in	r24, 0x05	; 5
     1be:	8d 7f       	andi	r24, 0xFD	; 253
     1c0:	85 b9       	out	0x05, r24	; 5
     1c2:	08 95       	ret

000001c4 <__vector_11>:

/* END Constant in Flash -----------------------------------------------------*/


/* Function ISR --------------------------------------------------------------*/
ISR(TIMER1_COMPA_vect){
     1c4:	1f 92       	push	r1
     1c6:	0f 92       	push	r0
     1c8:	0f b6       	in	r0, 0x3f	; 63
     1ca:	0f 92       	push	r0
     1cc:	11 24       	eor	r1, r1
     1ce:	8f 93       	push	r24
     1d0:	9f 93       	push	r25
     1d2:	ef 93       	push	r30
     1d4:	ff 93       	push	r31
	
	/*		Con el OCR1B en 20000 , cuento cada 10ms		*/
	IS10MS=TRUE;
     1d6:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <flag0>
     1da:	81 60       	ori	r24, 0x01	; 1
     1dc:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <flag0>
	OCR1A += 19999;
     1e0:	e8 e8       	ldi	r30, 0x88	; 136
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	91 81       	ldd	r25, Z+1	; 0x01
     1e8:	81 5e       	subi	r24, 0xE1	; 225
     1ea:	91 4b       	sbci	r25, 0xB1	; 177
     1ec:	91 83       	std	Z+1, r25	; 0x01
     1ee:	80 83       	st	Z, r24
	
}
     1f0:	ff 91       	pop	r31
     1f2:	ef 91       	pop	r30
     1f4:	9f 91       	pop	r25
     1f6:	8f 91       	pop	r24
     1f8:	0f 90       	pop	r0
     1fa:	0f be       	out	0x3f, r0	; 63
     1fc:	0f 90       	pop	r0
     1fe:	1f 90       	pop	r1
     200:	18 95       	reti

00000202 <__vector_12>:

ISR(TIMER1_COMPB_vect){
     202:	1f 92       	push	r1
     204:	0f 92       	push	r0
     206:	0f b6       	in	r0, 0x3f	; 63
     208:	0f 92       	push	r0
     20a:	11 24       	eor	r1, r1
     20c:	2f 93       	push	r18
     20e:	3f 93       	push	r19
     210:	4f 93       	push	r20
     212:	5f 93       	push	r21
     214:	6f 93       	push	r22
     216:	7f 93       	push	r23
     218:	8f 93       	push	r24
     21a:	9f 93       	push	r25
     21c:	af 93       	push	r26
     21e:	bf 93       	push	r27
     220:	ef 93       	push	r30
     222:	ff 93       	push	r31
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
}

static inline void on_timer1_compb_hcsr(){
	HCSR04_TriggerReady(HCSR_1);					//Pongo en LOW el Trigger
     224:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <HCSR_1>
     228:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <HCSR_1+0x1>
     22c:	0e 94 91 00 	call	0x122	; 0x122 <HCSR04_TriggerReady>
	TIFR1 |= (1<<ICF1);								// Timer/Counter1 Output Compare A Match Flag enabled
     230:	86 b3       	in	r24, 0x16	; 22
     232:	80 62       	ori	r24, 0x20	; 32
     234:	86 bb       	out	0x16, r24	; 22
	TCCR1B = (1 << ICNC1) | (1 << ICES1);			// Input Capture Noise Canceler and Input Capture Edge Select activated
     236:	e1 e8       	ldi	r30, 0x81	; 129
     238:	f0 e0       	ldi	r31, 0x00	; 0
     23a:	80 ec       	ldi	r24, 0xC0	; 192
     23c:	80 83       	st	Z, r24
	TCCR1B |= (1 << CS11);							// Prescaler definition (x8): CS12 = 0 and CS10 = 0
     23e:	80 81       	ld	r24, Z
     240:	82 60       	ori	r24, 0x02	; 2
     242:	80 83       	st	Z, r24
	TIMSK1 = (1<<ICIE1) | (1<<OCIE1A);				// Input Capture Interrupt and Output Compare A Match Interrupt enabled <---
     244:	82 e2       	ldi	r24, 0x22	; 34
     246:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	
	on_timer1_compb_hcsr();
	
}
     24a:	ff 91       	pop	r31
     24c:	ef 91       	pop	r30
     24e:	bf 91       	pop	r27
     250:	af 91       	pop	r26
     252:	9f 91       	pop	r25
     254:	8f 91       	pop	r24
     256:	7f 91       	pop	r23
     258:	6f 91       	pop	r22
     25a:	5f 91       	pop	r21
     25c:	4f 91       	pop	r20
     25e:	3f 91       	pop	r19
     260:	2f 91       	pop	r18
     262:	0f 90       	pop	r0
     264:	0f be       	out	0x3f, r0	; 63
     266:	0f 90       	pop	r0
     268:	1f 90       	pop	r1
     26a:	18 95       	reti

0000026c <__vector_10>:

ISR(TIMER1_CAPT_vect){
     26c:	1f 92       	push	r1
     26e:	0f 92       	push	r0
     270:	0f b6       	in	r0, 0x3f	; 63
     272:	0f 92       	push	r0
     274:	11 24       	eor	r1, r1
     276:	2f 93       	push	r18
     278:	3f 93       	push	r19
     27a:	4f 93       	push	r20
     27c:	5f 93       	push	r21
     27e:	6f 93       	push	r22
     280:	7f 93       	push	r23
     282:	8f 93       	push	r24
     284:	9f 93       	push	r25
     286:	af 93       	push	r26
     288:	bf 93       	push	r27
     28a:	ef 93       	push	r30
     28c:	ff 93       	push	r31
}

static inline void on_timer1_capt_hcsr(){
	if (TCCR1B & (1<<ICES1)){						// Si ICES1 = 1  el Timer va a capturar en el flanco de subida (rising edge).
     28e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
     292:	86 ff       	sbrs	r24, 6
     294:	10 c0       	rjmp	.+32     	; 0x2b6 <__vector_10+0x4a>
		
		TCCR1B = (1 << ICNC1) | (1 << CS11);		//preparo para capturar el flanco de bajada
     296:	82 e8       	ldi	r24, 0x82	; 130
     298:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
		HCSR04_RiseEdgeTime(HCSR_1, ICR1 >> 1);		//[[ ICR1 >> 1  ==  ICR1 / 2 ]] -> En ICR1 almacena el valor de TCNT1, Es decir, guardo el momento en que llego el RISE. Como ICR1 obtiene un tick cada 500ns, si contó 3000 ticks, se hace la cuenta 3000 * 0,5us = 1500us. (500ns = 0,5us = 1/2).
     29c:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2a0:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2a4:	76 95       	lsr	r23
     2a6:	67 95       	ror	r22
     2a8:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <HCSR_1>
     2ac:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <HCSR_1+0x1>
     2b0:	0e 94 9b 00 	call	0x136	; 0x136 <HCSR04_RiseEdgeTime>
     2b4:	11 c0       	rjmp	.+34     	; 0x2d8 <__vector_10+0x6c>
		}else{										// Falling edge is used as trigger

		TIMSK1 &= ~_BV(ICIE1);						//desactivo la interrupcion por input capture
     2b6:	ef e6       	ldi	r30, 0x6F	; 111
     2b8:	f0 e0       	ldi	r31, 0x00	; 0
     2ba:	80 81       	ld	r24, Z
     2bc:	8f 7d       	andi	r24, 0xDF	; 223
     2be:	80 83       	st	Z, r24
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
     2c0:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2c4:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2c8:	76 95       	lsr	r23
     2ca:	67 95       	ror	r22
     2cc:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <HCSR_1>
     2d0:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <HCSR_1+0x1>
     2d4:	0e 94 a4 00 	call	0x148	; 0x148 <HCSR04_FallEdgeTime>
	
	on_timer1_capt_hcsr();
	
}
     2d8:	ff 91       	pop	r31
     2da:	ef 91       	pop	r30
     2dc:	bf 91       	pop	r27
     2de:	af 91       	pop	r26
     2e0:	9f 91       	pop	r25
     2e2:	8f 91       	pop	r24
     2e4:	7f 91       	pop	r23
     2e6:	6f 91       	pop	r22
     2e8:	5f 91       	pop	r21
     2ea:	4f 91       	pop	r20
     2ec:	3f 91       	pop	r19
     2ee:	2f 91       	pop	r18
     2f0:	0f 90       	pop	r0
     2f2:	0f be       	out	0x3f, r0	; 63
     2f4:	0f 90       	pop	r0
     2f6:	1f 90       	pop	r1
     2f8:	18 95       	reti

000002fa <__vector_16>:

ISR(TIMER0_OVF_vect){
     2fa:	1f 92       	push	r1
     2fc:	0f 92       	push	r0
     2fe:	0f b6       	in	r0, 0x3f	; 63
     300:	0f 92       	push	r0
     302:	11 24       	eor	r1, r1
     304:	2f 93       	push	r18
     306:	3f 93       	push	r19
     308:	4f 93       	push	r20
     30a:	5f 93       	push	r21
     30c:	6f 93       	push	r22
     30e:	7f 93       	push	r23
     310:	8f 93       	push	r24
     312:	9f 93       	push	r25
     314:	af 93       	push	r26
     316:	bf 93       	push	r27
     318:	ef 93       	push	r30
     31a:	ff 93       	push	r31
	
	writeServo();
     31c:	0e 94 a1 06 	call	0xd42	; 0xd42 <writeServo>
	
}
     320:	ff 91       	pop	r31
     322:	ef 91       	pop	r30
     324:	bf 91       	pop	r27
     326:	af 91       	pop	r26
     328:	9f 91       	pop	r25
     32a:	8f 91       	pop	r24
     32c:	7f 91       	pop	r23
     32e:	6f 91       	pop	r22
     330:	5f 91       	pop	r21
     332:	4f 91       	pop	r20
     334:	3f 91       	pop	r19
     336:	2f 91       	pop	r18
     338:	0f 90       	pop	r0
     33a:	0f be       	out	0x3f, r0	; 63
     33c:	0f 90       	pop	r0
     33e:	1f 90       	pop	r1
     340:	18 95       	reti

00000342 <__vector_18>:

ISR(USART_RX_vect){
     342:	1f 92       	push	r1
     344:	0f 92       	push	r0
     346:	0f b6       	in	r0, 0x3f	; 63
     348:	0f 92       	push	r0
     34a:	11 24       	eor	r1, r1
     34c:	8f 93       	push	r24
     34e:	9f 93       	push	r25
     350:	af 93       	push	r26
     352:	bf 93       	push	r27
     354:	ef 93       	push	r30
     356:	ff 93       	push	r31
	dataRx.buff[dataRx.indexW++] = UDR0;
     358:	e5 e3       	ldi	r30, 0x35	; 53
     35a:	f2 e0       	ldi	r31, 0x02	; 2
     35c:	a0 81       	ld	r26, Z
     35e:	b1 81       	ldd	r27, Z+1	; 0x01
     360:	83 81       	ldd	r24, Z+3	; 0x03
     362:	91 e0       	ldi	r25, 0x01	; 1
     364:	98 0f       	add	r25, r24
     366:	93 83       	std	Z+3, r25	; 0x03
     368:	a8 0f       	add	r26, r24
     36a:	b1 1d       	adc	r27, r1
     36c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     370:	8c 93       	st	X, r24
	dataRx.indexW &= dataRx.mask;
     372:	85 81       	ldd	r24, Z+5	; 0x05
     374:	93 81       	ldd	r25, Z+3	; 0x03
     376:	89 23       	and	r24, r25
     378:	83 83       	std	Z+3, r24	; 0x03
}
     37a:	ff 91       	pop	r31
     37c:	ef 91       	pop	r30
     37e:	bf 91       	pop	r27
     380:	af 91       	pop	r26
     382:	9f 91       	pop	r25
     384:	8f 91       	pop	r24
     386:	0f 90       	pop	r0
     388:	0f be       	out	0x3f, r0	; 63
     38a:	0f 90       	pop	r0
     38c:	1f 90       	pop	r1
     38e:	18 95       	reti

00000390 <ini_ports>:
void ini_ports(){
	
	/************************************************************************/
	/*								OUTPUTS                                 */
	/************************************************************************/
	DDRB = ((1 << LED_BI)| (1 << SV1) | (1 << SV2) | (1<<TRIGGER) | (1<<LED_1));
     390:	8e e3       	ldi	r24, 0x3E	; 62
     392:	84 b9       	out	0x04, r24	; 4
	DDRD = (1 << SV0)|(1<<LED_2);
     394:	80 ec       	ldi	r24, 0xC0	; 192
     396:	8a b9       	out	0x0a, r24	; 10
	
	/************************************************************************/
	/*								INPUTS                                  */
	/************************************************************************/
	DDRB &= ~(1<<ECHO);
     398:	84 b1       	in	r24, 0x04	; 4
     39a:	8e 7f       	andi	r24, 0xFE	; 254
     39c:	84 b9       	out	0x04, r24	; 4
	DDRD &= ~((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     39e:	8a b1       	in	r24, 0x0a	; 10
     3a0:	83 7c       	andi	r24, 0xC3	; 195
     3a2:	8a b9       	out	0x0a, r24	; 10
	
	/*						Activo Pull ups internos						*/
	PORTB = (1<<ECHO);
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	85 b9       	out	0x05, r24	; 5
	PORTD = ((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3a8:	8c e3       	ldi	r24, 0x3C	; 60
     3aa:	8b b9       	out	0x0b, r24	; 11
     3ac:	08 95       	ret

000003ae <ini_timer1>:
/************************************************************************/
/*		Timer 1 es funcional al HCSR y a la accion cada 10ms            */
/************************************************************************/
void ini_timer1(){
	
	TCCR1A = 0x00;
     3ae:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
	/* Configuro noise canceler del input capture, el flanco del input capture y prescaler en 8 (f = 16MHz / 8 = 2MHz ? 1 tick = 0.5 µs) */
	TCCR1B = 0xC2;
     3b2:	82 ec       	ldi	r24, 0xC2	; 194
     3b4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
	TCNT1 = 0x00;
     3b8:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     3bc:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
	/*	Activo la interrupcion por comparador b	*/
	TIMSK1 = (1<<OCIE1A);
     3c0:	82 e0       	ldi	r24, 0x02	; 2
     3c2:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	/* Le doy un valor al comparador B	*/
	OCR1A = 19999;
     3c6:	8f e1       	ldi	r24, 0x1F	; 31
     3c8:	9e e4       	ldi	r25, 0x4E	; 78
     3ca:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     3ce:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
	TIFR1 = TIFR1;
     3d2:	86 b3       	in	r24, 0x16	; 22
     3d4:	86 bb       	out	0x16, r24	; 22
     3d6:	08 95       	ret

000003d8 <ini_timer0>:
/************************************************************************/
/*			Timer 0 funcional a generar el pwm de los servos			*/
/************************************************************************/
void ini_timer0(){
	
	TCCR0A = 0;
     3d8:	14 bc       	out	0x24, r1	; 36
	TCNT0 = 0;
     3da:	16 bc       	out	0x26, r1	; 38
	/*	Pongo las banderas en 0 con TIFR	*/
	TIFR0 = 0x07;
     3dc:	87 e0       	ldi	r24, 0x07	; 7
     3de:	85 bb       	out	0x15, r24	; 21
	/*	Habilito la interrupcion por TOV	*/
	TIMSK0 = (1<<TOIE0);
     3e0:	81 e0       	ldi	r24, 0x01	; 1
     3e2:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
	/*	Prescaler en 8 , obtengo el cuentas de 500ns, tov a 500*256 = 128us		*/
	TCCR0B = (1<<CS01);
     3e6:	82 e0       	ldi	r24, 0x02	; 2
     3e8:	85 bd       	out	0x25, r24	; 37
     3ea:	08 95       	ret

000003ec <ini_USART>:
	
}

void ini_USART(uint8_t ubrr){
	UBRR0H = 0;
     3ec:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = ubrr;
     3f0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	UCSR0A = 0xFE; //inicializo todas las banderas excepto el multiprocesor
     3f4:	8e ef       	ldi	r24, 0xFE	; 254
     3f6:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	UCSR0B =   0x98; // (1<<RXCIE0) | (1<<RXEN0)|(1<<TXEN0); //Activo las banderas de interrupcion de recepcion y la habilitacion del rx y tx
     3fa:	88 e9       	ldi	r24, 0x98	; 152
     3fc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
     400:	86 e0       	ldi	r24, 0x06	; 6
     402:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     406:	08 95       	ret

00000408 <IR_Init>:
	
}

void IR_Init(IRDebounce *ir) {
     408:	ac 01       	movw	r20, r24
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     40a:	20 e0       	ldi	r18, 0x00	; 0
     40c:	30 e0       	ldi	r19, 0x00	; 0
     40e:	0d c0       	rjmp	.+26     	; 0x42a <IR_Init+0x22>
		ir[globalIndex].state = IR_UP;
     410:	f9 01       	movw	r30, r18
     412:	ee 0f       	add	r30, r30
     414:	ff 1f       	adc	r31, r31
     416:	ee 0f       	add	r30, r30
     418:	ff 1f       	adc	r31, r31
     41a:	e4 0f       	add	r30, r20
     41c:	f5 1f       	adc	r31, r21
     41e:	91 e0       	ldi	r25, 0x01	; 1
     420:	90 83       	st	Z, r25
		ir[globalIndex].last_sample = 1;
     422:	92 83       	std	Z+2, r25	; 0x02
		ir[globalIndex].stateConfirmed = 0;
     424:	11 82       	std	Z+1, r1	; 0x01
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
	
}

void IR_Init(IRDebounce *ir) {
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     426:	2f 5f       	subi	r18, 0xFF	; 255
     428:	3f 4f       	sbci	r19, 0xFF	; 255
     42a:	24 30       	cpi	r18, 0x04	; 4
     42c:	31 05       	cpc	r19, r1
     42e:	84 f3       	brlt	.-32     	; 0x410 <IR_Init+0x8>
		ir[globalIndex].state = IR_UP;
		ir[globalIndex].last_sample = 1;
		ir[globalIndex].stateConfirmed = 0;
	}
}
     430:	08 95       	ret

00000432 <IR_Update>:

void IR_Update(IRDebounce *ir, uint8_t sample) {
     432:	fc 01       	movw	r30, r24
	switch (ir->state) {
     434:	80 81       	ld	r24, Z
     436:	81 30       	cpi	r24, 0x01	; 1
     438:	89 f0       	breq	.+34     	; 0x45c <IR_Update+0x2a>
     43a:	28 f0       	brcs	.+10     	; 0x446 <IR_Update+0x14>
     43c:	82 30       	cpi	r24, 0x02	; 2
     43e:	b1 f0       	breq	.+44     	; 0x46c <IR_Update+0x3a>
     440:	83 30       	cpi	r24, 0x03	; 3
     442:	01 f1       	breq	.+64     	; 0x484 <IR_Update+0x52>
     444:	26 c0       	rjmp	.+76     	; 0x492 <IR_Update+0x60>
		case IR_RISING:
		if (sample == 1 && ir->last_sample == 1){
     446:	61 30       	cpi	r22, 0x01	; 1
     448:	31 f4       	brne	.+12     	; 0x456 <IR_Update+0x24>
     44a:	82 81       	ldd	r24, Z+2	; 0x02
     44c:	81 30       	cpi	r24, 0x01	; 1
     44e:	19 f4       	brne	.+6      	; 0x456 <IR_Update+0x24>
			ir->state = IR_UP;
     450:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x01;
     452:	81 83       	std	Z+1, r24	; 0x01
     454:	20 c0       	rjmp	.+64     	; 0x496 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     456:	83 e0       	ldi	r24, 0x03	; 3
     458:	80 83       	st	Z, r24
     45a:	1d c0       	rjmp	.+58     	; 0x496 <IR_Update+0x64>
		}
		break;

		case IR_UP:
		if (sample == 0){
     45c:	61 11       	cpse	r22, r1
     45e:	03 c0       	rjmp	.+6      	; 0x466 <IR_Update+0x34>
			ir->state = IR_FALLING;
     460:	82 e0       	ldi	r24, 0x02	; 2
     462:	80 83       	st	Z, r24
     464:	18 c0       	rjmp	.+48     	; 0x496 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     466:	81 e0       	ldi	r24, 0x01	; 1
     468:	80 83       	st	Z, r24
     46a:	15 c0       	rjmp	.+42     	; 0x496 <IR_Update+0x64>
		}
		break;

		case IR_FALLING:
		if (sample == 0 && ir->last_sample == 0){
     46c:	61 11       	cpse	r22, r1
     46e:	07 c0       	rjmp	.+14     	; 0x47e <IR_Update+0x4c>
     470:	82 81       	ldd	r24, Z+2	; 0x02
     472:	81 11       	cpse	r24, r1
     474:	04 c0       	rjmp	.+8      	; 0x47e <IR_Update+0x4c>
			ir->state = IR_DOWN;
     476:	83 e0       	ldi	r24, 0x03	; 3
     478:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x00;
     47a:	11 82       	std	Z+1, r1	; 0x01
     47c:	0c c0       	rjmp	.+24     	; 0x496 <IR_Update+0x64>
			
			}else{
			ir->state = IR_UP;
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	80 83       	st	Z, r24
     482:	09 c0       	rjmp	.+18     	; 0x496 <IR_Update+0x64>
		}
		break;

		case IR_DOWN:
		if (sample == 1){
     484:	61 30       	cpi	r22, 0x01	; 1
     486:	11 f4       	brne	.+4      	; 0x48c <IR_Update+0x5a>
			ir->state = IR_RISING;
     488:	10 82       	st	Z, r1
     48a:	05 c0       	rjmp	.+10     	; 0x496 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     48c:	83 e0       	ldi	r24, 0x03	; 3
     48e:	80 83       	st	Z, r24
     490:	02 c0       	rjmp	.+4      	; 0x496 <IR_Update+0x64>
		}
		break;
		default:
		ir->state = IR_UP;
     492:	81 e0       	ldi	r24, 0x01	; 1
     494:	80 83       	st	Z, r24
		break;
	}

	ir->last_sample = sample;
     496:	62 83       	std	Z+2, r22	; 0x02
     498:	08 95       	ret

0000049a <IR_GetState>:
}

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}
     49a:	fc 01       	movw	r30, r24
     49c:	81 81       	ldd	r24, Z+1	; 0x01
     49e:	08 95       	ret

000004a0 <putHeaderOnTx>:
			dataTx->indexR &= dataTx->mask;
		}
	}
}

uint8_t putHeaderOnTx(_sTx  *dataTx, _eCmd ID, uint8_t frameLength){
     4a0:	fc 01       	movw	r30, r24
	dataTx->chk = 0;
     4a2:	15 82       	std	Z+5, r1	; 0x05
	dataTx->buff[dataTx->indexW++]='U';
     4a4:	a0 81       	ld	r26, Z
     4a6:	b1 81       	ldd	r27, Z+1	; 0x01
     4a8:	83 81       	ldd	r24, Z+3	; 0x03
     4aa:	91 e0       	ldi	r25, 0x01	; 1
     4ac:	98 0f       	add	r25, r24
     4ae:	93 83       	std	Z+3, r25	; 0x03
     4b0:	a8 0f       	add	r26, r24
     4b2:	b1 1d       	adc	r27, r1
     4b4:	85 e5       	ldi	r24, 0x55	; 85
     4b6:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4b8:	84 81       	ldd	r24, Z+4	; 0x04
     4ba:	93 81       	ldd	r25, Z+3	; 0x03
     4bc:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='N';
     4be:	a0 81       	ld	r26, Z
     4c0:	b1 81       	ldd	r27, Z+1	; 0x01
     4c2:	81 e0       	ldi	r24, 0x01	; 1
     4c4:	89 0f       	add	r24, r25
     4c6:	83 83       	std	Z+3, r24	; 0x03
     4c8:	a9 0f       	add	r26, r25
     4ca:	b1 1d       	adc	r27, r1
     4cc:	8e e4       	ldi	r24, 0x4E	; 78
     4ce:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4d0:	84 81       	ldd	r24, Z+4	; 0x04
     4d2:	93 81       	ldd	r25, Z+3	; 0x03
     4d4:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='E';
     4d6:	a0 81       	ld	r26, Z
     4d8:	b1 81       	ldd	r27, Z+1	; 0x01
     4da:	81 e0       	ldi	r24, 0x01	; 1
     4dc:	89 0f       	add	r24, r25
     4de:	83 83       	std	Z+3, r24	; 0x03
     4e0:	a9 0f       	add	r26, r25
     4e2:	b1 1d       	adc	r27, r1
     4e4:	85 e4       	ldi	r24, 0x45	; 69
     4e6:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4e8:	84 81       	ldd	r24, Z+4	; 0x04
     4ea:	93 81       	ldd	r25, Z+3	; 0x03
     4ec:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='R';
     4ee:	a0 81       	ld	r26, Z
     4f0:	b1 81       	ldd	r27, Z+1	; 0x01
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	89 0f       	add	r24, r25
     4f6:	83 83       	std	Z+3, r24	; 0x03
     4f8:	a9 0f       	add	r26, r25
     4fa:	b1 1d       	adc	r27, r1
     4fc:	82 e5       	ldi	r24, 0x52	; 82
     4fe:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     500:	84 81       	ldd	r24, Z+4	; 0x04
     502:	93 81       	ldd	r25, Z+3	; 0x03
     504:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=frameLength+1;
     506:	a0 81       	ld	r26, Z
     508:	b1 81       	ldd	r27, Z+1	; 0x01
     50a:	81 e0       	ldi	r24, 0x01	; 1
     50c:	89 0f       	add	r24, r25
     50e:	83 83       	std	Z+3, r24	; 0x03
     510:	a9 0f       	add	r26, r25
     512:	b1 1d       	adc	r27, r1
     514:	4f 5f       	subi	r20, 0xFF	; 255
     516:	4c 93       	st	X, r20
	dataTx->indexW &= dataTx->mask;
     518:	84 81       	ldd	r24, Z+4	; 0x04
     51a:	93 81       	ldd	r25, Z+3	; 0x03
     51c:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=':';
     51e:	a0 81       	ld	r26, Z
     520:	b1 81       	ldd	r27, Z+1	; 0x01
     522:	81 e0       	ldi	r24, 0x01	; 1
     524:	89 0f       	add	r24, r25
     526:	83 83       	std	Z+3, r24	; 0x03
     528:	a9 0f       	add	r26, r25
     52a:	b1 1d       	adc	r27, r1
     52c:	8a e3       	ldi	r24, 0x3A	; 58
     52e:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     530:	84 81       	ldd	r24, Z+4	; 0x04
     532:	93 81       	ldd	r25, Z+3	; 0x03
     534:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=ID;
     536:	a0 81       	ld	r26, Z
     538:	b1 81       	ldd	r27, Z+1	; 0x01
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	89 0f       	add	r24, r25
     53e:	83 83       	std	Z+3, r24	; 0x03
     540:	a9 0f       	add	r26, r25
     542:	b1 1d       	adc	r27, r1
     544:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     546:	94 81       	ldd	r25, Z+4	; 0x04
     548:	83 81       	ldd	r24, Z+3	; 0x03
     54a:	98 23       	and	r25, r24
     54c:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= (frameLength+1);
     54e:	95 81       	ldd	r25, Z+5	; 0x05
     550:	49 27       	eor	r20, r25
	dataTx->chk ^= ('U' ^'N' ^'E' ^'R' ^ID ^':') ;
     552:	64 27       	eor	r22, r20
     554:	86 e3       	ldi	r24, 0x36	; 54
     556:	86 27       	eor	r24, r22
     558:	85 83       	std	Z+5, r24	; 0x05
	return  dataTx->chk;
}
     55a:	08 95       	ret

0000055c <putByteOnTx>:
uint8_t putByteOnTx(_sTx *dataTx, uint8_t byte)
{
     55c:	fc 01       	movw	r30, r24
	dataTx->buff[dataTx->indexW++]=byte;
     55e:	a0 81       	ld	r26, Z
     560:	b1 81       	ldd	r27, Z+1	; 0x01
     562:	83 81       	ldd	r24, Z+3	; 0x03
     564:	91 e0       	ldi	r25, 0x01	; 1
     566:	98 0f       	add	r25, r24
     568:	93 83       	std	Z+3, r25	; 0x03
     56a:	a8 0f       	add	r26, r24
     56c:	b1 1d       	adc	r27, r1
     56e:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     570:	94 81       	ldd	r25, Z+4	; 0x04
     572:	83 81       	ldd	r24, Z+3	; 0x03
     574:	98 23       	and	r25, r24
     576:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= byte;
     578:	85 81       	ldd	r24, Z+5	; 0x05
     57a:	86 27       	eor	r24, r22
     57c:	85 83       	std	Z+5, r24	; 0x05
	return dataTx->chk;
}
     57e:	08 95       	ret

00000580 <decodeCommand>:
void decodeCommand(_sRx *dataRx, _sTx *dataTx){
     580:	0f 93       	push	r16
     582:	1f 93       	push	r17
     584:	cf 93       	push	r28
     586:	df 93       	push	r29
     588:	eb 01       	movw	r28, r22
	switch(dataRx->buff[dataRx->indexData]){
     58a:	dc 01       	movw	r26, r24
     58c:	ed 91       	ld	r30, X+
     58e:	fc 91       	ld	r31, X
     590:	11 97       	sbiw	r26, 0x01	; 1
     592:	14 96       	adiw	r26, 0x04	; 4
     594:	8c 91       	ld	r24, X
     596:	e8 0f       	add	r30, r24
     598:	f1 1d       	adc	r31, r1
     59a:	60 81       	ld	r22, Z
     59c:	68 3a       	cpi	r22, 0xA8	; 168
     59e:	70 f4       	brcc	.+28     	; 0x5bc <decodeCommand+0x3c>
     5a0:	64 3a       	cpi	r22, 0xA4	; 164
     5a2:	08 f0       	brcs	.+2      	; 0x5a6 <decodeCommand+0x26>
     5a4:	84 c0       	rjmp	.+264    	; 0x6ae <decodeCommand+0x12e>
     5a6:	63 3a       	cpi	r22, 0xA3	; 163
     5a8:	e0 f5       	brcc	.+120    	; 0x622 <decodeCommand+0xa2>
     5aa:	60 3a       	cpi	r22, 0xA0	; 160
     5ac:	08 f0       	brcs	.+2      	; 0x5b0 <decodeCommand+0x30>
     5ae:	7f c0       	rjmp	.+254    	; 0x6ae <decodeCommand+0x12e>
     5b0:	60 31       	cpi	r22, 0x10	; 16
     5b2:	01 f1       	breq	.+64     	; 0x5f4 <decodeCommand+0x74>
     5b4:	62 31       	cpi	r22, 0x12	; 18
     5b6:	09 f0       	breq	.+2      	; 0x5ba <decodeCommand+0x3a>
     5b8:	6e c0       	rjmp	.+220    	; 0x696 <decodeCommand+0x116>
     5ba:	79 c0       	rjmp	.+242    	; 0x6ae <decodeCommand+0x12e>
     5bc:	6e 3d       	cpi	r22, 0xDE	; 222
     5be:	09 f4       	brne	.+2      	; 0x5c2 <decodeCommand+0x42>
     5c0:	76 c0       	rjmp	.+236    	; 0x6ae <decodeCommand+0x12e>
     5c2:	20 f4       	brcc	.+8      	; 0x5cc <decodeCommand+0x4c>
     5c4:	6a 3a       	cpi	r22, 0xAA	; 170
     5c6:	09 f4       	brne	.+2      	; 0x5ca <decodeCommand+0x4a>
     5c8:	43 c0       	rjmp	.+134    	; 0x650 <decodeCommand+0xd0>
     5ca:	65 c0       	rjmp	.+202    	; 0x696 <decodeCommand+0x116>
     5cc:	60 3f       	cpi	r22, 0xF0	; 240
     5ce:	21 f0       	breq	.+8      	; 0x5d8 <decodeCommand+0x58>
     5d0:	61 3f       	cpi	r22, 0xF1	; 241
     5d2:	09 f0       	breq	.+2      	; 0x5d6 <decodeCommand+0x56>
     5d4:	60 c0       	rjmp	.+192    	; 0x696 <decodeCommand+0x116>
     5d6:	6b c0       	rjmp	.+214    	; 0x6ae <decodeCommand+0x12e>
		case ALIVE:
		putHeaderOnTx(dataTx, ALIVE, 2);
     5d8:	42 e0       	ldi	r20, 0x02	; 2
     5da:	60 ef       	ldi	r22, 0xF0	; 240
     5dc:	ce 01       	movw	r24, r28
     5de:	0e 94 50 02 	call	0x4a0	; 0x4a0 <putHeaderOnTx>
		putByteOnTx(dataTx, ACK );
     5e2:	6d e0       	ldi	r22, 0x0D	; 13
     5e4:	ce 01       	movw	r24, r28
     5e6:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		putByteOnTx(dataTx, dataTx->chk);
     5ea:	6d 81       	ldd	r22, Y+5	; 0x05
     5ec:	ce 01       	movw	r24, r28
     5ee:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		break;
     5f2:	5d c0       	rjmp	.+186    	; 0x6ae <decodeCommand+0x12e>
		case FIRMWARE:
		break;
		case LEDSTATUS:
		putHeaderOnTx(dataTx, LEDSTATUS, 3);
     5f4:	43 e0       	ldi	r20, 0x03	; 3
     5f6:	60 e1       	ldi	r22, 0x10	; 16
     5f8:	ce 01       	movw	r24, r28
     5fa:	0e 94 50 02 	call	0x4a0	; 0x4a0 <putHeaderOnTx>
		putByteOnTx(dataTx, myWord.ui8[0] );
     5fe:	0b e4       	ldi	r16, 0x4B	; 75
     600:	12 e0       	ldi	r17, 0x02	; 2
     602:	f8 01       	movw	r30, r16
     604:	60 81       	ld	r22, Z
     606:	ce 01       	movw	r24, r28
     608:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		putByteOnTx(dataTx, myWord.ui8[1] );
     60c:	d8 01       	movw	r26, r16
     60e:	11 96       	adiw	r26, 0x01	; 1
     610:	6c 91       	ld	r22, X
     612:	ce 01       	movw	r24, r28
     614:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		putByteOnTx(dataTx, dataTx->chk);
     618:	6d 81       	ldd	r22, Y+5	; 0x05
     61a:	ce 01       	movw	r24, r28
     61c:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		break;
     620:	46 c0       	rjmp	.+140    	; 0x6ae <decodeCommand+0x12e>
		break;
		case CONFIGSERVO:
		break;
		case GETDISTANCE:
		//myWord.ui16[0]	= timehc.distance;
			putHeaderOnTx(dataTx, GETDISTANCE, 3);
     622:	43 e0       	ldi	r20, 0x03	; 3
     624:	63 ea       	ldi	r22, 0xA3	; 163
     626:	ce 01       	movw	r24, r28
     628:	0e 94 50 02 	call	0x4a0	; 0x4a0 <putHeaderOnTx>
			putByteOnTx(dataTx, myWord.ui8[0]);
     62c:	0b e4       	ldi	r16, 0x4B	; 75
     62e:	12 e0       	ldi	r17, 0x02	; 2
     630:	f8 01       	movw	r30, r16
     632:	60 81       	ld	r22, Z
     634:	ce 01       	movw	r24, r28
     636:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     63a:	d8 01       	movw	r26, r16
     63c:	11 96       	adiw	r26, 0x01	; 1
     63e:	6c 91       	ld	r22, X
     640:	ce 01       	movw	r24, r28
     642:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     646:	6d 81       	ldd	r22, Y+5	; 0x05
     648:	ce 01       	movw	r24, r28
     64a:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		break;
     64e:	2f c0       	rjmp	.+94     	; 0x6ae <decodeCommand+0x12e>
		case GETSPEED:
		break;
		case STARTSTOP:
		break;
		case NEWBOX:
			myWord.ui16[0]=Cajita[Numbox].boxSize;
     650:	e0 91 27 01 	lds	r30, 0x0127	; 0x800127 <Numbox>
     654:	f0 91 28 01 	lds	r31, 0x0128	; 0x800128 <Numbox+0x1>
     658:	ee 0f       	add	r30, r30
     65a:	ff 1f       	adc	r31, r31
     65c:	e1 5a       	subi	r30, 0xA1	; 161
     65e:	fc 4f       	sbci	r31, 0xFC	; 252
     660:	80 81       	ld	r24, Z
     662:	0b e4       	ldi	r16, 0x4B	; 75
     664:	12 e0       	ldi	r17, 0x02	; 2
     666:	90 e0       	ldi	r25, 0x00	; 0
     668:	f8 01       	movw	r30, r16
     66a:	91 83       	std	Z+1, r25	; 0x01
     66c:	80 83       	st	Z, r24
			putHeaderOnTx(dataTx, NEWBOX, 3);
     66e:	43 e0       	ldi	r20, 0x03	; 3
     670:	6a ea       	ldi	r22, 0xAA	; 170
     672:	ce 01       	movw	r24, r28
     674:	0e 94 50 02 	call	0x4a0	; 0x4a0 <putHeaderOnTx>
			putByteOnTx(dataTx, myWord.ui8[0]);
     678:	d8 01       	movw	r26, r16
     67a:	6c 91       	ld	r22, X
     67c:	ce 01       	movw	r24, r28
     67e:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     682:	f8 01       	movw	r30, r16
     684:	61 81       	ldd	r22, Z+1	; 0x01
     686:	ce 01       	movw	r24, r28
     688:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     68c:	6d 81       	ldd	r22, Y+5	; 0x05
     68e:	ce 01       	movw	r24, r28
     690:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		break;
     694:	0c c0       	rjmp	.+24     	; 0x6ae <decodeCommand+0x12e>

		default:
		putHeaderOnTx(dataTx, (_eCmd)dataRx->buff[dataRx->indexData], 2);
     696:	42 e0       	ldi	r20, 0x02	; 2
     698:	ce 01       	movw	r24, r28
     69a:	0e 94 50 02 	call	0x4a0	; 0x4a0 <putHeaderOnTx>
		putByteOnTx(dataTx,UNKNOWN );
     69e:	6f ef       	ldi	r22, 0xFF	; 255
     6a0:	ce 01       	movw	r24, r28
     6a2:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		putByteOnTx(dataTx, dataTx->chk);
     6a6:	6d 81       	ldd	r22, Y+5	; 0x05
     6a8:	ce 01       	movw	r24, r28
     6aa:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		break;
		
	}
}
     6ae:	df 91       	pop	r29
     6b0:	cf 91       	pop	r28
     6b2:	1f 91       	pop	r17
     6b4:	0f 91       	pop	r16
     6b6:	08 95       	ret

000006b8 <decodeHeader>:
void decodeHeader(_sRx *dataRx){
     6b8:	dc 01       	movw	r26, r24
	uint8_t auxIndex=dataRx->indexW;
     6ba:	13 96       	adiw	r26, 0x03	; 3
     6bc:	2c 91       	ld	r18, X
     6be:	13 97       	sbiw	r26, 0x03	; 3
	while(dataRx->indexR != auxIndex){
     6c0:	c9 c0       	rjmp	.+402    	; 0x854 <__DATA_REGION_LENGTH__+0x54>
		switch(dataRx->header)
     6c2:	18 96       	adiw	r26, 0x08	; 8
     6c4:	ec 91       	ld	r30, X
     6c6:	18 97       	sbiw	r26, 0x08	; 8
     6c8:	4e 2f       	mov	r20, r30
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	47 30       	cpi	r20, 0x07	; 7
     6ce:	51 05       	cpc	r21, r1
     6d0:	08 f0       	brcs	.+2      	; 0x6d4 <decodeHeader+0x1c>
     6d2:	b2 c0       	rjmp	.+356    	; 0x838 <__DATA_REGION_LENGTH__+0x38>
     6d4:	fa 01       	movw	r30, r20
     6d6:	ec 5c       	subi	r30, 0xCC	; 204
     6d8:	ff 4f       	sbci	r31, 0xFF	; 255
     6da:	0c 94 fe 06 	jmp	0xdfc	; 0xdfc <__tablejump2__>
		{
			case HEADER_U:
			if(dataRx->buff[dataRx->indexR] == 'U'){
     6de:	ed 91       	ld	r30, X+
     6e0:	fc 91       	ld	r31, X
     6e2:	11 97       	sbiw	r26, 0x01	; 1
     6e4:	e8 0f       	add	r30, r24
     6e6:	f1 1d       	adc	r31, r1
     6e8:	80 81       	ld	r24, Z
     6ea:	85 35       	cpi	r24, 0x55	; 85
     6ec:	09 f0       	breq	.+2      	; 0x6f0 <decodeHeader+0x38>
     6ee:	a7 c0       	rjmp	.+334    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
				dataRx->header = HEADER_N;
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	18 96       	adiw	r26, 0x08	; 8
     6f4:	8c 93       	st	X, r24
     6f6:	18 97       	sbiw	r26, 0x08	; 8
     6f8:	a2 c0       	rjmp	.+324    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
			}
			break;
			case HEADER_N:
			if(dataRx->buff[dataRx->indexR] == 'N'){
     6fa:	ed 91       	ld	r30, X+
     6fc:	fc 91       	ld	r31, X
     6fe:	11 97       	sbiw	r26, 0x01	; 1
     700:	e8 0f       	add	r30, r24
     702:	f1 1d       	adc	r31, r1
     704:	90 81       	ld	r25, Z
     706:	9e 34       	cpi	r25, 0x4E	; 78
     708:	29 f4       	brne	.+10     	; 0x714 <decodeHeader+0x5c>
				dataRx->header = HEADER_E;
     70a:	82 e0       	ldi	r24, 0x02	; 2
     70c:	18 96       	adiw	r26, 0x08	; 8
     70e:	8c 93       	st	X, r24
     710:	18 97       	sbiw	r26, 0x08	; 8
     712:	95 c0       	rjmp	.+298    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
				}else{
				if(dataRx->buff[dataRx->indexR] != 'U'){
     714:	95 35       	cpi	r25, 0x55	; 85
     716:	09 f4       	brne	.+2      	; 0x71a <decodeHeader+0x62>
     718:	92 c0       	rjmp	.+292    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
					dataRx->header = HEADER_U;
     71a:	18 96       	adiw	r26, 0x08	; 8
     71c:	1c 92       	st	X, r1
     71e:	18 97       	sbiw	r26, 0x08	; 8
					dataRx->indexR--;
     720:	81 50       	subi	r24, 0x01	; 1
     722:	12 96       	adiw	r26, 0x02	; 2
     724:	8c 93       	st	X, r24
     726:	12 97       	sbiw	r26, 0x02	; 2
     728:	8a c0       	rjmp	.+276    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
				}
			}
			break;
			case HEADER_E:
			if(dataRx->buff[dataRx->indexR] == 'E'){
     72a:	ed 91       	ld	r30, X+
     72c:	fc 91       	ld	r31, X
     72e:	11 97       	sbiw	r26, 0x01	; 1
     730:	e8 0f       	add	r30, r24
     732:	f1 1d       	adc	r31, r1
     734:	90 81       	ld	r25, Z
     736:	95 34       	cpi	r25, 0x45	; 69
     738:	29 f4       	brne	.+10     	; 0x744 <decodeHeader+0x8c>
				dataRx->header = HEADER_R;
     73a:	83 e0       	ldi	r24, 0x03	; 3
     73c:	18 96       	adiw	r26, 0x08	; 8
     73e:	8c 93       	st	X, r24
     740:	18 97       	sbiw	r26, 0x08	; 8
     742:	7d c0       	rjmp	.+250    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
				}else{
				dataRx->header = HEADER_U;
     744:	18 96       	adiw	r26, 0x08	; 8
     746:	1c 92       	st	X, r1
     748:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     74a:	81 50       	subi	r24, 0x01	; 1
     74c:	12 96       	adiw	r26, 0x02	; 2
     74e:	8c 93       	st	X, r24
     750:	12 97       	sbiw	r26, 0x02	; 2
     752:	75 c0       	rjmp	.+234    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
			}
			break;
			case HEADER_R:
			if(dataRx->buff[dataRx->indexR] == 'R'){
     754:	ed 91       	ld	r30, X+
     756:	fc 91       	ld	r31, X
     758:	11 97       	sbiw	r26, 0x01	; 1
     75a:	e8 0f       	add	r30, r24
     75c:	f1 1d       	adc	r31, r1
     75e:	90 81       	ld	r25, Z
     760:	92 35       	cpi	r25, 0x52	; 82
     762:	29 f4       	brne	.+10     	; 0x76e <decodeHeader+0xb6>
				dataRx->header = NBYTES;
     764:	84 e0       	ldi	r24, 0x04	; 4
     766:	18 96       	adiw	r26, 0x08	; 8
     768:	8c 93       	st	X, r24
     76a:	18 97       	sbiw	r26, 0x08	; 8
     76c:	68 c0       	rjmp	.+208    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
				}else{
				dataRx->header = HEADER_U;
     76e:	18 96       	adiw	r26, 0x08	; 8
     770:	1c 92       	st	X, r1
     772:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     774:	81 50       	subi	r24, 0x01	; 1
     776:	12 96       	adiw	r26, 0x02	; 2
     778:	8c 93       	st	X, r24
     77a:	12 97       	sbiw	r26, 0x02	; 2
     77c:	60 c0       	rjmp	.+192    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
			}
			break;
			case NBYTES:
			dataRx->nBytes=dataRx->buff[dataRx->indexR];
     77e:	ed 91       	ld	r30, X+
     780:	fc 91       	ld	r31, X
     782:	11 97       	sbiw	r26, 0x01	; 1
     784:	e8 0f       	add	r30, r24
     786:	f1 1d       	adc	r31, r1
     788:	80 81       	ld	r24, Z
     78a:	17 96       	adiw	r26, 0x07	; 7
     78c:	8c 93       	st	X, r24
     78e:	17 97       	sbiw	r26, 0x07	; 7
			dataRx->header = TOKEN;
     790:	85 e0       	ldi	r24, 0x05	; 5
     792:	18 96       	adiw	r26, 0x08	; 8
     794:	8c 93       	st	X, r24
     796:	18 97       	sbiw	r26, 0x08	; 8
			break;
     798:	52 c0       	rjmp	.+164    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
			case TOKEN:
			if(dataRx->buff[dataRx->indexR] == ':'){
     79a:	ed 91       	ld	r30, X+
     79c:	fc 91       	ld	r31, X
     79e:	11 97       	sbiw	r26, 0x01	; 1
     7a0:	e8 0f       	add	r30, r24
     7a2:	f1 1d       	adc	r31, r1
     7a4:	90 81       	ld	r25, Z
     7a6:	9a 33       	cpi	r25, 0x3A	; 58
     7a8:	a9 f4       	brne	.+42     	; 0x7d4 <decodeHeader+0x11c>
				dataRx->header = PAYLOAD;
     7aa:	96 e0       	ldi	r25, 0x06	; 6
     7ac:	18 96       	adiw	r26, 0x08	; 8
     7ae:	9c 93       	st	X, r25
     7b0:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexData = dataRx->indexR+1;
     7b2:	8f 5f       	subi	r24, 0xFF	; 255
				dataRx->indexData &= dataRx->mask;
     7b4:	15 96       	adiw	r26, 0x05	; 5
     7b6:	9c 91       	ld	r25, X
     7b8:	15 97       	sbiw	r26, 0x05	; 5
     7ba:	89 23       	and	r24, r25
     7bc:	14 96       	adiw	r26, 0x04	; 4
     7be:	8c 93       	st	X, r24
     7c0:	14 97       	sbiw	r26, 0x04	; 4
				dataRx->chk = 0;
				dataRx->chk ^= ('U' ^'N' ^'E' ^'R' ^dataRx->nBytes ^':') ;
     7c2:	17 96       	adiw	r26, 0x07	; 7
     7c4:	9c 91       	ld	r25, X
     7c6:	17 97       	sbiw	r26, 0x07	; 7
     7c8:	86 e3       	ldi	r24, 0x36	; 54
     7ca:	89 27       	eor	r24, r25
     7cc:	16 96       	adiw	r26, 0x06	; 6
     7ce:	8c 93       	st	X, r24
     7d0:	16 97       	sbiw	r26, 0x06	; 6
     7d2:	35 c0       	rjmp	.+106    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
				}else{
				dataRx->header = HEADER_U;
     7d4:	18 96       	adiw	r26, 0x08	; 8
     7d6:	1c 92       	st	X, r1
     7d8:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     7da:	81 50       	subi	r24, 0x01	; 1
     7dc:	12 96       	adiw	r26, 0x02	; 2
     7de:	8c 93       	st	X, r24
     7e0:	12 97       	sbiw	r26, 0x02	; 2
     7e2:	2d c0       	rjmp	.+90     	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
			}
			break;
			case PAYLOAD:
			dataRx->nBytes--;
     7e4:	17 96       	adiw	r26, 0x07	; 7
     7e6:	9c 91       	ld	r25, X
     7e8:	17 97       	sbiw	r26, 0x07	; 7
     7ea:	91 50       	subi	r25, 0x01	; 1
     7ec:	17 96       	adiw	r26, 0x07	; 7
     7ee:	9c 93       	st	X, r25
     7f0:	17 97       	sbiw	r26, 0x07	; 7
			if(dataRx->nBytes>0){
     7f2:	99 23       	and	r25, r25
     7f4:	71 f0       	breq	.+28     	; 0x812 <__DATA_REGION_LENGTH__+0x12>
				dataRx->chk ^= dataRx->buff[dataRx->indexR];
     7f6:	ed 91       	ld	r30, X+
     7f8:	fc 91       	ld	r31, X
     7fa:	11 97       	sbiw	r26, 0x01	; 1
     7fc:	e8 0f       	add	r30, r24
     7fe:	f1 1d       	adc	r31, r1
     800:	80 81       	ld	r24, Z
     802:	16 96       	adiw	r26, 0x06	; 6
     804:	9c 91       	ld	r25, X
     806:	16 97       	sbiw	r26, 0x06	; 6
     808:	89 27       	eor	r24, r25
     80a:	16 96       	adiw	r26, 0x06	; 6
     80c:	8c 93       	st	X, r24
     80e:	16 97       	sbiw	r26, 0x06	; 6
     810:	16 c0       	rjmp	.+44     	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
				}else{
				dataRx->header = HEADER_U;
     812:	18 96       	adiw	r26, 0x08	; 8
     814:	1c 92       	st	X, r1
     816:	18 97       	sbiw	r26, 0x08	; 8
				if(dataRx->buff[dataRx->indexR] == dataRx->chk)
     818:	ed 91       	ld	r30, X+
     81a:	fc 91       	ld	r31, X
     81c:	11 97       	sbiw	r26, 0x01	; 1
     81e:	e8 0f       	add	r30, r24
     820:	f1 1d       	adc	r31, r1
     822:	90 81       	ld	r25, Z
     824:	16 96       	adiw	r26, 0x06	; 6
     826:	8c 91       	ld	r24, X
     828:	16 97       	sbiw	r26, 0x06	; 6
     82a:	98 13       	cpse	r25, r24
     82c:	08 c0       	rjmp	.+16     	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
				dataRx->isComannd = TRUE;
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	1a 96       	adiw	r26, 0x0a	; 10
     832:	8c 93       	st	X, r24
     834:	1a 97       	sbiw	r26, 0x0a	; 10
     836:	03 c0       	rjmp	.+6      	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
			}
			break;
			default:
			dataRx->header = HEADER_U;
     838:	18 96       	adiw	r26, 0x08	; 8
     83a:	1c 92       	st	X, r1
     83c:	18 97       	sbiw	r26, 0x08	; 8
			break;
		}
		dataRx->indexR++;
     83e:	12 96       	adiw	r26, 0x02	; 2
     840:	8c 91       	ld	r24, X
     842:	12 97       	sbiw	r26, 0x02	; 2
     844:	8f 5f       	subi	r24, 0xFF	; 255
		dataRx->indexR &= dataRx->mask;
     846:	15 96       	adiw	r26, 0x05	; 5
     848:	9c 91       	ld	r25, X
     84a:	15 97       	sbiw	r26, 0x05	; 5
     84c:	89 23       	and	r24, r25
     84e:	12 96       	adiw	r26, 0x02	; 2
     850:	8c 93       	st	X, r24
     852:	12 97       	sbiw	r26, 0x02	; 2
		
	}
}
void decodeHeader(_sRx *dataRx){
	uint8_t auxIndex=dataRx->indexW;
	while(dataRx->indexR != auxIndex){
     854:	12 96       	adiw	r26, 0x02	; 2
     856:	8c 91       	ld	r24, X
     858:	12 97       	sbiw	r26, 0x02	; 2
     85a:	28 13       	cpse	r18, r24
     85c:	32 cf       	rjmp	.-412    	; 0x6c2 <decodeHeader+0xa>
			break;
		}
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}
     85e:	08 95       	ret

00000860 <serialTask>:

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}

void serialTask(_sRx* dataRx, _sTx* dataTx){
     860:	0f 93       	push	r16
     862:	1f 93       	push	r17
     864:	cf 93       	push	r28
     866:	df 93       	push	r29
     868:	8c 01       	movw	r16, r24
     86a:	eb 01       	movw	r28, r22
	if(dataRx->isComannd){
     86c:	fc 01       	movw	r30, r24
     86e:	82 85       	ldd	r24, Z+10	; 0x0a
     870:	88 23       	and	r24, r24
     872:	21 f0       	breq	.+8      	; 0x87c <serialTask+0x1c>
		dataRx->isComannd=FALSE;
     874:	12 86       	std	Z+10, r1	; 0x0a
		decodeCommand(dataRx,dataTx);
     876:	c8 01       	movw	r24, r16
     878:	0e 94 c0 02 	call	0x580	; 0x580 <decodeCommand>
	}
	if(dataRx->indexR!=dataRx->indexW){
     87c:	f8 01       	movw	r30, r16
     87e:	92 81       	ldd	r25, Z+2	; 0x02
     880:	83 81       	ldd	r24, Z+3	; 0x03
     882:	98 17       	cp	r25, r24
     884:	19 f0       	breq	.+6      	; 0x88c <serialTask+0x2c>
		
		decodeHeader(dataRx);
     886:	c8 01       	movw	r24, r16
     888:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <decodeHeader>
	}
	if (dataTx->indexR!= dataTx->indexW) {
     88c:	8a 81       	ldd	r24, Y+2	; 0x02
     88e:	9b 81       	ldd	r25, Y+3	; 0x03
     890:	89 17       	cp	r24, r25
     892:	91 f0       	breq	.+36     	; 0x8b8 <serialTask+0x58>
		if (UCSR0A & (1 << UDRE0)) { // Si el buffer de transmisión está vacío
     894:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     898:	95 ff       	sbrs	r25, 5
     89a:	0e c0       	rjmp	.+28     	; 0x8b8 <serialTask+0x58>
			UDR0 = dataTx->buff[dataTx->indexR++]; // Enviar el dato
     89c:	e8 81       	ld	r30, Y
     89e:	f9 81       	ldd	r31, Y+1	; 0x01
     8a0:	91 e0       	ldi	r25, 0x01	; 1
     8a2:	98 0f       	add	r25, r24
     8a4:	9a 83       	std	Y+2, r25	; 0x02
     8a6:	e8 0f       	add	r30, r24
     8a8:	f1 1d       	adc	r31, r1
     8aa:	80 81       	ld	r24, Z
     8ac:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
			dataTx->indexR &= dataTx->mask;
     8b0:	8c 81       	ldd	r24, Y+4	; 0x04
     8b2:	9a 81       	ldd	r25, Y+2	; 0x02
     8b4:	89 23       	and	r24, r25
     8b6:	8a 83       	std	Y+2, r24	; 0x02
		}
	}
}
     8b8:	df 91       	pop	r29
     8ba:	cf 91       	pop	r28
     8bc:	1f 91       	pop	r17
     8be:	0f 91       	pop	r16
     8c0:	08 95       	ret

000008c2 <sensorMeasure>:
	count100ms--;
	count40ms--;
}

void sensorMeasure(uint16_t distance){
	globalDistance=distance;
     8c2:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <globalDistance+0x1>
     8c6:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <globalDistance>
     8ca:	08 95       	ret

000008cc <addBox>:
}

void addBox(uint16_t distance){
	
	//dar margen por ej a la caja de 6cm , decir que es veradero cuando sean enrtre 5 y 8cm
	if (distance>boxSizeconfig.smallboxC && distance<boxSizeconfig.smallboxF){ //caja chica
     8cc:	20 91 2b 02 	lds	r18, 0x022B	; 0x80022b <boxSizeconfig+0x2>
     8d0:	30 91 2c 02 	lds	r19, 0x022C	; 0x80022c <boxSizeconfig+0x3>
     8d4:	28 17       	cp	r18, r24
     8d6:	39 07       	cpc	r19, r25
     8d8:	b0 f4       	brcc	.+44     	; 0x906 <__stack+0x7>
     8da:	20 91 29 02 	lds	r18, 0x0229	; 0x800229 <boxSizeconfig>
     8de:	30 91 2a 02 	lds	r19, 0x022A	; 0x80022a <boxSizeconfig+0x1>
     8e2:	82 17       	cp	r24, r18
     8e4:	93 07       	cpc	r25, r19
     8e6:	78 f4       	brcc	.+30     	; 0x906 <__stack+0x7>
		Cajita[Numbox].boxState=isOn;
     8e8:	e0 91 27 01 	lds	r30, 0x0127	; 0x800127 <Numbox>
     8ec:	f0 91 28 01 	lds	r31, 0x0128	; 0x800128 <Numbox+0x1>
     8f0:	ee 0f       	add	r30, r30
     8f2:	ff 1f       	adc	r31, r31
     8f4:	e1 5a       	subi	r30, 0xA1	; 161
     8f6:	fc 4f       	sbci	r31, 0xFC	; 252
     8f8:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=SmallBox;
     8fa:	21 e0       	ldi	r18, 0x01	; 1
     8fc:	20 83       	st	Z, r18
		PORTB ^= (1<<LED_1);
     8fe:	35 b1       	in	r19, 0x05	; 5
     900:	24 e0       	ldi	r18, 0x04	; 4
     902:	23 27       	eor	r18, r19
     904:	25 b9       	out	0x05, r18	; 5
	}
	if (distance>boxSizeconfig.mediumboxC && distance<boxSizeconfig.mediumboxF){ //caja mediana
     906:	20 91 2f 02 	lds	r18, 0x022F	; 0x80022f <boxSizeconfig+0x6>
     90a:	30 91 30 02 	lds	r19, 0x0230	; 0x800230 <boxSizeconfig+0x7>
     90e:	28 17       	cp	r18, r24
     910:	39 07       	cpc	r19, r25
     912:	b0 f4       	brcc	.+44     	; 0x940 <__stack+0x41>
     914:	20 91 2d 02 	lds	r18, 0x022D	; 0x80022d <boxSizeconfig+0x4>
     918:	30 91 2e 02 	lds	r19, 0x022E	; 0x80022e <boxSizeconfig+0x5>
     91c:	82 17       	cp	r24, r18
     91e:	93 07       	cpc	r25, r19
     920:	78 f4       	brcc	.+30     	; 0x940 <__stack+0x41>
		Cajita[Numbox].boxState=isOn;
     922:	e0 91 27 01 	lds	r30, 0x0127	; 0x800127 <Numbox>
     926:	f0 91 28 01 	lds	r31, 0x0128	; 0x800128 <Numbox+0x1>
     92a:	ee 0f       	add	r30, r30
     92c:	ff 1f       	adc	r31, r31
     92e:	e1 5a       	subi	r30, 0xA1	; 161
     930:	fc 4f       	sbci	r31, 0xFC	; 252
     932:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=MediumBox;
     934:	22 e0       	ldi	r18, 0x02	; 2
     936:	20 83       	st	Z, r18
		PORTB ^= (1<<LED_BI);
     938:	35 b1       	in	r19, 0x05	; 5
     93a:	20 e2       	ldi	r18, 0x20	; 32
     93c:	23 27       	eor	r18, r19
     93e:	25 b9       	out	0x05, r18	; 5
	}
	
	if (distance>boxSizeconfig.largeboxC && distance<boxSizeconfig.largeboxF){ //caja grande
     940:	20 91 33 02 	lds	r18, 0x0233	; 0x800233 <boxSizeconfig+0xa>
     944:	30 91 34 02 	lds	r19, 0x0234	; 0x800234 <boxSizeconfig+0xb>
     948:	28 17       	cp	r18, r24
     94a:	39 07       	cpc	r19, r25
     94c:	b8 f4       	brcc	.+46     	; 0x97c <__stack+0x7d>
     94e:	20 91 31 02 	lds	r18, 0x0231	; 0x800231 <boxSizeconfig+0x8>
     952:	30 91 32 02 	lds	r19, 0x0232	; 0x800232 <boxSizeconfig+0x9>
     956:	82 17       	cp	r24, r18
     958:	93 07       	cpc	r25, r19
     95a:	80 f4       	brcc	.+32     	; 0x97c <__stack+0x7d>
		Cajita[Numbox].boxState=isOn;
     95c:	e0 91 27 01 	lds	r30, 0x0127	; 0x800127 <Numbox>
     960:	f0 91 28 01 	lds	r31, 0x0128	; 0x800128 <Numbox+0x1>
     964:	ee 0f       	add	r30, r30
     966:	ff 1f       	adc	r31, r31
     968:	e1 5a       	subi	r30, 0xA1	; 161
     96a:	fc 4f       	sbci	r31, 0xFC	; 252
     96c:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=LargeBox;
     96e:	83 e0       	ldi	r24, 0x03	; 3
     970:	80 83       	st	Z, r24
		PORTB ^= (1<<LED_2);
     972:	95 b1       	in	r25, 0x05	; 5
     974:	80 e4       	ldi	r24, 0x40	; 64
     976:	89 27       	eor	r24, r25
     978:	85 b9       	out	0x05, r24	; 5
     97a:	03 c0       	rjmp	.+6      	; 0x982 <__stack+0x83>
	}else
		Cajita->boxSize=NotSelected;
     97c:	84 e0       	ldi	r24, 0x04	; 4
     97e:	80 93 5f 03 	sts	0x035F, r24	; 0x80035f <Cajita>
	
	Numbox++;
     982:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <Numbox>
     986:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <Numbox+0x1>
     98a:	01 96       	adiw	r24, 0x01	; 1
     98c:	90 93 28 01 	sts	0x0128, r25	; 0x800128 <Numbox+0x1>
     990:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <Numbox>
	
	if(Numbox>=bufferBox) //reinicio el buffer
     994:	0f 97       	sbiw	r24, 0x0f	; 15
     996:	20 f0       	brcs	.+8      	; 0x9a0 <__stack+0xa1>
		Numbox=0;
     998:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <Numbox+0x1>
     99c:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <Numbox>
		
	//si el ir deja de detectar pongo el measuring box en false para reiniciar la medicion
	if(IR_GetState(&ir_sensor[0]) == 1)
     9a0:	8f e4       	ldi	r24, 0x4F	; 79
     9a2:	92 e0       	ldi	r25, 0x02	; 2
     9a4:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     9a8:	81 30       	cpi	r24, 0x01	; 1
     9aa:	29 f4       	brne	.+10     	; 0x9b6 <__stack+0xb7>
		MEASURINGBOX=FALSE;
     9ac:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <flag0>
     9b0:	8d 7f       	andi	r24, 0xFD	; 253
     9b2:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <flag0>
     9b6:	08 95       	ret

000009b8 <newBox>:
	
	
}

void newBox(uint16_t distance){
     9b8:	cf 93       	push	r28
     9ba:	df 93       	push	r29
     9bc:	ec 01       	movw	r28, r24
	
	if((IR_GetState(&ir_sensor[0]) == 0x00) && !MEASURINGBOX){
     9be:	8f e4       	ldi	r24, 0x4F	; 79
     9c0:	92 e0       	ldi	r25, 0x02	; 2
     9c2:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     9c6:	81 11       	cpse	r24, r1
     9c8:	14 c0       	rjmp	.+40     	; 0x9f2 <newBox+0x3a>
     9ca:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <flag0>
     9ce:	81 fd       	sbrc	r24, 1
     9d0:	10 c0       	rjmp	.+32     	; 0x9f2 <newBox+0x3a>
		if(distance<Cm18){
     9d2:	cc 34       	cpi	r28, 0x4C	; 76
     9d4:	84 e0       	ldi	r24, 0x04	; 4
     9d6:	d8 07       	cpc	r29, r24
     9d8:	60 f4       	brcc	.+24     	; 0x9f2 <newBox+0x3a>
			MEASURINGBOX=TRUE;
     9da:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <flag0>
     9de:	82 60       	ori	r24, 0x02	; 2
     9e0:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <flag0>
			addBox(distance);
     9e4:	ce 01       	movw	r24, r28
     9e6:	0e 94 66 04 	call	0x8cc	; 0x8cc <addBox>
			PORTB ^=(1<<LED_BI);
     9ea:	95 b1       	in	r25, 0x05	; 5
     9ec:	80 e2       	ldi	r24, 0x20	; 32
     9ee:	89 27       	eor	r24, r25
     9f0:	85 b9       	out	0x05, r24	; 5
		}
	}
}
     9f2:	df 91       	pop	r29
     9f4:	cf 91       	pop	r28
     9f6:	08 95       	ret

000009f8 <kickBox>:

void kickBox(){
     9f8:	1f 93       	push	r17
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
	uint8_t needKick;
	static uint8_t read1=0;
	static uint8_t read2=0;
	static uint8_t read3=0;
	
	for(needKick=1;needKick<4;needKick++){
     9fe:	11 e0       	ldi	r17, 0x01	; 1
     a00:	76 c0       	rjmp	.+236    	; 0xaee <kickBox+0xf6>
		
		if (IR_GetState(&ir_sensor[needKick])==0){ //si esta negado esta en 1 , es decir hay caja 
     a02:	c1 2f       	mov	r28, r17
     a04:	d0 e0       	ldi	r29, 0x00	; 0
     a06:	ce 01       	movw	r24, r28
     a08:	88 0f       	add	r24, r24
     a0a:	99 1f       	adc	r25, r25
     a0c:	88 0f       	add	r24, r24
     a0e:	99 1f       	adc	r25, r25
     a10:	81 5b       	subi	r24, 0xB1	; 177
     a12:	9d 4f       	sbci	r25, 0xFD	; 253
     a14:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     a18:	81 11       	cpse	r24, r1
     a1a:	68 c0       	rjmp	.+208    	; 0xaec <kickBox+0xf4>
			if(ir_sensor[needKick].irType == Cajita[read1].boxSize){
     a1c:	fe 01       	movw	r30, r28
     a1e:	ee 0f       	add	r30, r30
     a20:	ff 1f       	adc	r31, r31
     a22:	ee 0f       	add	r30, r30
     a24:	ff 1f       	adc	r31, r31
     a26:	e1 5b       	subi	r30, 0xB1	; 177
     a28:	fd 4f       	sbci	r31, 0xFD	; 253
     a2a:	93 81       	ldd	r25, Z+3	; 0x03
     a2c:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <read1.2094>
     a30:	f0 e0       	ldi	r31, 0x00	; 0
     a32:	ee 0f       	add	r30, r30
     a34:	ff 1f       	adc	r31, r31
     a36:	e1 5a       	subi	r30, 0xA1	; 161
     a38:	fc 4f       	sbci	r31, 0xFC	; 252
     a3a:	80 81       	ld	r24, Z
     a3c:	98 13       	cpse	r25, r24
     a3e:	11 c0       	rjmp	.+34     	; 0xa62 <kickBox+0x6a>
				servo_Angle(0,90);
     a40:	6a e5       	ldi	r22, 0x5A	; 90
     a42:	80 e0       	ldi	r24, 0x00	; 0
     a44:	0e 94 73 06 	call	0xce6	; 0xce6 <servo_Angle>
				Cajita[read1].boxState=isOut;
     a48:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <read1.2094>
     a4c:	e8 2f       	mov	r30, r24
     a4e:	f0 e0       	ldi	r31, 0x00	; 0
     a50:	ee 0f       	add	r30, r30
     a52:	ff 1f       	adc	r31, r31
     a54:	e1 5a       	subi	r30, 0xA1	; 161
     a56:	fc 4f       	sbci	r31, 0xFC	; 252
     a58:	92 e0       	ldi	r25, 0x02	; 2
     a5a:	91 83       	std	Z+1, r25	; 0x01
				read1++;
     a5c:	8f 5f       	subi	r24, 0xFF	; 255
     a5e:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <read1.2094>
			}
			if(ir_sensor[needKick].irType == Cajita[read2].boxSize){
     a62:	fe 01       	movw	r30, r28
     a64:	ee 0f       	add	r30, r30
     a66:	ff 1f       	adc	r31, r31
     a68:	ee 0f       	add	r30, r30
     a6a:	ff 1f       	adc	r31, r31
     a6c:	e1 5b       	subi	r30, 0xB1	; 177
     a6e:	fd 4f       	sbci	r31, 0xFD	; 253
     a70:	93 81       	ldd	r25, Z+3	; 0x03
     a72:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <read2.2095>
     a76:	f0 e0       	ldi	r31, 0x00	; 0
     a78:	ee 0f       	add	r30, r30
     a7a:	ff 1f       	adc	r31, r31
     a7c:	e1 5a       	subi	r30, 0xA1	; 161
     a7e:	fc 4f       	sbci	r31, 0xFC	; 252
     a80:	80 81       	ld	r24, Z
     a82:	98 13       	cpse	r25, r24
     a84:	11 c0       	rjmp	.+34     	; 0xaa8 <kickBox+0xb0>
				servo_Angle(1,90);
     a86:	6a e5       	ldi	r22, 0x5A	; 90
     a88:	81 e0       	ldi	r24, 0x01	; 1
     a8a:	0e 94 73 06 	call	0xce6	; 0xce6 <servo_Angle>
				Cajita[read2].boxState=isOut;
     a8e:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <read2.2095>
     a92:	e8 2f       	mov	r30, r24
     a94:	f0 e0       	ldi	r31, 0x00	; 0
     a96:	ee 0f       	add	r30, r30
     a98:	ff 1f       	adc	r31, r31
     a9a:	e1 5a       	subi	r30, 0xA1	; 161
     a9c:	fc 4f       	sbci	r31, 0xFC	; 252
     a9e:	92 e0       	ldi	r25, 0x02	; 2
     aa0:	91 83       	std	Z+1, r25	; 0x01
				read2++;
     aa2:	8f 5f       	subi	r24, 0xFF	; 255
     aa4:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <read2.2095>
			}	
			if(ir_sensor[needKick].irType == Cajita[read1].boxSize){
     aa8:	cc 0f       	add	r28, r28
     aaa:	dd 1f       	adc	r29, r29
     aac:	cc 0f       	add	r28, r28
     aae:	dd 1f       	adc	r29, r29
     ab0:	c1 5b       	subi	r28, 0xB1	; 177
     ab2:	dd 4f       	sbci	r29, 0xFD	; 253
     ab4:	9b 81       	ldd	r25, Y+3	; 0x03
     ab6:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <read1.2094>
     aba:	f0 e0       	ldi	r31, 0x00	; 0
     abc:	ee 0f       	add	r30, r30
     abe:	ff 1f       	adc	r31, r31
     ac0:	e1 5a       	subi	r30, 0xA1	; 161
     ac2:	fc 4f       	sbci	r31, 0xFC	; 252
     ac4:	80 81       	ld	r24, Z
     ac6:	98 13       	cpse	r25, r24
     ac8:	11 c0       	rjmp	.+34     	; 0xaec <kickBox+0xf4>
				servo_Angle(2,90);
     aca:	6a e5       	ldi	r22, 0x5A	; 90
     acc:	82 e0       	ldi	r24, 0x02	; 2
     ace:	0e 94 73 06 	call	0xce6	; 0xce6 <servo_Angle>
				Cajita[read3].boxState=isOut;
     ad2:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <read3.2096>
     ad6:	e8 2f       	mov	r30, r24
     ad8:	f0 e0       	ldi	r31, 0x00	; 0
     ada:	ee 0f       	add	r30, r30
     adc:	ff 1f       	adc	r31, r31
     ade:	e1 5a       	subi	r30, 0xA1	; 161
     ae0:	fc 4f       	sbci	r31, 0xFC	; 252
     ae2:	92 e0       	ldi	r25, 0x02	; 2
     ae4:	91 83       	std	Z+1, r25	; 0x01
				read3++;
     ae6:	8f 5f       	subi	r24, 0xFF	; 255
     ae8:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <read3.2096>
	uint8_t needKick;
	static uint8_t read1=0;
	static uint8_t read2=0;
	static uint8_t read3=0;
	
	for(needKick=1;needKick<4;needKick++){
     aec:	1f 5f       	subi	r17, 0xFF	; 255
     aee:	14 30       	cpi	r17, 0x04	; 4
     af0:	08 f4       	brcc	.+2      	; 0xaf4 <kickBox+0xfc>
     af2:	87 cf       	rjmp	.-242    	; 0xa02 <kickBox+0xa>
				Cajita[read3].boxState=isOut;
				read3++;
			}
		}
	}
}
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	1f 91       	pop	r17
     afa:	08 95       	ret

00000afc <every10ms>:
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}

void every10ms(){
     afc:	cf 93       	push	r28
     afe:	df 93       	push	r29
	
	if (!count100ms){		//Si pasaron 100ms
     b00:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <count100ms>
     b04:	81 11       	cpse	r24, r1
     b06:	1b c0       	rjmp	.+54     	; 0xb3e <every10ms+0x42>

uint32_t	HCSR_1;
uint16_t	aux16 = 0;

static inline void on_reset_hcsr(){
	aux16 = TCNT1;								// Loads actual time in TCNT1 into aux16
     b08:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
     b0c:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
	aux16 += 20;								// 20*500ns = 10us (tiempo del trigger), Adds 10 (us) to the previously saved time at TCNT1
     b10:	44 96       	adiw	r24, 0x14	; 20
     b12:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <aux16+0x1>
     b16:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <aux16>
	OCR1B = aux16;								// Then loads the value into OCR1B, generating an Output Compare Interrupt
     b1a:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7f808b>
     b1e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7f808a>
	TIFR1 = (1<<OCF1B) | (1<<OCF1A);			// Flag set after the counter value in TCNT1 equals OCR1A and OCR1B
     b22:	86 e0       	ldi	r24, 0x06	; 6
     b24:	86 bb       	out	0x16, r24	; 22
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
     b26:	84 e0       	ldi	r24, 0x04	; 4
     b28:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
     b2c:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <HCSR_1>
     b30:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <HCSR_1+0x1>
     b34:	0e 94 87 00 	call	0x10e	; 0x10e <HCSR04_Start>
		on_reset_hcsr();
		//state1 = IR_GetState(&ir_sensor[0]);
		count100ms = 10;
     b38:	8a e0       	ldi	r24, 0x0A	; 10
     b3a:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <count100ms>
	}
	
	if (!count40ms){
     b3e:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <count40ms>
     b42:	88 23       	and	r24, r24
     b44:	81 f0       	breq	.+32     	; 0xb66 <every10ms+0x6a>
     b46:	1f c0       	rjmp	.+62     	; 0xb86 <every10ms+0x8a>
		for(int i=0;i<4;i++){
			IR_Update(&ir_sensor[i], raw_input[i]);
     b48:	fe 01       	movw	r30, r28
     b4a:	e9 5b       	subi	r30, 0xB9	; 185
     b4c:	fd 4f       	sbci	r31, 0xFD	; 253
     b4e:	ce 01       	movw	r24, r28
     b50:	88 0f       	add	r24, r24
     b52:	99 1f       	adc	r25, r25
     b54:	88 0f       	add	r24, r24
     b56:	99 1f       	adc	r25, r25
     b58:	60 81       	ld	r22, Z
     b5a:	81 5b       	subi	r24, 0xB1	; 177
     b5c:	9d 4f       	sbci	r25, 0xFD	; 253
     b5e:	0e 94 19 02 	call	0x432	; 0x432 <IR_Update>
		//state1 = IR_GetState(&ir_sensor[0]);
		count100ms = 10;
	}
	
	if (!count40ms){
		for(int i=0;i<4;i++){
     b62:	21 96       	adiw	r28, 0x01	; 1
     b64:	02 c0       	rjmp	.+4      	; 0xb6a <every10ms+0x6e>
     b66:	c0 e0       	ldi	r28, 0x00	; 0
     b68:	d0 e0       	ldi	r29, 0x00	; 0
     b6a:	c4 30       	cpi	r28, 0x04	; 4
     b6c:	d1 05       	cpc	r29, r1
     b6e:	64 f3       	brlt	.-40     	; 0xb48 <every10ms+0x4c>
			IR_Update(&ir_sensor[i], raw_input[i]);
		}
		count40ms = 4;
     b70:	84 e0       	ldi	r24, 0x04	; 4
     b72:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <count40ms>
		newBox(globalDistance);
     b76:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <globalDistance>
     b7a:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <globalDistance+0x1>
     b7e:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <newBox>
		kickBox();
     b82:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <kickBox>
	}
	
	raw_input[0] = (PIND & (1<<IR0)) ? 1 : 0;
     b86:	89 b1       	in	r24, 0x09	; 9
     b88:	82 fb       	bst	r24, 2
     b8a:	88 27       	eor	r24, r24
     b8c:	80 f9       	bld	r24, 0
     b8e:	e7 e4       	ldi	r30, 0x47	; 71
     b90:	f2 e0       	ldi	r31, 0x02	; 2
     b92:	80 83       	st	Z, r24
	raw_input[1] = (PIND & (1<<IR1)) ? 1 : 0;
     b94:	89 b1       	in	r24, 0x09	; 9
     b96:	83 fb       	bst	r24, 3
     b98:	88 27       	eor	r24, r24
     b9a:	80 f9       	bld	r24, 0
     b9c:	81 83       	std	Z+1, r24	; 0x01
	raw_input[2] = (PIND & (1<<IR2)) ? 1 : 0;
     b9e:	89 b1       	in	r24, 0x09	; 9
     ba0:	82 95       	swap	r24
     ba2:	81 70       	andi	r24, 0x01	; 1
     ba4:	82 83       	std	Z+2, r24	; 0x02
	raw_input[3] = (PIND & (1<<IR3)) ? 1 : 0;
     ba6:	89 b1       	in	r24, 0x09	; 9
     ba8:	85 fb       	bst	r24, 5
     baa:	88 27       	eor	r24, r24
     bac:	80 f9       	bld	r24, 0
     bae:	83 83       	std	Z+3, r24	; 0x03
	
	IS10MS = FALSE;
     bb0:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <flag0>
     bb4:	8e 7f       	andi	r24, 0xFE	; 254
     bb6:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <flag0>
	count100ms--;
     bba:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <count100ms>
     bbe:	81 50       	subi	r24, 0x01	; 1
     bc0:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <count100ms>
	count40ms--;
     bc4:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <count40ms>
     bc8:	81 50       	subi	r24, 0x01	; 1
     bca:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <count40ms>
}
     bce:	df 91       	pop	r29
     bd0:	cf 91       	pop	r28
     bd2:	08 95       	ret

00000bd4 <main>:
}
/* END Function prototypes user code ------------------------------------------*/

int main(){
	
	cli();
     bd4:	f8 94       	cli

	/* END Local variables -------------------------------------------------------*/


	/* User code Init ------------------------------------------------------------*/
	flag0.byte = 0;
     bd6:	10 92 46 02 	sts	0x0246, r1	; 0x800246 <flag0>
	
	ini_ports();
     bda:	0e 94 c8 01 	call	0x390	; 0x390 <ini_ports>
	ini_timer1();
     bde:	0e 94 d7 01 	call	0x3ae	; 0x3ae <ini_timer1>
	ini_timer0();
     be2:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <ini_timer0>
	ini_USART(16);
     be6:	80 e1       	ldi	r24, 0x10	; 16
     be8:	0e 94 f6 01 	call	0x3ec	; 0x3ec <ini_USART>
	
	IR_Init(&ir_sensor[0]);
     bec:	8f e4       	ldi	r24, 0x4F	; 79
     bee:	92 e0       	ldi	r25, 0x02	; 2
     bf0:	0e 94 04 02 	call	0x408	; 0x408 <IR_Init>
	
	addServo(&PORTD,SV0);
     bf4:	67 e0       	ldi	r22, 0x07	; 7
     bf6:	8b e2       	ldi	r24, 0x2B	; 43
     bf8:	90 e0       	ldi	r25, 0x00	; 0
     bfa:	0e 94 5f 06 	call	0xcbe	; 0xcbe <addServo>
	addServo(&PORTB,SV1);
     bfe:	64 e0       	ldi	r22, 0x04	; 4
     c00:	85 e2       	ldi	r24, 0x25	; 37
     c02:	90 e0       	ldi	r25, 0x00	; 0
     c04:	0e 94 5f 06 	call	0xcbe	; 0xcbe <addServo>
	addServo(&PORTB,SV2);
     c08:	63 e0       	ldi	r22, 0x03	; 3
     c0a:	85 e2       	ldi	r24, 0x25	; 37
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	0e 94 5f 06 	call	0xcbe	; 0xcbe <addServo>
	
	HCSR_1 = HCSR04_AddNew(&WritePin_HCSR, 16);
     c12:	40 e1       	ldi	r20, 0x10	; 16
     c14:	50 e0       	ldi	r21, 0x00	; 0
     c16:	60 e0       	ldi	r22, 0x00	; 0
     c18:	70 e0       	ldi	r23, 0x00	; 0
     c1a:	88 ed       	ldi	r24, 0xD8	; 216
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	0e 94 5a 00 	call	0xb4	; 0xb4 <HCSR04_AddNew>
     c22:	a0 e0       	ldi	r26, 0x00	; 0
     c24:	b0 e0       	ldi	r27, 0x00	; 0
     c26:	80 93 23 01 	sts	0x0123, r24	; 0x800123 <HCSR_1>
     c2a:	90 93 24 01 	sts	0x0124, r25	; 0x800124 <HCSR_1+0x1>
     c2e:	a0 93 25 01 	sts	0x0125, r26	; 0x800125 <HCSR_1+0x2>
     c32:	b0 93 26 01 	sts	0x0126, r27	; 0x800126 <HCSR_1+0x3>
	
	dataRx.buff = (uint8_t *)buffRx;
     c36:	e5 e3       	ldi	r30, 0x35	; 53
     c38:	f2 e0       	ldi	r31, 0x02	; 2
     c3a:	89 e2       	ldi	r24, 0x29	; 41
     c3c:	91 e0       	ldi	r25, 0x01	; 1
     c3e:	91 83       	std	Z+1, r25	; 0x01
     c40:	80 83       	st	Z, r24
	dataRx.indexR = 0;
     c42:	12 82       	std	Z+2, r1	; 0x02
	dataRx.indexW = 0;
     c44:	13 82       	std	Z+3, r1	; 0x03
	dataRx.header = HEADER_U;
     c46:	10 86       	std	Z+8, r1	; 0x08
	dataRx.mask = RXBUFSIZE - 1;
     c48:	8f ef       	ldi	r24, 0xFF	; 255
     c4a:	85 83       	std	Z+5, r24	; 0x05
	
	dataTx.buff = buffTx;
     c4c:	e0 e4       	ldi	r30, 0x40	; 64
     c4e:	f2 e0       	ldi	r31, 0x02	; 2
     c50:	2f e5       	ldi	r18, 0x5F	; 95
     c52:	32 e0       	ldi	r19, 0x02	; 2
     c54:	31 83       	std	Z+1, r19	; 0x01
     c56:	20 83       	st	Z, r18
	dataTx.indexR = 0;
     c58:	12 82       	std	Z+2, r1	; 0x02
	dataTx.indexW = 0;
     c5a:	13 82       	std	Z+3, r1	; 0x03
	dataTx.mask = TXBUFSIZE -1;
     c5c:	84 83       	std	Z+4, r24	; 0x04
	
	boxSizeconfig.smallboxF=Cm15;
     c5e:	e9 e2       	ldi	r30, 0x29	; 41
     c60:	f2 e0       	ldi	r31, 0x02	; 2
     c62:	86 e6       	ldi	r24, 0x66	; 102
     c64:	93 e0       	ldi	r25, 0x03	; 3
     c66:	91 83       	std	Z+1, r25	; 0x01
     c68:	80 83       	st	Z, r24
	boxSizeconfig.smallboxC=Cm13;
     c6a:	82 ef       	ldi	r24, 0xF2	; 242
     c6c:	92 e0       	ldi	r25, 0x02	; 2
     c6e:	93 83       	std	Z+3, r25	; 0x03
     c70:	82 83       	std	Z+2, r24	; 0x02
	boxSizeconfig.mediumboxF=Cm13;
     c72:	95 83       	std	Z+5, r25	; 0x05
     c74:	84 83       	std	Z+4, r24	; 0x04
	boxSizeconfig.mediumboxC=Cm11;
     c76:	8e e7       	ldi	r24, 0x7E	; 126
     c78:	92 e0       	ldi	r25, 0x02	; 2
     c7a:	97 83       	std	Z+7, r25	; 0x07
     c7c:	86 83       	std	Z+6, r24	; 0x06
	boxSizeconfig.largeboxF=Cm11;
     c7e:	91 87       	std	Z+9, r25	; 0x09
     c80:	80 87       	std	Z+8, r24	; 0x08
	boxSizeconfig.largeboxC=Cm9;
     c82:	8a e0       	ldi	r24, 0x0A	; 10
     c84:	92 e0       	ldi	r25, 0x02	; 2
     c86:	93 87       	std	Z+11, r25	; 0x0b
     c88:	82 87       	std	Z+10, r24	; 0x0a
	
	ir_sensor[1].irType = SmallBox;
     c8a:	ef e4       	ldi	r30, 0x4F	; 79
     c8c:	f2 e0       	ldi	r31, 0x02	; 2
     c8e:	81 e0       	ldi	r24, 0x01	; 1
     c90:	87 83       	std	Z+7, r24	; 0x07
	ir_sensor[2].irType = MediumBox;
     c92:	92 e0       	ldi	r25, 0x02	; 2
     c94:	93 87       	std	Z+11, r25	; 0x0b
	ir_sensor[3].irType = LargeBox;
     c96:	93 e0       	ldi	r25, 0x03	; 3
     c98:	97 87       	std	Z+15, r25	; 0x0f
	
	Cajita[0].boxSize = SmallBox;
     c9a:	80 93 5f 03 	sts	0x035F, r24	; 0x80035f <Cajita>
	
	/* END User code Init --------------------------------------------------------*/
	sei();
     c9e:	78 94       	sei

	while (1){
		/* User Code loop ------------------------------------------------------------*/
		task_HCSR();
     ca0:	0e 94 af 00 	call	0x15e	; 0x15e <task_HCSR>
		serialTask(&dataRx,&dataTx);
     ca4:	60 e4       	ldi	r22, 0x40	; 64
     ca6:	72 e0       	ldi	r23, 0x02	; 2
     ca8:	85 e3       	ldi	r24, 0x35	; 53
     caa:	92 e0       	ldi	r25, 0x02	; 2
     cac:	0e 94 30 04 	call	0x860	; 0x860 <serialTask>
		if (IS10MS)
     cb0:	80 91 46 02 	lds	r24, 0x0246	; 0x800246 <flag0>
     cb4:	80 ff       	sbrs	r24, 0
     cb6:	f4 cf       	rjmp	.-24     	; 0xca0 <main+0xcc>
			every10ms();
     cb8:	0e 94 7e 05 	call	0xafc	; 0xafc <every10ms>
     cbc:	f1 cf       	rjmp	.-30     	; 0xca0 <main+0xcc>

00000cbe <addServo>:
     cbe:	20 91 13 01 	lds	r18, 0x0113	; 0x800113 <ServN>
     cc2:	e2 2f       	mov	r30, r18
     cc4:	f0 e0       	ldi	r31, 0x00	; 0
     cc6:	af 01       	movw	r20, r30
     cc8:	44 0f       	add	r20, r20
     cca:	55 1f       	adc	r21, r21
     ccc:	44 0f       	add	r20, r20
     cce:	55 1f       	adc	r21, r21
     cd0:	e4 0f       	add	r30, r20
     cd2:	f5 1f       	adc	r31, r21
     cd4:	ec 5e       	subi	r30, 0xEC	; 236
     cd6:	fe 4f       	sbci	r31, 0xFE	; 254
     cd8:	62 83       	std	Z+2, r22	; 0x02
     cda:	91 83       	std	Z+1, r25	; 0x01
     cdc:	80 83       	st	Z, r24
     cde:	2f 5f       	subi	r18, 0xFF	; 255
     ce0:	20 93 13 01 	sts	0x0113, r18	; 0x800113 <ServN>
     ce4:	08 95       	ret

00000ce6 <servo_Angle>:
     ce6:	48 2f       	mov	r20, r24
     ce8:	85 e7       	ldi	r24, 0x75	; 117
     cea:	68 9f       	mul	r22, r24
     cec:	90 01       	movw	r18, r0
     cee:	11 24       	eor	r1, r1
     cf0:	2e 5c       	subi	r18, 0xCE	; 206
     cf2:	36 4d       	sbci	r19, 0xD6	; 214
     cf4:	a3 e8       	ldi	r26, 0x83	; 131
     cf6:	bd e2       	ldi	r27, 0x2D	; 45
     cf8:	0e 94 04 07 	call	0xe08	; 0xe08 <__umulhisi3>
     cfc:	96 95       	lsr	r25
     cfe:	87 95       	ror	r24
     d00:	92 95       	swap	r25
     d02:	82 95       	swap	r24
     d04:	8f 70       	andi	r24, 0x0F	; 15
     d06:	89 27       	eor	r24, r25
     d08:	9f 70       	andi	r25, 0x0F	; 15
     d0a:	89 27       	eor	r24, r25
     d0c:	9c 01       	movw	r18, r24
     d0e:	2b 5f       	subi	r18, 0xFB	; 251
     d10:	3f 4f       	sbci	r19, 0xFF	; 255
     d12:	ad ec       	ldi	r26, 0xCD	; 205
     d14:	bc ec       	ldi	r27, 0xCC	; 204
     d16:	0e 94 04 07 	call	0xe08	; 0xe08 <__umulhisi3>
     d1a:	96 95       	lsr	r25
     d1c:	87 95       	ror	r24
     d1e:	96 95       	lsr	r25
     d20:	87 95       	ror	r24
     d22:	96 95       	lsr	r25
     d24:	87 95       	ror	r24
     d26:	24 2f       	mov	r18, r20
     d28:	30 e0       	ldi	r19, 0x00	; 0
     d2a:	f9 01       	movw	r30, r18
     d2c:	ee 0f       	add	r30, r30
     d2e:	ff 1f       	adc	r31, r31
     d30:	ee 0f       	add	r30, r30
     d32:	ff 1f       	adc	r31, r31
     d34:	2e 0f       	add	r18, r30
     d36:	3f 1f       	adc	r19, r31
     d38:	f9 01       	movw	r30, r18
     d3a:	ec 5e       	subi	r30, 0xEC	; 236
     d3c:	fe 4f       	sbci	r31, 0xFE	; 254
     d3e:	84 83       	std	Z+4, r24	; 0x04
     d40:	08 95       	ret

00000d42 <writeServo>:
     d42:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <is20ms>
     d46:	81 50       	subi	r24, 0x01	; 1
     d48:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <is20ms>
     d4c:	20 e0       	ldi	r18, 0x00	; 0
     d4e:	2a c0       	rjmp	.+84     	; 0xda4 <writeServo+0x62>
     d50:	82 2f       	mov	r24, r18
     d52:	90 e0       	ldi	r25, 0x00	; 0
     d54:	fc 01       	movw	r30, r24
     d56:	ee 0f       	add	r30, r30
     d58:	ff 1f       	adc	r31, r31
     d5a:	ee 0f       	add	r30, r30
     d5c:	ff 1f       	adc	r31, r31
     d5e:	e8 0f       	add	r30, r24
     d60:	f9 1f       	adc	r31, r25
     d62:	ec 5e       	subi	r30, 0xEC	; 236
     d64:	fe 4f       	sbci	r31, 0xFE	; 254
     d66:	33 81       	ldd	r19, Z+3	; 0x03
     d68:	31 50       	subi	r19, 0x01	; 1
     d6a:	33 83       	std	Z+3, r19	; 0x03
     d6c:	33 81       	ldd	r19, Z+3	; 0x03
     d6e:	31 11       	cpse	r19, r1
     d70:	18 c0       	rjmp	.+48     	; 0xda2 <writeServo+0x60>
     d72:	fc 01       	movw	r30, r24
     d74:	ee 0f       	add	r30, r30
     d76:	ff 1f       	adc	r31, r31
     d78:	ee 0f       	add	r30, r30
     d7a:	ff 1f       	adc	r31, r31
     d7c:	8e 0f       	add	r24, r30
     d7e:	9f 1f       	adc	r25, r31
     d80:	fc 01       	movw	r30, r24
     d82:	ec 5e       	subi	r30, 0xEC	; 236
     d84:	fe 4f       	sbci	r31, 0xFE	; 254
     d86:	a0 81       	ld	r26, Z
     d88:	b1 81       	ldd	r27, Z+1	; 0x01
     d8a:	3c 91       	ld	r19, X
     d8c:	81 e0       	ldi	r24, 0x01	; 1
     d8e:	90 e0       	ldi	r25, 0x00	; 0
     d90:	02 80       	ldd	r0, Z+2	; 0x02
     d92:	02 c0       	rjmp	.+4      	; 0xd98 <writeServo+0x56>
     d94:	88 0f       	add	r24, r24
     d96:	99 1f       	adc	r25, r25
     d98:	0a 94       	dec	r0
     d9a:	e2 f7       	brpl	.-8      	; 0xd94 <writeServo+0x52>
     d9c:	80 95       	com	r24
     d9e:	83 23       	and	r24, r19
     da0:	8c 93       	st	X, r24
     da2:	2f 5f       	subi	r18, 0xFF	; 255
     da4:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ServN>
     da8:	28 17       	cp	r18, r24
     daa:	90 f2       	brcs	.-92     	; 0xd50 <writeServo+0xe>
     dac:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <is20ms>
     db0:	99 23       	and	r25, r25
     db2:	e9 f0       	breq	.+58     	; 0xdee <writeServo+0xac>
     db4:	08 95       	ret
     db6:	e9 2f       	mov	r30, r25
     db8:	f0 e0       	ldi	r31, 0x00	; 0
     dba:	9f 01       	movw	r18, r30
     dbc:	22 0f       	add	r18, r18
     dbe:	33 1f       	adc	r19, r19
     dc0:	22 0f       	add	r18, r18
     dc2:	33 1f       	adc	r19, r19
     dc4:	e2 0f       	add	r30, r18
     dc6:	f3 1f       	adc	r31, r19
     dc8:	ec 5e       	subi	r30, 0xEC	; 236
     dca:	fe 4f       	sbci	r31, 0xFE	; 254
     dcc:	24 81       	ldd	r18, Z+4	; 0x04
     dce:	23 83       	std	Z+3, r18	; 0x03
     dd0:	a0 81       	ld	r26, Z
     dd2:	b1 81       	ldd	r27, Z+1	; 0x01
     dd4:	4c 91       	ld	r20, X
     dd6:	21 e0       	ldi	r18, 0x01	; 1
     dd8:	30 e0       	ldi	r19, 0x00	; 0
     dda:	02 80       	ldd	r0, Z+2	; 0x02
     ddc:	02 c0       	rjmp	.+4      	; 0xde2 <writeServo+0xa0>
     dde:	22 0f       	add	r18, r18
     de0:	33 1f       	adc	r19, r19
     de2:	0a 94       	dec	r0
     de4:	e2 f7       	brpl	.-8      	; 0xdde <writeServo+0x9c>
     de6:	24 2b       	or	r18, r20
     de8:	2c 93       	st	X, r18
     dea:	9f 5f       	subi	r25, 0xFF	; 255
     dec:	01 c0       	rjmp	.+2      	; 0xdf0 <writeServo+0xae>
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	98 17       	cp	r25, r24
     df2:	08 f3       	brcs	.-62     	; 0xdb6 <writeServo+0x74>
     df4:	8c e9       	ldi	r24, 0x9C	; 156
     df6:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <is20ms>
     dfa:	08 95       	ret

00000dfc <__tablejump2__>:
     dfc:	ee 0f       	add	r30, r30
     dfe:	ff 1f       	adc	r31, r31
     e00:	05 90       	lpm	r0, Z+
     e02:	f4 91       	lpm	r31, Z
     e04:	e0 2d       	mov	r30, r0
     e06:	09 94       	ijmp

00000e08 <__umulhisi3>:
     e08:	a2 9f       	mul	r26, r18
     e0a:	b0 01       	movw	r22, r0
     e0c:	b3 9f       	mul	r27, r19
     e0e:	c0 01       	movw	r24, r0
     e10:	a3 9f       	mul	r26, r19
     e12:	70 0d       	add	r23, r0
     e14:	81 1d       	adc	r24, r1
     e16:	11 24       	eor	r1, r1
     e18:	91 1d       	adc	r25, r1
     e1a:	b2 9f       	mul	r27, r18
     e1c:	70 0d       	add	r23, r0
     e1e:	81 1d       	adc	r24, r1
     e20:	11 24       	eor	r1, r1
     e22:	91 1d       	adc	r25, r1
     e24:	08 95       	ret

00000e26 <malloc>:
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	cf 93       	push	r28
     e2c:	df 93       	push	r29
     e2e:	82 30       	cpi	r24, 0x02	; 2
     e30:	91 05       	cpc	r25, r1
     e32:	10 f4       	brcc	.+4      	; 0xe38 <malloc+0x12>
     e34:	82 e0       	ldi	r24, 0x02	; 2
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <__flp>
     e3c:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <__flp+0x1>
     e40:	20 e0       	ldi	r18, 0x00	; 0
     e42:	30 e0       	ldi	r19, 0x00	; 0
     e44:	a0 e0       	ldi	r26, 0x00	; 0
     e46:	b0 e0       	ldi	r27, 0x00	; 0
     e48:	30 97       	sbiw	r30, 0x00	; 0
     e4a:	19 f1       	breq	.+70     	; 0xe92 <malloc+0x6c>
     e4c:	40 81       	ld	r20, Z
     e4e:	51 81       	ldd	r21, Z+1	; 0x01
     e50:	02 81       	ldd	r16, Z+2	; 0x02
     e52:	13 81       	ldd	r17, Z+3	; 0x03
     e54:	48 17       	cp	r20, r24
     e56:	59 07       	cpc	r21, r25
     e58:	c8 f0       	brcs	.+50     	; 0xe8c <malloc+0x66>
     e5a:	84 17       	cp	r24, r20
     e5c:	95 07       	cpc	r25, r21
     e5e:	69 f4       	brne	.+26     	; 0xe7a <malloc+0x54>
     e60:	10 97       	sbiw	r26, 0x00	; 0
     e62:	31 f0       	breq	.+12     	; 0xe70 <malloc+0x4a>
     e64:	12 96       	adiw	r26, 0x02	; 2
     e66:	0c 93       	st	X, r16
     e68:	12 97       	sbiw	r26, 0x02	; 2
     e6a:	13 96       	adiw	r26, 0x03	; 3
     e6c:	1c 93       	st	X, r17
     e6e:	27 c0       	rjmp	.+78     	; 0xebe <malloc+0x98>
     e70:	00 93 7f 03 	sts	0x037F, r16	; 0x80037f <__flp>
     e74:	10 93 80 03 	sts	0x0380, r17	; 0x800380 <__flp+0x1>
     e78:	22 c0       	rjmp	.+68     	; 0xebe <malloc+0x98>
     e7a:	21 15       	cp	r18, r1
     e7c:	31 05       	cpc	r19, r1
     e7e:	19 f0       	breq	.+6      	; 0xe86 <malloc+0x60>
     e80:	42 17       	cp	r20, r18
     e82:	53 07       	cpc	r21, r19
     e84:	18 f4       	brcc	.+6      	; 0xe8c <malloc+0x66>
     e86:	9a 01       	movw	r18, r20
     e88:	bd 01       	movw	r22, r26
     e8a:	ef 01       	movw	r28, r30
     e8c:	df 01       	movw	r26, r30
     e8e:	f8 01       	movw	r30, r16
     e90:	db cf       	rjmp	.-74     	; 0xe48 <malloc+0x22>
     e92:	21 15       	cp	r18, r1
     e94:	31 05       	cpc	r19, r1
     e96:	f9 f0       	breq	.+62     	; 0xed6 <malloc+0xb0>
     e98:	28 1b       	sub	r18, r24
     e9a:	39 0b       	sbc	r19, r25
     e9c:	24 30       	cpi	r18, 0x04	; 4
     e9e:	31 05       	cpc	r19, r1
     ea0:	80 f4       	brcc	.+32     	; 0xec2 <malloc+0x9c>
     ea2:	8a 81       	ldd	r24, Y+2	; 0x02
     ea4:	9b 81       	ldd	r25, Y+3	; 0x03
     ea6:	61 15       	cp	r22, r1
     ea8:	71 05       	cpc	r23, r1
     eaa:	21 f0       	breq	.+8      	; 0xeb4 <malloc+0x8e>
     eac:	fb 01       	movw	r30, r22
     eae:	93 83       	std	Z+3, r25	; 0x03
     eb0:	82 83       	std	Z+2, r24	; 0x02
     eb2:	04 c0       	rjmp	.+8      	; 0xebc <malloc+0x96>
     eb4:	90 93 80 03 	sts	0x0380, r25	; 0x800380 <__flp+0x1>
     eb8:	80 93 7f 03 	sts	0x037F, r24	; 0x80037f <__flp>
     ebc:	fe 01       	movw	r30, r28
     ebe:	32 96       	adiw	r30, 0x02	; 2
     ec0:	44 c0       	rjmp	.+136    	; 0xf4a <malloc+0x124>
     ec2:	fe 01       	movw	r30, r28
     ec4:	e2 0f       	add	r30, r18
     ec6:	f3 1f       	adc	r31, r19
     ec8:	81 93       	st	Z+, r24
     eca:	91 93       	st	Z+, r25
     ecc:	22 50       	subi	r18, 0x02	; 2
     ece:	31 09       	sbc	r19, r1
     ed0:	39 83       	std	Y+1, r19	; 0x01
     ed2:	28 83       	st	Y, r18
     ed4:	3a c0       	rjmp	.+116    	; 0xf4a <malloc+0x124>
     ed6:	20 91 7d 03 	lds	r18, 0x037D	; 0x80037d <__brkval>
     eda:	30 91 7e 03 	lds	r19, 0x037E	; 0x80037e <__brkval+0x1>
     ede:	23 2b       	or	r18, r19
     ee0:	41 f4       	brne	.+16     	; 0xef2 <malloc+0xcc>
     ee2:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
     ee6:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
     eea:	30 93 7e 03 	sts	0x037E, r19	; 0x80037e <__brkval+0x1>
     eee:	20 93 7d 03 	sts	0x037D, r18	; 0x80037d <__brkval>
     ef2:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     ef6:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     efa:	21 15       	cp	r18, r1
     efc:	31 05       	cpc	r19, r1
     efe:	41 f4       	brne	.+16     	; 0xf10 <malloc+0xea>
     f00:	2d b7       	in	r18, 0x3d	; 61
     f02:	3e b7       	in	r19, 0x3e	; 62
     f04:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
     f08:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
     f0c:	24 1b       	sub	r18, r20
     f0e:	35 0b       	sbc	r19, r21
     f10:	e0 91 7d 03 	lds	r30, 0x037D	; 0x80037d <__brkval>
     f14:	f0 91 7e 03 	lds	r31, 0x037E	; 0x80037e <__brkval+0x1>
     f18:	e2 17       	cp	r30, r18
     f1a:	f3 07       	cpc	r31, r19
     f1c:	a0 f4       	brcc	.+40     	; 0xf46 <malloc+0x120>
     f1e:	2e 1b       	sub	r18, r30
     f20:	3f 0b       	sbc	r19, r31
     f22:	28 17       	cp	r18, r24
     f24:	39 07       	cpc	r19, r25
     f26:	78 f0       	brcs	.+30     	; 0xf46 <malloc+0x120>
     f28:	ac 01       	movw	r20, r24
     f2a:	4e 5f       	subi	r20, 0xFE	; 254
     f2c:	5f 4f       	sbci	r21, 0xFF	; 255
     f2e:	24 17       	cp	r18, r20
     f30:	35 07       	cpc	r19, r21
     f32:	48 f0       	brcs	.+18     	; 0xf46 <malloc+0x120>
     f34:	4e 0f       	add	r20, r30
     f36:	5f 1f       	adc	r21, r31
     f38:	50 93 7e 03 	sts	0x037E, r21	; 0x80037e <__brkval+0x1>
     f3c:	40 93 7d 03 	sts	0x037D, r20	; 0x80037d <__brkval>
     f40:	81 93       	st	Z+, r24
     f42:	91 93       	st	Z+, r25
     f44:	02 c0       	rjmp	.+4      	; 0xf4a <malloc+0x124>
     f46:	e0 e0       	ldi	r30, 0x00	; 0
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	cf 01       	movw	r24, r30
     f4c:	df 91       	pop	r29
     f4e:	cf 91       	pop	r28
     f50:	1f 91       	pop	r17
     f52:	0f 91       	pop	r16
     f54:	08 95       	ret

00000f56 <free>:
     f56:	cf 93       	push	r28
     f58:	df 93       	push	r29
     f5a:	00 97       	sbiw	r24, 0x00	; 0
     f5c:	09 f4       	brne	.+2      	; 0xf60 <free+0xa>
     f5e:	81 c0       	rjmp	.+258    	; 0x1062 <free+0x10c>
     f60:	fc 01       	movw	r30, r24
     f62:	32 97       	sbiw	r30, 0x02	; 2
     f64:	13 82       	std	Z+3, r1	; 0x03
     f66:	12 82       	std	Z+2, r1	; 0x02
     f68:	a0 91 7f 03 	lds	r26, 0x037F	; 0x80037f <__flp>
     f6c:	b0 91 80 03 	lds	r27, 0x0380	; 0x800380 <__flp+0x1>
     f70:	10 97       	sbiw	r26, 0x00	; 0
     f72:	81 f4       	brne	.+32     	; 0xf94 <free+0x3e>
     f74:	20 81       	ld	r18, Z
     f76:	31 81       	ldd	r19, Z+1	; 0x01
     f78:	82 0f       	add	r24, r18
     f7a:	93 1f       	adc	r25, r19
     f7c:	20 91 7d 03 	lds	r18, 0x037D	; 0x80037d <__brkval>
     f80:	30 91 7e 03 	lds	r19, 0x037E	; 0x80037e <__brkval+0x1>
     f84:	28 17       	cp	r18, r24
     f86:	39 07       	cpc	r19, r25
     f88:	51 f5       	brne	.+84     	; 0xfde <free+0x88>
     f8a:	f0 93 7e 03 	sts	0x037E, r31	; 0x80037e <__brkval+0x1>
     f8e:	e0 93 7d 03 	sts	0x037D, r30	; 0x80037d <__brkval>
     f92:	67 c0       	rjmp	.+206    	; 0x1062 <free+0x10c>
     f94:	ed 01       	movw	r28, r26
     f96:	20 e0       	ldi	r18, 0x00	; 0
     f98:	30 e0       	ldi	r19, 0x00	; 0
     f9a:	ce 17       	cp	r28, r30
     f9c:	df 07       	cpc	r29, r31
     f9e:	40 f4       	brcc	.+16     	; 0xfb0 <free+0x5a>
     fa0:	4a 81       	ldd	r20, Y+2	; 0x02
     fa2:	5b 81       	ldd	r21, Y+3	; 0x03
     fa4:	9e 01       	movw	r18, r28
     fa6:	41 15       	cp	r20, r1
     fa8:	51 05       	cpc	r21, r1
     faa:	f1 f0       	breq	.+60     	; 0xfe8 <free+0x92>
     fac:	ea 01       	movw	r28, r20
     fae:	f5 cf       	rjmp	.-22     	; 0xf9a <free+0x44>
     fb0:	d3 83       	std	Z+3, r29	; 0x03
     fb2:	c2 83       	std	Z+2, r28	; 0x02
     fb4:	40 81       	ld	r20, Z
     fb6:	51 81       	ldd	r21, Z+1	; 0x01
     fb8:	84 0f       	add	r24, r20
     fba:	95 1f       	adc	r25, r21
     fbc:	c8 17       	cp	r28, r24
     fbe:	d9 07       	cpc	r29, r25
     fc0:	59 f4       	brne	.+22     	; 0xfd8 <free+0x82>
     fc2:	88 81       	ld	r24, Y
     fc4:	99 81       	ldd	r25, Y+1	; 0x01
     fc6:	84 0f       	add	r24, r20
     fc8:	95 1f       	adc	r25, r21
     fca:	02 96       	adiw	r24, 0x02	; 2
     fcc:	91 83       	std	Z+1, r25	; 0x01
     fce:	80 83       	st	Z, r24
     fd0:	8a 81       	ldd	r24, Y+2	; 0x02
     fd2:	9b 81       	ldd	r25, Y+3	; 0x03
     fd4:	93 83       	std	Z+3, r25	; 0x03
     fd6:	82 83       	std	Z+2, r24	; 0x02
     fd8:	21 15       	cp	r18, r1
     fda:	31 05       	cpc	r19, r1
     fdc:	29 f4       	brne	.+10     	; 0xfe8 <free+0x92>
     fde:	f0 93 80 03 	sts	0x0380, r31	; 0x800380 <__flp+0x1>
     fe2:	e0 93 7f 03 	sts	0x037F, r30	; 0x80037f <__flp>
     fe6:	3d c0       	rjmp	.+122    	; 0x1062 <free+0x10c>
     fe8:	e9 01       	movw	r28, r18
     fea:	fb 83       	std	Y+3, r31	; 0x03
     fec:	ea 83       	std	Y+2, r30	; 0x02
     fee:	49 91       	ld	r20, Y+
     ff0:	59 91       	ld	r21, Y+
     ff2:	c4 0f       	add	r28, r20
     ff4:	d5 1f       	adc	r29, r21
     ff6:	ec 17       	cp	r30, r28
     ff8:	fd 07       	cpc	r31, r29
     ffa:	61 f4       	brne	.+24     	; 0x1014 <free+0xbe>
     ffc:	80 81       	ld	r24, Z
     ffe:	91 81       	ldd	r25, Z+1	; 0x01
    1000:	84 0f       	add	r24, r20
    1002:	95 1f       	adc	r25, r21
    1004:	02 96       	adiw	r24, 0x02	; 2
    1006:	e9 01       	movw	r28, r18
    1008:	99 83       	std	Y+1, r25	; 0x01
    100a:	88 83       	st	Y, r24
    100c:	82 81       	ldd	r24, Z+2	; 0x02
    100e:	93 81       	ldd	r25, Z+3	; 0x03
    1010:	9b 83       	std	Y+3, r25	; 0x03
    1012:	8a 83       	std	Y+2, r24	; 0x02
    1014:	e0 e0       	ldi	r30, 0x00	; 0
    1016:	f0 e0       	ldi	r31, 0x00	; 0
    1018:	12 96       	adiw	r26, 0x02	; 2
    101a:	8d 91       	ld	r24, X+
    101c:	9c 91       	ld	r25, X
    101e:	13 97       	sbiw	r26, 0x03	; 3
    1020:	00 97       	sbiw	r24, 0x00	; 0
    1022:	19 f0       	breq	.+6      	; 0x102a <free+0xd4>
    1024:	fd 01       	movw	r30, r26
    1026:	dc 01       	movw	r26, r24
    1028:	f7 cf       	rjmp	.-18     	; 0x1018 <free+0xc2>
    102a:	8d 91       	ld	r24, X+
    102c:	9c 91       	ld	r25, X
    102e:	11 97       	sbiw	r26, 0x01	; 1
    1030:	9d 01       	movw	r18, r26
    1032:	2e 5f       	subi	r18, 0xFE	; 254
    1034:	3f 4f       	sbci	r19, 0xFF	; 255
    1036:	82 0f       	add	r24, r18
    1038:	93 1f       	adc	r25, r19
    103a:	20 91 7d 03 	lds	r18, 0x037D	; 0x80037d <__brkval>
    103e:	30 91 7e 03 	lds	r19, 0x037E	; 0x80037e <__brkval+0x1>
    1042:	28 17       	cp	r18, r24
    1044:	39 07       	cpc	r19, r25
    1046:	69 f4       	brne	.+26     	; 0x1062 <free+0x10c>
    1048:	30 97       	sbiw	r30, 0x00	; 0
    104a:	29 f4       	brne	.+10     	; 0x1056 <free+0x100>
    104c:	10 92 80 03 	sts	0x0380, r1	; 0x800380 <__flp+0x1>
    1050:	10 92 7f 03 	sts	0x037F, r1	; 0x80037f <__flp>
    1054:	02 c0       	rjmp	.+4      	; 0x105a <free+0x104>
    1056:	13 82       	std	Z+3, r1	; 0x03
    1058:	12 82       	std	Z+2, r1	; 0x02
    105a:	b0 93 7e 03 	sts	0x037E, r27	; 0x80037e <__brkval+0x1>
    105e:	a0 93 7d 03 	sts	0x037D, r26	; 0x80037d <__brkval>
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	08 95       	ret

00001068 <_exit>:
    1068:	f8 94       	cli

0000106a <__stop_program>:
    106a:	ff cf       	rjmp	.-2      	; 0x106a <__stop_program>
