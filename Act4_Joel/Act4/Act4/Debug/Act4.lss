
AVRASM ver. 2.2.8  C:\Users\Baccon\Documents\Micros\Act4_Joel\Act4\Act4\main.asm Wed Apr 02 20:25:10 2025

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328Pdef.inc'
C:\Users\Baccon\Documents\Micros\Act4_Joel\Act4\Act4\main.asm(8): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pdef.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328Pdef.inc'
C:\Users\Baccon\Documents\Micros\Act4_Joel\Act4\Act4\main.asm(8): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pdef.inc'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #define _M328PDEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega328P
                                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x0f
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1B	= 6	; 
                                 .equ	FOC1A	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register
                                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SPMCSR - Store Program Memory Control and Status Register
                                 .equ    SELFPRGEN = 0; Added for backwards compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                                 .equ    SIGRD   = 5 ; Signature Row Read
                                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; 
                                 .equ	IVSEL	= 1	; 
                                 .equ	PUD	= 4	; 
                                 .equ	BODSE	= 5	; BOD Sleep Enable
                                 .equ	BODS	= 6	; BOD Sleep
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	EXTREF	= EXTRF	; For compatibility
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; GPIOR2 - General Purpose I/O Register 2
                                 .equ	GPIOR20	= 0	; 
                                 .equ	GPIOR21	= 1	; 
                                 .equ	GPIOR22	= 2	; 
                                 .equ	GPIOR23	= 3	; 
                                 .equ	GPIOR24	= 4	; 
                                 .equ	GPIOR25	= 5	; 
                                 .equ	GPIOR26	= 6	; 
                                 .equ	GPIOR27	= 7	; 
                                 
                                 ; GPIOR1 - General Purpose I/O Register 1
                                 .equ	GPIOR10	= 0	; 
                                 .equ	GPIOR11	= 1	; 
                                 .equ	GPIOR12	= 2	; 
                                 .equ	GPIOR13	= 3	; 
                                 .equ	GPIOR14	= 4	; 
                                 .equ	GPIOR15	= 5	; 
                                 .equ	GPIOR16	= 6	; 
                                 .equ	GPIOR17	= 7	; 
                                 
                                 ; GPIOR0 - General Purpose I/O Register 0
                                 .equ	GPIOR00	= 0	; 
                                 .equ	GPIOR01	= 1	; 
                                 .equ	GPIOR02	= 2	; 
                                 .equ	GPIOR03	= 3	; 
                                 .equ	GPIOR04	= 4	; 
                                 .equ	GPIOR05	= 5	; 
                                 .equ	GPIOR06	= 6	; 
                                 .equ	GPIOR07	= 7	; 
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEARH - EEPROM Address Register High Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select reset vector
                                 .equ	BOOTSZ0	= 1	; Select boot size
                                 .equ	BOOTSZ1	= 2	; Select boot size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog Timer Always On
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	DWEN	= 6	; debugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2048
                                 .equ	RAMEND	= 0x08ff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                                 
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; Act4.asm
                                 ;
                                 ; Created: 18/3/2025 18:08:11
                                 ; Author : Schiebert Joel
                                 ;
                                 
                                 #include <m328pdef.inc>
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;igualdades
                                 .equ	softversion=0x01
                                 .equ	build=0x04
                                 .equ	centuria=20
                                 .equ	anno=17
                                 .equ	mes=1
                                 .equ	dia=29
                                 
                                 ;igualdades
                                 .equ	LEDBUILTIN = PB5
                                 .equ	SW0 = PB4
                                 
                                 ; Definiciones para el buffer USART
                                 .equ    BUFSIZERX = 32	//Tamao del buffer de recepcin
                                 .equ    BUFSIZETX = 32	//Tamao del buffer de transmisin
                                 
                                 ;-----------------------------------------------------------------------------------------------------------------------------------------------
                                 
                                 .equ LASTSTATESW0	= 0		//GPIOR0<0>: ultimo estado del pulsador, Se usa para detectar flancos (cuando el usuario presiona o suelta el botn).
                                 .equ IS10MS			= 5		//GPIOR0<5>: para lograr los 10ms
                                 .equ ISNEWSTATESW0	= 7		//GPIOR0<7>: Indica si hubo un "nuevo estado" del botn. Se activa cuando el usuario presiona el botn (SW0).
                                 
                                 
                                 ;Estos valores representan los patrones de parpadeo del LED en cada estado.
                                 ;Estos valores se almacenan en ledstate y son usados para definir cundo el LED debe encenderse o apagarse.
                                 .equ	STATEIDLE	= 0x80000000	
                                 .equ	STATEUNO	= 0xF1000000	
                                 .equ	STATEDOS	= 0xF1100000	
                                 .equ	STATETRES	= 0xF1110000	
                                 .equ	STATECUATRO = 0xF1111000	
                                 .equ	STATECINCO	= 0xF1111100	
                                 .equ	STATESEIS	= 0xF1400000	
                                 .equ	STATESIETE	= 0xF1408000	
                                 .equ	STATEOCHO	= 0xF140A000	
                                 .equ	STATENUEVE	= 0xF140A800	
                                 .equ	STATEDIEZ	= 0xF140AA00	
                                 
                                 ;-----------------------------------------------------------------------------------------------------------------------------------------------
                                 
                                 ;definiciones - nombres simb?licos
                                 .def	w=r16
                                 .def	w1=r17
                                 .def	saux=r18
                                 .def	flag1=r19
                                 .def	newButton=r21
                                 
                                 ;-----------------------------------------------------------------------------------------------------------------------------------------------
                                 
                                 ; Segmento de Datos SRAM
                                 .dseg
000100                           statboot:		.BYTE	1
000101                           addrrx:			.BYTE	2
000103                           RXBUF:			.BYTE	24
                                 
00011b                           bufRX:			.BYTE   BUFSIZERX	; Buffer circular de recepcin
00013b                           iwRX:			.BYTE   1			; ndice de escritura RX
00013c                           irRX:			.BYTE   1			; ndice de lectura RX
00013d                           bufTX:			.BYTE   BUFSIZETX	; Buffer circular de transmisin
00015d                           iwTX:			.BYTE   1			; ndice de escritura TX
00015e                           irTX:			.BYTE   1			; ndice de lectura TX
                                 
00015f                           time10ms:		.BYTE	1
000160                           time100ms:		.BYTE	1
000161                           maskState:		.BYTE	4			;Mscara de estado del LED (4 bytes). Guarda una mscara de 4 bytes que se usa para definir el patrn de parpadeo del LED.
000165                           ledState:		.BYTE	4			;Estado actual del LED (4 bytes). Cuando el usuario cambia de estado, se actualiza con STATEIDLE o STATEUNO.
000169                           ledLastState:	.BYTE	1
                                 
00016a                           dbSW0:			.BYTE	1			;Contador de debounce del botn. Evita que una sola pulsacin sea detectada varias veces.
                                 
                                 ;-----------------------------------------------------------------------------------------------------------------------------------------------
                                 
                                 ; Segmento de Cdigo
                                 .cseg
                                 
                                 .org    0x00		// El micro empieza en la direccion 0x00
000000 940c 0227                     jmp start
                                 
                                 .org	0x20		//pagina 74 de ATMega328P
000020 940c 0081                 	jmp TIMER0_OVF
                                 
                                 .org    0x24		// Vector de interrupcin para USART RX
000024 940c 0092                     jmp USART_RXC
                                 
                                 .org	0x34		//por el vector de interrupciones
                                 
                                 ;-----------------------------------------------------------------------------------------------------------------------------------------------
                                 
                                 ;******************* CONSTANTES EN FLASH *************************
                                 
000034 3032
000035 3532
000036 3330
000037 3431
000038 305f
000039 6231
00003a 3130
00003b 000a                      version:		.db "20250314_01b01",'\n','\0'		;Se puede enviar por el puerto serie si se recibe un comando de diagnstico.
00003c 4554
00003d 5453
00003e 000a                      msgTest:		.db "TEST",'\n','\0'				;Este mensaje se usa como respuesta si se recibe la letra "T" por USART.
                                 
00003f 5453
000040 5441
000041 2045
000042 4449
000043 454c
000044 000a                      msgStateIdle:	.db "STATE IDLE",'\n','\0'			;Este mensaje se imprime por serie cuando STATEIDLE est activo.
000045 5453
000046 5441
000047 2045
000048 4e55
000049 0a4f
00004a 0000                      msgStateUno:	.db "STATE UNO",'\n','\0','\0'		;Este mensaje se imprime cuando STATEUNO est activo.
00004b 5453
00004c 5441
00004d 2045
00004e 4f44
00004f 0a53
000050 0000                      msgStateDos:	.db "STATE DOS",'\n','\0','\0'		
000051 5453
000052 5441
000053 2045
000054 5254
000055 5345
000056 000a                      msgStateTres:	.db "STATE TRES",'\n','\0'	
000057 5453
000058 5441
000059 2045
00005a 5543
00005b 5441
00005c 4f52                      msgStateCuatro:	.db "STATE CUATRO"
00005d 5453
00005e 5441
00005f 2045
000060 4943
000061 434e
000062 0a4f                      msgStateCinco:	.db "STATE CINCO",'\n'	
000063 5453
000064 5441
000065 2045
000066 4553
000067 5349
000068 000a                      msgStateSeis:	.db "STATE SEIS",'\n','\0'	
000069 5453
00006a 5441
00006b 2045
00006c 4953
00006d 5445
00006e 0a45                      msgStateSiete:	.db "STATE SIETE",'\n'	
00006f 5453
000070 5441
000071 2045
000072 434f
000073 4f48
000074 000a                      msgStateOcho:	.db "STATE OCHO",'\n','\0'
000075 5453
000076 5441
000077 2045
000078 554e
000079 5645
00007a 0a45                      msgStateNueve:	.db "STATE NUEVE",'\n'	
00007b 5453
00007c 5441
00007d 2045
00007e 4944
00007f 5a45
000080 000a                      msgStateDiez:	.db "STATE DIEZ",'\n','\0'	
                                 
                                 ;-----------------------------------------------------------------------------------------------------------------------------------------------
                                 
                                 ;INTERRUPCIONES
                                 
                                 TIMER0_OVF:					;interrupcion a la que va a entrar 1 de 256 clocks (prescaler)
                                 
000081 b62f                      	in		r2,SREG			;cargo en r2 todos los valores de SREG, el cual me guarda todos los estados de las banderas del micro (registro de estado) //SREG = STATUS REGISTER, En donde en cada bit tiene los registros del micro, como la C, Z, etc.
000082 922f                      	push	r2				;guardo el estado de SREG en la pila para no tener alteraciones por la interrupcion 
000083 930f                      	push	r16				;como es una interrupcion guardo el valor de r16 por si tenia algo guardado
                                 	
000084 9100 015f                 	lds		r16,time10ms	;Cargo 1 byte (time10ms) directamente desde el espacio de datos 
000086 950a                      	dec		r16				;Decremento en 1 el r16, que vale 5 (Ver en "START"). Como a la interrupcion entrar cada 2ms, 2x5=10ms
000087 9300 015f                 	sts		time10ms,r16	;Almaceno directamente en el espacio de datos, es decir, voy decrementando y cargandole el nuevo valor a time10ms, que ir desde 5 a 0
                                 
000089 f421                      	brne	OUT_TIMER0_OVF	;entra a esta funcion siempre que time10ms no haya llegado a 0
                                 
                                 	;si dio 0 hago lo siguiente ,osea que llego a los 10ms
                                 
00008a 9af5                      	sbi		GPIOR0, IS10MS	;seteo en 1 el bit 5 de gpior0 (indica si pasaron los 10ms)
00008b e005                      	ldi		r16,5			;Vuelvo a cargar el valor 5 para que se vuelvan a repetir los 10ms
00008c 9300 015f                 	sts		time10ms,r16	;reincio el contador en 5 (cantidad de veces que necesito para que cuente 10ms)
                                 
                                 OUT_TIMER0_OVF:				;vuelvo a recuperar los datos guardados en la pila para que se sigan utilzando en el programa
                                 	
00008e 910f                      	pop		r16
00008f 902f                      	pop		r2
000090 be2f                      	out		SREG,r2			;devuelve el estado origianl de SREG (porque usamos la bandera z en la interrupcion)
000091 9518                      	reti
                                 
                                 
                                 /*Interrupcin USART_RXC
                                 Guarda el dato recibido en bufRX y actualiza el ndice de escritura iwRX.
                                 Usa un buffer circular para evitar sobreescrituras.*/
                                 
                                 USART_RXC:
000092 b62f                          in		r2, SREG ; Guardar el estado de SREG y agrego a la pila los registros que voy a utilizar en la interrupcion para no perderlos cuando termine la interrupcion
000093 922f                          push    r2
000094 930f                          push    r16
000095 931f                          push    r17
000096 93af                          push    r26
000097 93bf                          push    r27
                                 
                                 	; Calcular la direccin en bufRX para almacenar el dato recibido
000098 e1ab                          ldi		r26, low(bufRX)
000099 e0b1                          ldi		r27, high(bufRX)
00009a 9100 013b                     lds		r16, iwRX			;Leer ndice de escritura RX
00009c 2711                          clr		r17
00009d 0fa0                          add		r26, r16
00009e 1fb1                          adc		r27, r17 
                                 	; Guardar el dato recibido en el buffer
00009f 9110 00c6                     lds		r17, UDR0			; Leer dato del USART
0000a1 931c                          st		X, r17				; Almacenar en buffer RX
                                 
                                 	; Incrementar ndice circular de escritura
0000a2 9503                          inc		r16
0000a3 710f                          andi    r16, BUFSIZERX-1	; Mantener dentro del rango del buffer
0000a4 9300 013b                     sts		iwRX, r16
                                 
                                 OUT_USART_RXC:
0000a6 91bf                          pop		r27
0000a7 91af                          pop		r26
0000a8 911f                          pop		r17
0000a9 910f                          pop		r16
0000aa 902f                          pop		r2
0000ab be2f                          out		SREG, r2	; Restaurar SREG
0000ac 9518                          reti				; Retornar de la interrupcin
                                 
                                 
                                 ;constantes
                                 //consts:		.DB 0, 255, 0b01010101, -128, 0xaa
0000ad 0000 0000
0000af babe fade
0000b1 0000 8000
0000b3 0000 4000                 varlist:	.DD 0, 0xfadebabe, -2147483648, 1 << 30
                                 
                                 ;************************************** Funciones **************************************
                                 
                                 ;****** Inicializar Puertos ******
                                 ini_ports:
                                 	
0000b5 e200                      	ldi		r16, (0 << SW0) | (1 << LEDBUILTIN) 
0000b6 b904                      	out		DDRB,r16 
0000b7 e100                      	ldi		r16, (1 << SW0) 
0000b8 b905                      	out		PORTB, r16 
0000b9 9508                      	ret
                                 
                                 
                                 ;***** Inicializar Timer ******
                                 ini_timer:
                                 
0000ba e002                      	ldi		r16, (1<<WGM01)	//0b00000010 - timer en modo CTC (WGM01 = 1, WGM00 = 0)
0000bb bd04                      	out		TCCR0A, r16
                                 
0000bc 2700                      	clr		r16				//Como TCNT0 y TIFR0 tienen el valor 0b00000000 (es decir 0), directamente limpio el registro para que quede en 0 y se los cargo
0000bd bd06                      	out		TCNT0, r16		//TCNT0 reinicia el contador, por eso es necesario ponerlo en 0
0000be bb05                      	out		TIFR0, r16
                                 
0000bf e002                      	ldi		r16, (1 << OCIE0A)	//0b00000010. Habilitar interrupcin por comparacin OCR0A
0000c0 9300 006e                 	sts		TIMSK0, r16
                                 
0000c2 e004                      	ldi		r16, (1<<CS02)	//0b00000100	cargo el prescaler en 256
0000c3 bd05                      	out		TCCR0B, r16
                                 
0000c4 e70c                      	ldi		r16, 124	//Valor para generar 2ms (ver en word)
0000c5 bd07                      	out		OCR0A ,r16
                                 
0000c6 9508                      	ret
                                 
                                 ;********** Inicializacin USART **********
                                 
                                 /*Configura el USART a 115200 baudios, 8N1
                                 Configura USART a 115200 baudios, 8 bits, sin paridad, 1 stop bit.
                                 Habilita TX, RX e interrupcin RX.*/
                                 
                                 ini_USART0:
0000c7 ef0e                          ldi		r16, 0xFE		; Doble velocidad habilitada (U2X0)
0000c8 9300 00c0                     sts		UCSR0A, r16
0000ca e908                          ldi		r16, (1 << RXCIE0) | (1 << RXEN0) | (1 << TXEN0) ; Habilitar TX, RX e interrupcin RX
0000cb 9300 00c1                     sts		UCSR0B, r16
0000cd e006                          ldi		r16, 0x06		; Configurar 8N1 (8 bits, sin paridad, 1 stop bit)
0000ce 9300 00c2                     sts		UCSR0C, r16
0000d0 e100                          ldi		r16, 16			; Baud rate para 115200 con fclk=16MHz // Configurar baud rate (115200 baudios a 16MHz)
0000d1 9300 00c4                     sts		UBRR0L, r16
0000d3 9300 00c4                     sts		UBRR0L, r16
0000d5 e000                          ldi		r16, 0
0000d6 9300 00c5                     sts		UBRR0H, r16
0000d8 9508                          ret
                                 
                                 ;Enviar texto constante por USART 
                                 PutConstTextOnBufTX:
0000d9 930f                          push    r16
0000da 931f                          push    r17
0000db 93af                          push    r26
0000dc 93bf                          push    r27
0000dd 9100 015d                     lds		r16, iwTX			; Leer ndice de escritura TX
                                 
                                 nextByteText:
0000df e0b1                          ldi		r27, high(bufTX)
0000e0 e3ad                          ldi		r26, low(bufTX)
0000e1 0fa0                          add		r26, r16
0000e2 f408                          brcc	PC+2
0000e3 5fbf                          subi	r27, -1
0000e4 9503                          inc		r16
0000e5 710f                          andi    r16, BUFSIZETX-1	; Mantener dentro del buffer
                                 
0000e6 9115                          lpm		r17, Z+				; Cargar siguiente carcter del mensaje
0000e7 3010                          cpi		r17, '\0'			; Es el final de la cadena?
0000e8 f011                          breq	outPutConstText		; Si es el final de la cadena entonces voy a outputconstText
0000e9 931c                          st		X, r17				; Almacenar en buffer TX
0000ea f7a1                          brne	nextByteText		; Repetir si no ha terminado
                                 
                                 outPutConstText:
0000eb 950a                          dec		r16
0000ec 710f                          andi	r16, BUFSIZETX-1
0000ed 9300 015d                     sts		iwTX, r16
0000ef 91bf                          pop		r27
0000f0 91af                          pop		r26
0000f1 911f                          pop		r17
0000f2 910f                          pop		r16
0000f3 9508                          ret
                                 
                                 ;Procesar datos recibidos
                                 /*Procesamiento de recepcin doRX
                                 Verifica si se recibi una 'T' y si es as, llama a PutConstTextOnBufTX para enviar "TEST". Y demas instrucciones */
                                 
                                 doRX:
0000f4 9100 013c                     lds		r16, irRX
0000f6 e1ab                          ldi		r26, low(bufRX)
0000f7 e0b1                          ldi		r27, high(bufRX)
0000f8 2711                          clr		r17
0000f9 0fa0                          add		r26, r16
0000fa 1fb1                          adc		r27, r17
0000fb 9503                          inc		r16
0000fc 710f                          andi	r16, BUFSIZERX-1
0000fd 9300 013c                     sts		irRX, r16
0000ff 910c                          ld		r16, X		; Leer dato recibido
                                 
                                 doRX_V:	;if 'V' is received, the firmware version is answered  
000100 3506                      	cpi		r16, 'V'
000101 f009                      	breq	PC+2
000102 c005                      	rjmp	doRX_T
000103 e6e8                      	ldi		r30, low(version << 1)
000104 e0f0                      	ldi		r31, high(version << 1)
000105 940e 00d9                 	call	PutConstTextOnBufTX
000107 9508                      	ret
                                 
                                 doRX_T: ; Si se recibe 'T', se responde con "TEST"
000108 3504                      	cpi		r16, 'T'
000109 f009                      	breq	PC+2
00010a c005                      	rjmp	doRX_S
00010b e7e8                          ldi		r30, low(msgTest << 1)
00010c e0f0                          ldi		r31, high(msgTest << 1)
00010d 940e 00d9                     call	PutConstTextOnBufTX
00010f 9508                          ret
                                 
                                 doRX_S: ;if 'S' is received, change ledState
000110 3503                      	cpi		r16, 'S' 
000111 f009                      	breq	PC+2 //Si el caracter recibido es S, voy 2 lineas mas adelante, es decir a LDS 
000112 9508                      	ret
                                 
000113 9100 0166                 	lds		r16, ledState+1				//leo el estado actual del led. (En un principio ledstate+3 posee 0x80)
000115 3a0a                      	cpi		r16, 0xAA					//Comparo, si el estado del led es DIEZ, entonces cambio a IDLE 
000116 f449                      	brne	setNewStateRX_s					//si son iguales, seteo un nuevo estado. Es decir. Si estaba en IDLE paso a un nuevo estado. Sino. si es que no estaba en IDLE, voy a IDLE 
                                 
000117 e7ee                      	ldi		r30, low(msgStateIdle << 1)	
000118 e0f0                      	ldi		r31, high(msgStateIdle << 1)
000119 940e 00d9                 	call	PutConstTextOnBufTX
                                 
                                 	//Cargo el estado "IDLE"
00011b e000                      	ldi		r16, low(STATEIDLE)		//STATEIDLE = 0x80000000 
00011c e010                      	ldi		r17, high(STATEIDLE)
00011d e020                      	ldi		r18, byte3(STATEIDLE)
00011e e830                      	ldi		r19, byte4(STATEIDLE)
00011f c0c8                      	rjmp	outNewState
                                 
                                 ; Cargo el nuevo estado "STATEx" a los registros
                                 setNewStateRX_s:
                                 	
000120 e8ea                      	ldi		r30, low(msgStateUno << 1)
000121 e0f0                      	ldi		r31, high(msgStateUno << 1)
000122 940e 00d9                 	call	PutConstTextOnBufTX
                                 
000124 9100 0169                 	lds		r16, ledLastState
000126 9503                      	inc		r16
000127 9300 0169                 	sts		ledLastState, r16
                                 
000129 3001                      	cpi		r16, 1
00012a f091                      	breq	SetStateUNO_RXs
00012b 3002                      	cpi		r16, 2
00012c f0a9                      	breq	SetStateDOS_RXs
00012d 3003                      	cpi		r16, 3
00012e f0c1                      	breq	SetStateTRES_RXs
00012f 3004                      	cpi		r16, 4
000130 f0d9                      	breq	SetStateCUATRO_RXs
000131 3005                      	cpi		r16, 5
000132 f0f1                      	breq	SetStateCINCO_RXs
000133 3006                      	cpi		r16, 6
000134 f109                      	breq	SetStateSEIS_RXs
000135 3007                      	cpi		r16, 7
000136 f121                      	breq	SetStateSIETE_RXs
000137 3008                      	cpi		r16, 8
000138 f139                      	breq	SetStateOCHO_RXs
000139 3009                      	cpi		r16, 9
00013a f151                      	breq	SetStateNUEVE_RXs
00013b 300a                      	cpi		r16, 10
00013c f169                      	breq	SetStateDIEZ_RXs
                                 
                                 SetStateUNO_RXs:
00013d e000                      	ldi		r16, low(STATEUNO)		
00013e e010                      	ldi		r17, high(STATEUNO)
00013f e020                      	ldi		r18, byte3(STATEUNO)
000140 ef31                      	ldi		r19, byte4(STATEUNO)
                                 
000141 c0a6                      	rjmp	outNewState
                                 
                                 SetStateDOS_RXs:
000142 e000                      	ldi		r16, low(STATEDOS)		
000143 e010                      	ldi		r17, high(STATEDOS)
000144 e120                      	ldi		r18, byte3(STATEDOS)
000145 ef31                      	ldi		r19, byte4(STATEDOS)
                                 
000146 c0a1                      	rjmp	outNewState
                                 
                                 SetStateTRES_RXs:
000147 e000                      	ldi		r16, low(STATETRES)		
000148 e010                      	ldi		r17, high(STATETRES)
000149 e121                      	ldi		r18, byte3(STATETRES)
00014a ef31                      	ldi		r19, byte4(STATETRES)
                                 
00014b c09c                      	rjmp	outNewState
                                 
                                 SetStateCUATRO_RXs:
00014c e000                      	ldi		r16, low(STATECUATRO)		
00014d e110                      	ldi		r17, high(STATECUATRO)
00014e e121                      	ldi		r18, byte3(STATECUATRO)
00014f ef31                      	ldi		r19, byte4(STATECUATRO)
                                 
000150 c097                      	rjmp	outNewState
                                 	
                                 SetStateCINCO_RXs:
000151 e000                      	ldi		r16, low(STATECINCO)		
000152 e111                      	ldi		r17, high(STATECINCO)
000153 e121                      	ldi		r18, byte3(STATECINCO)
000154 ef31                      	ldi		r19, byte4(STATECINCO)
                                 
000155 c092                      	rjmp	outNewState
                                 
                                 SetStateSEIS_RXs:
000156 e000                      	ldi		r16, low(STATESEIS)		
000157 e010                      	ldi		r17, high(STATESEIS)
000158 e420                      	ldi		r18, byte3(STATESEIS)
000159 ef31                      	ldi		r19, byte4(STATESEIS)
                                 
00015a c08d                      	rjmp	outNewState
                                 
                                 SetStateSIETE_RXs:
00015b e000                      	ldi		r16, low(STATESIETE)		
00015c e810                      	ldi		r17, high(STATESIETE)
00015d e420                      	ldi		r18, byte3(STATESIETE)
00015e ef31                      	ldi		r19, byte4(STATESIETE)
                                 
00015f c088                      	rjmp	outNewState
                                 
                                 SetStateOCHO_RXs:
000160 e000                      	ldi		r16, low(STATEOCHO)		
000161 ea10                      	ldi		r17, high(STATEOCHO)
000162 e420                      	ldi		r18, byte3(STATEOCHO)
000163 ef31                      	ldi		r19, byte4(STATEOCHO)
                                 
000164 c083                      	rjmp	outNewState
                                 
                                 SetStateNUEVE_RXs:
000165 e000                      	ldi		r16, low(STATENUEVE)		
000166 ea18                      	ldi		r17, high(STATENUEVE)
000167 e420                      	ldi		r18, byte3(STATENUEVE)
000168 ef31                      	ldi		r19, byte4(STATENUEVE)
                                 
000169 c07e                      	rjmp	outNewState
                                 
                                 SetStateDIEZ_RXs:
00016a e000                      	ldi		r16, low(STATEDIEZ)		
00016b ea1a                      	ldi		r17, high(STATEDIEZ)
00016c e420                      	ldi		r18, byte3(STATEDIEZ)
00016d ef31                      	ldi		r19, byte4(STATEDIEZ)
                                 
00016e e090                      	ldi		r25, 0
00016f 9390 0169                 	sts		ledLastState, r25
                                 
000171 c076                      	rjmp	outNewState
                                 
                                 ///////////////////////////////////////////////////////////////////////////////////////////////////////
                                 ;Manejo la deteccin de un botn con antirrebote (debounce)
                                 
                                 doSW0:
000172 9100 016a                 	lds		r16, dbSW0
000174 99f0                      	sbic	GPIOR0, LASTSTATESW0	
000175 c004                      	rjmp	testLowSW0
000176 9b1c                      	sbis	PINB, SW0				
000177 c006                      	rjmp	doSW0db1
000178 9af0                      	sbi		GPIOR0, LASTSTATESW0	
000179 c003                      	rjmp	doSW0db0
                                 
                                 testLowSW0:
00017a 991c                      	sbic	PINB, SW0
00017b c002                      	rjmp	doSW0db1
00017c 98f0                      	cbi		GPIOR0, LASTSTATESW0
                                 
                                 ;Anti-rebote
                                 //Si detecta un cambio en el botn, inicia el debounce cargando r16 = 6.
                                 doSW0db0:
00017d e006                      	ldi		r16, 6
                                 
                                 /*Cada vez que se llama a esta funcin, r16 se va decrementando.
                                 Cuando r16 llega a 0, confirma el nuevo estado del botn y activa ISNEWSTATESW0.*/
                                 doSW0db1:
00017e 2300                      	tst		r16				//Verifica si r16 es 0
00017f f019                      	breq	outDoSW0
000180 950a                      	dec		r16
000181 f409                      	brne	outDoSW0
000182 9af7                      	sbi		GPIOR0, ISNEWSTATESW0	
                                 
                                 outDoSW0:
000183 9300 016a                 	sts		dbSW0, r16
000185 9508                      	ret
                                 
                                 ////////////////////////////////////////////////////////////////////////////////////////////////////////
                                 	
                                 ; Cambio el estado del led cuando se presiona el boton. 
                                 doNewStateSW0:
000186 98f7                      	cbi		GPIOR0, ISNEWSTATESW0		//limpio el bit 7 de GPIOR0
000187 99f0                      	sbic	GPIOR0, LASTSTATESW0		//Si el bit0 (LASTSTATESW0) es 0 (boton apretado) entonces salteo la siguiente instruccion y cambio el estado del led
000188 9508                      	ret
000189 9100 0166                 	lds		r16, ledState+1				//leo el estado actual del led. (En un principio ledstate+3 posee 0x80)
00018b 3a0a                      	cpi		r16, 0xAA					//Comparo, si el estado del led es DIEZ, entonces cambio a IDLE 
00018c f449                      	brne	setNewState					//si son iguales, seteo un nuevo estado. Es decir. Si estaba en IDLE paso a un nuevo estado. Sino. si es que no estaba en IDLE, voy a IDLE 
                                 
00018d e7ee                      	ldi		r30, low(msgStateIdle << 1)	
00018e e0f0                      	ldi		r31, high(msgStateIdle << 1)
00018f 940e 00d9                 	call	PutConstTextOnBufTX
                                 
                                 	//Cargo el estado "IDLE"
000191 e000                      	ldi		r16, low(STATEIDLE)		//STATEIDLE = 0x80000000 
000192 e010                      	ldi		r17, high(STATEIDLE)
000193 e020                      	ldi		r18, byte3(STATEIDLE)
000194 e830                      	ldi		r19, byte4(STATEIDLE)
000195 c052                      	rjmp	outNewState
                                 
                                 ; Cargo el nuevo estado "STATEx" a los registros
                                 setNewState:
000196 e8ea                      	ldi		r30, low(msgStateUno << 1)
000197 e0f0                      	ldi		r31, high(msgStateUno << 1)
000198 940e 00d9                 	call	PutConstTextOnBufTX
                                 
00019a 9100 0169                 	lds		r16, ledLastState
00019c 9503                      	inc		r16
00019d 9300 0169                 	sts		ledLastState, r16
                                 
00019f 3001                      	cpi		r16, 1
0001a0 f091                      	breq	SetStateUNO
0001a1 3002                      	cpi		r16, 2
0001a2 f0a9                      	breq	SetStateDOS
0001a3 3003                      	cpi		r16, 3
0001a4 f0c1                      	breq	SetStateTRES
0001a5 3004                      	cpi		r16, 4
0001a6 f0d9                      	breq	SetStateCUATRO
0001a7 3005                      	cpi		r16, 5
0001a8 f0f1                      	breq	SetStateCINCO
0001a9 3006                      	cpi		r16, 6
0001aa f109                      	breq	SetStateSEIS
0001ab 3007                      	cpi		r16, 7
0001ac f121                      	breq	SetStateSIETE
0001ad 3008                      	cpi		r16, 8
0001ae f139                      	breq	SetStateOCHO
0001af 3009                      	cpi		r16, 9
0001b0 f151                      	breq	SetStateNUEVE
0001b1 300a                      	cpi		r16, 10
0001b2 f169                      	breq	SetStateDIEZ
                                 
                                 SetStateUNO:
0001b3 e000                      	ldi		r16, low(STATEUNO)		
0001b4 e010                      	ldi		r17, high(STATEUNO)
0001b5 e020                      	ldi		r18, byte3(STATEUNO)
0001b6 ef31                      	ldi		r19, byte4(STATEUNO)
                                 
0001b7 c030                      	rjmp	outNewState
                                 
                                 SetStateDOS:
0001b8 e000                      	ldi		r16, low(STATEDOS)		
0001b9 e010                      	ldi		r17, high(STATEDOS)
0001ba e120                      	ldi		r18, byte3(STATEDOS)
0001bb ef31                      	ldi		r19, byte4(STATEDOS)
                                 
0001bc c02b                      	rjmp	outNewState
                                 
                                 SetStateTRES:
0001bd e000                      	ldi		r16, low(STATETRES)		
0001be e010                      	ldi		r17, high(STATETRES)
0001bf e121                      	ldi		r18, byte3(STATETRES)
0001c0 ef31                      	ldi		r19, byte4(STATETRES)
                                 
0001c1 c026                      	rjmp	outNewState
                                 
                                 SetStateCUATRO:
0001c2 e000                      	ldi		r16, low(STATECUATRO)		
0001c3 e110                      	ldi		r17, high(STATECUATRO)
0001c4 e121                      	ldi		r18, byte3(STATECUATRO)
0001c5 ef31                      	ldi		r19, byte4(STATECUATRO)
                                 
0001c6 c021                      	rjmp	outNewState
                                 	
                                 SetStateCINCO:
0001c7 e000                      	ldi		r16, low(STATECINCO)		
0001c8 e111                      	ldi		r17, high(STATECINCO)
0001c9 e121                      	ldi		r18, byte3(STATECINCO)
0001ca ef31                      	ldi		r19, byte4(STATECINCO)
                                 
0001cb c01c                      	rjmp	outNewState
                                 
                                 SetStateSEIS:
0001cc e000                      	ldi		r16, low(STATESEIS)		
0001cd e010                      	ldi		r17, high(STATESEIS)
0001ce e420                      	ldi		r18, byte3(STATESEIS)
0001cf ef31                      	ldi		r19, byte4(STATESEIS)
                                 
0001d0 c017                      	rjmp	outNewState
                                 
                                 SetStateSIETE:
0001d1 e000                      	ldi		r16, low(STATESIETE)		
0001d2 e810                      	ldi		r17, high(STATESIETE)
0001d3 e420                      	ldi		r18, byte3(STATESIETE)
0001d4 ef31                      	ldi		r19, byte4(STATESIETE)
                                 
0001d5 c012                      	rjmp	outNewState
                                 
                                 SetStateOCHO:
0001d6 e000                      	ldi		r16, low(STATEOCHO)		
0001d7 ea10                      	ldi		r17, high(STATEOCHO)
0001d8 e420                      	ldi		r18, byte3(STATEOCHO)
0001d9 ef31                      	ldi		r19, byte4(STATEOCHO)
                                 
0001da c00d                      	rjmp	outNewState
                                 
                                 SetStateNUEVE:
0001db e000                      	ldi		r16, low(STATENUEVE)		
0001dc ea18                      	ldi		r17, high(STATENUEVE)
0001dd e420                      	ldi		r18, byte3(STATENUEVE)
0001de ef31                      	ldi		r19, byte4(STATENUEVE)
                                 
0001df c008                      	rjmp	outNewState
                                 
                                 SetStateDIEZ:
0001e0 e000                      	ldi		r16, low(STATEDIEZ)		
0001e1 ea1a                      	ldi		r17, high(STATEDIEZ)
0001e2 e420                      	ldi		r18, byte3(STATEDIEZ)
0001e3 ef31                      	ldi		r19, byte4(STATEDIEZ)
                                 
0001e4 e090                      	ldi		r25, 0
0001e5 9390 0169                 	sts		ledLastState, r25
                                 
0001e7 c000                      	rjmp	outNewState
                                 
                                 ; Cargo al ledstate 
                                 outNewState:
0001e8 9300 0165                 	sts		ledState+0, r16
0001ea 9310 0166                 	sts		ledState+1, r17
0001ec 9320 0167                 	sts		ledState+2, r18
0001ee 9330 0168                 	sts		ledState+3, r19
0001f0 9508                      	ret
                                 
                                 ////////////////////////////////////////////////////////////////////////////////////////////////////////
                                 
                                 do100ms:
0001f1 9100 0160                 	lds		r16, time100ms
0001f3 950a                      	dec		r16
0001f4 9300 0160                 	sts		time100ms, r16
0001f6 f009                      	breq	PC+2				// "Program Counter + 2", Salto dos direcciones, si no llego a 0, me voy (ret). Si llego a 0 salteo 2 instrucciones y voy al ldi
0001f7 9508                      	ret
                                 
0001f8 e00a                      	ldi		r16, 10
0001f9 9300 0160                 	sts		time100ms, r16
                                 
0001fb 90c0 0161                 	lds		r12, maskState+0	
0001fd 90d0 0162                 	lds		r13, maskState+1	
0001ff 90e0 0163                 	lds		r14, maskState+2
000201 90f0 0164                 	lds		r15, maskState+3	
                                 	
000203 9080 0165                 	lds		r8, ledState+0		//0x00
000205 9090 0166                 	lds		r9, ledState+1		//0x00
000207 90a0 0167                 	lds		r10, ledState+2		//0x00
000209 90b0 0168                 	lds		r11, ledState+3		//0x80
                                 
00020b 208c                      	and		r8, r12		
00020c 209d                      	and		r9, r13		
00020d 20ae                      	and		r10, r14	
00020e 20bf                      	and		r11, r15	
00020f 2889                      	or		r8, r9
000210 28ab                      	or		r10, r11
000211 288a                      	or		r8, r10 
                                 
000212 f011                      	breq	ledOff				; Si r8 es 0, el LED debe apagarse, de lo contrario, debe encenderse.
                                 
000213 9a2d                      	sbi		PORTB, LEDBUILTIN	; led ON
000214 c001                      	rjmp	saveMask
                                 
                                 ledOff:
000215 982d                      	cbi		PORTB, LEDBUILTIN	;led Off
                                 
                                 ; La mscara se rota en cada ejecucin de do100ms, lo que significa que cada 100 ms se desplaza la posicin del bit activo en maskState.
                                 saveMask:
                                 								/*	roto cada registro de maskState, desplazando los bits hacia la derecha.
                                 									en el momento 1, pasamos de:		  a:			y tiene que llegar a:
                                 													r12:	00000000	|	00000000	|	00000001
                                 													r13:	00000000	|	00000000	|	00000000
                                 													r14:	00000000	|	00000000	|	00000000	
                                 													r15:	10000000	|	01000000	|	00000000	
                                 									Por lo que Cada 100 ms, la mscara se rota una posicin a la derecha. La mscara tiene 4 registros de 8 bits (32 bits en total).
                                 									Se necesitan 32 rotaciones para que el bit 1 desaparezca completamente y se reinicie la mscara.
                                 									32  100 ms = 3,2 s antes de que el LED se vuelva a encender.	*/
                                 
000216 9488                      	clc							//Borra el flag de carry (C) antes de la rotacin.
                                 
000217 94f7                      	ror		r15						
000218 94e7                      	ror		r14					
000219 94d7                      	ror		r13					
00021a 94c7                      	ror		r12		
                                 
                                 	// Si el carry est en 0 (el ltimo bit de r12 era 1 antes de ROR), el cdigo carga 0x80 (10000000) en r15 para reiniciar la rotacin cuando la mscara llega a 00000001. Sino, si el carry est en 1 salteo 2 instrucciones
00021b f410                      	brcc	PC+3
00021c e800                      	ldi		r16, 0x80
00021d 2ef0                      	mov		r15, r16
                                 
                                 	//almaceno la mascara actualizada
00021e 92c0 0161                 	sts		maskState+0, r12
000220 92d0 0162                 	sts		maskState+1, r13
000222 92e0 0163                 	sts		maskState+2, r14
000224 92f0 0164                 	sts		maskState+3, r15
000226 9508                      	ret
                                 
                                 ;************************************** Like a main in C **************************************
                                 start:
000227 94f8                          cli
                                 
                                 ;Inicializacion de la SRAM
000228 ef0f                          ldi		r16, low(RAMEND)
000229 bf0d                          out		SPL, r16
00022a e008                          ldi		r16, HIGH(RAMEND)
00022b bf0e                          out		SPH, r16
                                 
                                 ;Llamo las inicializaciones
00022c 940e 00b5                     call	ini_ports
00022e 940e 00ba                     call	ini_timer
000230 940e 00c7                     call	ini_USART0
                                 
                                 ;cargo 0 para inicializar variables
000232 2700                      	clr		r16
000233 bb0e                      	out		GPIOR0,r16			//Pongo en 0 la bandera
                                 
000234 9300 013b                 	sts		iwRX, r16
000236 9300 013c                 	sts		irRX, r16
000238 9300 015d                 	sts		iwTX, r16
00023a 9300 015e                 	sts		irTX, r16
                                 	
00023c 9300 0161                 	sts		maskState+0, r16
00023e 9300 0162                 	sts		maskState+1, r16
000240 9300 0163                 	sts		maskState+2, r16
                                 
000242 9300 0169                 	sts		ledLastState, r16
                                 
000244 e800                      	ldi		r16, 0x80
000245 9300 0164                 	sts		maskState+3, r16
                                 
                                 ;Activo el estado IDLE desde el arranque
000247 e000                      	ldi		r16, low(STATEDIEZ)		// Cargo byte 1. 0x00
000248 9300 0165                 	sts		ledstate+0, r16
00024a ea0a                      	ldi		r16, high(STATEDIEZ)	// Cargo byte 2. 0x00
00024b 9300 0166                 	sts		ledstate+1, r16
00024d e400                      	ldi		r16, byte3(STATEDIEZ)	// Cargo byte 3. 0x00
00024e 9300 0167                 	sts		ledstate+2, r16
000250 ef01                      	ldi		r16, byte4(STATEDIEZ)	// Cargo byte 4. 0x80
000251 9300 0168                 	sts		ledstate+3, r16
                                 
000253 e005                      	ldi		r16, 5
000254 9300 015f                 	sts		time10ms, r16
000256 e00a                      	ldi		r16,10
000257 9300 0160                 	sts		time100ms,r16
                                 
000259 9478                      	sei
                                 
                                 loop:
00025a 9bf5                      	sbis	GPIOR0, IS10MS  // This instruction tests a single bit in an I/O Register and skips the next instruction if the bit is set.
00025b c008                      	rjmp	testBufRX
                                 
                                 ;Entra en esta parte cada 10ms
00025c 98f5                      	cbi		GPIOR0, IS10MS
00025d 940e 01f1                 	call	do100ms
00025f 940e 0172                 	call	doSW0
                                 
000261 99f7                      	sbic	GPIOR0, ISNEWSTATESW0
000262 940e 0186                 	call	doNewStateSW0
                                 
                                 
                                 ; ***************************** USART *****************************
                                 ; Procesar buffer RX
                                 testBufRX:							; Revisa si hay datos en bufRX 
000264 9110 013b                     lds		r17, iwRX
000266 9100 013c                     lds		r16, irRX
000268 1701                          cp		r16, r17
000269 f011                          breq	testBufTX	
00026a 940e 00f4                     call	doRX					; Si se recibio algo, lo procesa en doRx 
                                 
                                 ; Procesar buffer TX
                                 testBufTX:				; Verifica si hay datos en bufTX para enviarlos por USART.
00026c 9110 015d                     lds		r17, iwTX
00026e 9100 015e                     lds		r16, irTX
000270 1701                          cp		r16, r17
000271 f409                          brne	PC+2
000272 940c 025a                     jmp		loop
                                 
                                 ;**** Enviar datos por USART ****
                                 doTX:
000274 9110 00c0                 	lds		r17, UCSR0A
000276 ff15                      	sbrs	r17, UDRE0  ; Esperar hasta que el buffer est libre
000277 940c 025a                 	jmp		loop
000279 e3ad                      	ldi		r26, low(bufTX)
00027a e0b1                      	ldi		r27, high(bufTX)
00027b 2711                      	clr		r17
00027c 0fa0                      	add		r26, r16
00027d 1fb1                      	adc		r27, r17
00027e 9503                      	inc		r16
00027f 710f                      	andi	r16, BUFSIZETX-1
000280 9300 015e                 	sts		irTX, r16
000282 e402                      	ldi		r16, (1 << TXC0) | (1 << U2X0)
000283 9300 00c0                 	sts		UCSR0A, r16
000285 910c                      	ld		r16, X
000286 9300 00c6                 	sts		UDR0, r16


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
x  :   4 y  :   0 z  :   1 r0 :   0 r1 :   0 r2 :   8 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   4 r9 :   3 r10:   4 r11:   3 r12:   4 
r13:   4 r14:   4 r15:   5 r16: 163 r17:  44 r18:  23 r19:  23 r20:   0 
r21:   0 r22:   0 r23:   0 r24:   0 r25:   4 r26:  12 r27:  12 r28:   0 
r29:   0 r30:   6 r31:   6 
Registers used: 20 out of 35 (57.1%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   3 add   :   4 adiw  :   0 and   :   4 
andi  :   5 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   0 break :   0 breq  :  28 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :   6 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  13 cbi   :   4 cbr   :   0 
clc   :   1 clh   :   0 cli   :   1 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   2 cpc   :   0 
cpi   :  26 cpse  :   0 dec   :   4 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   2 inc   :   6 jmp   :   6 
ld    :   2 ldd   :   0 ldi   : 135 lds   :  24 lpm   :   1 lsl   :   0 
lsr   :   0 mov   :   1 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   3 ori   :   0 out   :  12 pop   :  11 
push  :  11 rcall :   0 ret   :  12 reti  :   2 rjmp  :  30 rol   :   0 
ror   :   4 sbc   :   0 sbci  :   0 sbi   :   4 sbic  :   4 sbis  :   2 
sbiw  :   0 sbr   :   0 sbrc  :   0 sbrs  :   1 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   2 std   :   0 sts   :  45 
sub   :   0 subi  :   1 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 40 out of 113 (35.4%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000514   1038    170   1208   32768   3.7%
[.dseg] 0x000100 0x00016b      0    107    107    2048   5.2%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
