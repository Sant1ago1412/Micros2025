
Cinta_Final.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  00001036  000010ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001036  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000027f  0080010a  0080010a  000010d4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000010d4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001104  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000158  00000000  00000000  00001144  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001ba3  00000000  00000000  0000129c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b9a  00000000  00000000  00002e3f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000dab  00000000  00000000  000039d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003d0  00000000  00000000  00004784  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000948  00000000  00000000  00004b54  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000954  00000000  00000000  0000549c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000140  00000000  00000000  00005df0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
       4:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       8:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      28:	0c 94 36 01 	jmp	0x26c	; 0x26c <__vector_10>
      2c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__vector_11>
      30:	0c 94 01 01 	jmp	0x202	; 0x202 <__vector_12>
      34:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      40:	0c 94 7d 01 	jmp	0x2fa	; 0x2fa <__vector_16>
      44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      48:	0c 94 a1 01 	jmp	0x342	; 0x342 <__vector_18>
      4c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      54:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      58:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      5c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      60:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      64:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      68:	4d 03       	fmul	r20, r21
      6a:	5b 03       	fmul	r21, r19
      6c:	73 03       	mulsu	r23, r19
      6e:	88 03       	fmulsu	r16, r16
      70:	9d 03       	fmulsu	r17, r21
      72:	ab 03       	fmulsu	r18, r19
      74:	d0 03       	fmuls	r21, r16

00000076 <__ctors_end>:
      76:	11 24       	eor	r1, r1
      78:	1f be       	out	0x3f, r1	; 63
      7a:	cf ef       	ldi	r28, 0xFF	; 255
      7c:	d8 e0       	ldi	r29, 0x08	; 8
      7e:	de bf       	out	0x3e, r29	; 62
      80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
      82:	11 e0       	ldi	r17, 0x01	; 1
      84:	a0 e0       	ldi	r26, 0x00	; 0
      86:	b1 e0       	ldi	r27, 0x01	; 1
      88:	e6 e3       	ldi	r30, 0x36	; 54
      8a:	f0 e1       	ldi	r31, 0x10	; 16
      8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
      8e:	05 90       	lpm	r0, Z+
      90:	0d 92       	st	X+, r0
      92:	aa 30       	cpi	r26, 0x0A	; 10
      94:	b1 07       	cpc	r27, r17
      96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
      98:	23 e0       	ldi	r18, 0x03	; 3
      9a:	aa e0       	ldi	r26, 0x0A	; 10
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
      a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
      a2:	a9 38       	cpi	r26, 0x89	; 137
      a4:	b2 07       	cpc	r27, r18
      a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
      a8:	0e 94 bf 05 	call	0xb7e	; 0xb7e <main>
      ac:	0c 94 19 08 	jmp	0x1032	; 0x1032 <_exit>

000000b0 <__bad_interrupt>:
      b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <HCSR04_AddNew>:

//variable interna estatica
static _sHCSR04Handle *mySensor;		//puntero a la estructura _sHCSR04Handle. Se usa como variable auxiliar para manipular los datos de los sensores ultrasónicos HCSR04.

unsigned int HCSR04_AddNew(void (*WritePin_HCSR04)(uint8_t value), uint32_t ticks)
{
      b4:	cf 92       	push	r12
      b6:	df 92       	push	r13
      b8:	ef 92       	push	r14
      ba:	ff 92       	push	r15
      bc:	cf 93       	push	r28
      be:	df 93       	push	r29
      c0:	ec 01       	movw	r28, r24
      c2:	6a 01       	movw	r12, r20
      c4:	7b 01       	movw	r14, r22
	mySensor = (_sHCSR04Handle *)malloc(sizeof(_sHCSR04Handle));	//myHandleAux almacena un nuevo sensor dinámicamente, por lo que myHandleAux apunta a la nueva estructura creada.
      c6:	8f e0       	ldi	r24, 0x0F	; 15
      c8:	90 e0       	ldi	r25, 0x00	; 0
      ca:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <malloc>
      ce:	fc 01       	movw	r30, r24
      d0:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
      d4:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>

	mySensor->WritePin = WritePin_HCSR04;
      d8:	d1 83       	std	Z+1, r29	; 0x01
      da:	c0 83       	st	Z, r28
	mySensor->ticks = ticks;
      dc:	c2 86       	std	Z+10, r12	; 0x0a
      de:	d3 86       	std	Z+11, r13	; 0x0b
      e0:	e4 86       	std	Z+12, r14	; 0x0c
      e2:	f5 86       	std	Z+13, r15	; 0x0d
	mySensor->flags.byte = 0;								
      e4:	16 86       	std	Z+14, r1	; 0x0e
	mySensor->lastDistanceUs = 0;
      e6:	11 86       	std	Z+9, r1	; 0x09
      e8:	10 86       	std	Z+8, r1	; 0x08
	mySensor->usTimeRise = 0;
      ea:	15 82       	std	Z+5, r1	; 0x05
      ec:	14 82       	std	Z+4, r1	; 0x04
	mySensor->usTimeFall = 0;
      ee:	17 82       	std	Z+7, r1	; 0x07
      f0:	16 82       	std	Z+6, r1	; 0x06
	mySensor->WritePin(0);		
      f2:	80 e0       	ldi	r24, 0x00	; 0
      f4:	fe 01       	movw	r30, r28
      f6:	09 95       	icall
	
	return (unsigned int)mySensor;
}
      f8:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <__data_end>
      fc:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <__data_end+0x1>
     100:	df 91       	pop	r29
     102:	cf 91       	pop	r28
     104:	ff 90       	pop	r15
     106:	ef 90       	pop	r14
     108:	df 90       	pop	r13
     10a:	cf 90       	pop	r12
     10c:	08 95       	ret

0000010e <HCSR04_Start>:
//}


void HCSR04_Start(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     10e:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     112:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
	
	mySensor->WritePin(1);					
     116:	dc 01       	movw	r26, r24
     118:	ed 91       	ld	r30, X+
     11a:	fc 91       	ld	r31, X
     11c:	81 e0       	ldi	r24, 0x01	; 1
     11e:	09 95       	icall
     120:	08 95       	ret

00000122 <HCSR04_TriggerReady>:
	
}

void HCSR04_TriggerReady(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     122:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     126:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>
	
	mySensor->WritePin(0);
     12a:	dc 01       	movw	r26, r24
     12c:	ed 91       	ld	r30, X+
     12e:	fc 91       	ld	r31, X
     130:	80 e0       	ldi	r24, 0x00	; 0
     132:	09 95       	icall
     134:	08 95       	ret

00000136 <HCSR04_RiseEdgeTime>:
}

void HCSR04_RiseEdgeTime(unsigned int handleHCSR04, uint16_t usTimeRise)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     136:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     13a:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>

	mySensor->usTimeRise = usTimeRise;	//Cargo cuando se pone en RISE
     13e:	fc 01       	movw	r30, r24
     140:	75 83       	std	Z+5, r23	; 0x05
     142:	64 83       	std	Z+4, r22	; 0x04
	mySensor->flags.byte = 0;
     144:	16 86       	std	Z+14, r1	; 0x0e
     146:	08 95       	ret

00000148 <HCSR04_FallEdgeTime>:

}

void HCSR04_FallEdgeTime(unsigned int handleHCSR04, uint16_t usTimeFall)
{
     148:	fc 01       	movw	r30, r24
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     14a:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <__data_end+0x1>
     14e:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__data_end>

	mySensor->usTimeFall = usTimeFall;	//Cargo cuando se pone en Fall 
     152:	77 83       	std	Z+7, r23	; 0x07
     154:	66 83       	std	Z+6, r22	; 0x06
	mySensor->flags.bit.EDGEREADY = 1;
     156:	86 85       	ldd	r24, Z+14	; 0x0e
     158:	81 60       	ori	r24, 0x01	; 1
     15a:	86 87       	std	Z+14, r24	; 0x0e
     15c:	08 95       	ret

0000015e <task_HCSR>:
	
}

void task_HCSR()
{
	if (mySensor != NULL)
     15e:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <__data_end>
     162:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <__data_end+0x1>
     166:	30 97       	sbiw	r30, 0x00	; 0
     168:	11 f1       	breq	.+68     	; 0x1ae <task_HCSR+0x50>
	{
		if (mySensor->flags.bit.EDGEREADY) //¿el sensor midió? Esto indica que ya se recibieron los dos flancos (rising y falling) y se puede calcular el tiempo que tardó el eco en volver = la distancia.
     16a:	86 85       	ldd	r24, Z+14	; 0x0e
     16c:	80 ff       	sbrs	r24, 0
     16e:	1f c0       	rjmp	.+62     	; 0x1ae <task_HCSR+0x50>
		{
			mySensor->flags.byte = 0;
     170:	16 86       	std	Z+14, r1	; 0x0e
			
			if(mySensor->usTimeRise < mySensor->usTimeFall){ //si no hubo overflow
     172:	24 81       	ldd	r18, Z+4	; 0x04
     174:	35 81       	ldd	r19, Z+5	; 0x05
     176:	86 81       	ldd	r24, Z+6	; 0x06
     178:	97 81       	ldd	r25, Z+7	; 0x07
     17a:	28 17       	cp	r18, r24
     17c:	39 07       	cpc	r19, r25
     17e:	28 f4       	brcc	.+10     	; 0x18a <task_HCSR+0x2c>
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise; //distancia medida
     180:	82 1b       	sub	r24, r18
     182:	93 0b       	sbc	r25, r19
     184:	91 87       	std	Z+9, r25	; 0x09
     186:	80 87       	std	Z+8, r24	; 0x08
     188:	05 c0       	rjmp	.+10     	; 0x194 <task_HCSR+0x36>
				}else{ //hubo overflow
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise + 0xFFFF; //para corregir
     18a:	82 1b       	sub	r24, r18
     18c:	93 0b       	sbc	r25, r19
     18e:	01 97       	sbiw	r24, 0x01	; 1
     190:	91 87       	std	Z+9, r25	; 0x09
     192:	80 87       	std	Z+8, r24	; 0x08
			}
			
			if(mySensor->lastDistanceUs > 11764) //2 metros
     194:	80 85       	ldd	r24, Z+8	; 0x08
     196:	91 85       	ldd	r25, Z+9	; 0x09
     198:	85 3f       	cpi	r24, 0xF5	; 245
     19a:	9d 42       	sbci	r25, 0x2D	; 45
     19c:	20 f0       	brcs	.+8      	; 0x1a6 <task_HCSR+0x48>
				mySensor->lastDistanceUs = 0xFFFF;
     19e:	8f ef       	ldi	r24, 0xFF	; 255
     1a0:	9f ef       	ldi	r25, 0xFF	; 255
     1a2:	91 87       	std	Z+9, r25	; 0x09
     1a4:	80 87       	std	Z+8, r24	; 0x08
			
			sensorMeasure(mySensor->lastDistanceUs);
     1a6:	80 85       	ldd	r24, Z+8	; 0x08
     1a8:	91 85       	ldd	r25, Z+9	; 0x09
     1aa:	0e 94 3f 04 	call	0x87e	; 0x87e <sensorMeasure>
     1ae:	08 95       	ret

000001b0 <WritePin_HCSR>:
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
	}
}

void WritePin_HCSR(uint8_t value){
	if (value)
     1b0:	88 23       	and	r24, r24
     1b2:	21 f0       	breq	.+8      	; 0x1bc <WritePin_HCSR+0xc>
	PORTB |= (1<<TRIGGER);				// Sets a HIGH state (1) in the TRIGGER pin
     1b4:	85 b1       	in	r24, 0x05	; 5
     1b6:	82 60       	ori	r24, 0x02	; 2
     1b8:	85 b9       	out	0x05, r24	; 5
     1ba:	08 95       	ret
	else
	PORTB &= ~(1<<TRIGGER);				// Sets a LOW state (0) in the TRIGGER pin
     1bc:	85 b1       	in	r24, 0x05	; 5
     1be:	8d 7f       	andi	r24, 0xFD	; 253
     1c0:	85 b9       	out	0x05, r24	; 5
     1c2:	08 95       	ret

000001c4 <__vector_11>:

/* END Constant in Flash -----------------------------------------------------*/


/* Function ISR --------------------------------------------------------------*/
ISR(TIMER1_COMPA_vect){
     1c4:	1f 92       	push	r1
     1c6:	0f 92       	push	r0
     1c8:	0f b6       	in	r0, 0x3f	; 63
     1ca:	0f 92       	push	r0
     1cc:	11 24       	eor	r1, r1
     1ce:	8f 93       	push	r24
     1d0:	9f 93       	push	r25
     1d2:	ef 93       	push	r30
     1d4:	ff 93       	push	r31
	
	/*		Con el OCR1B en 20000 , cuento cada 10ms		*/
	IS10MS=TRUE;
     1d6:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     1da:	81 60       	ori	r24, 0x01	; 1
     1dc:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <flag0>
	OCR1A += 19999;
     1e0:	e8 e8       	ldi	r30, 0x88	; 136
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	91 81       	ldd	r25, Z+1	; 0x01
     1e8:	81 5e       	subi	r24, 0xE1	; 225
     1ea:	91 4b       	sbci	r25, 0xB1	; 177
     1ec:	91 83       	std	Z+1, r25	; 0x01
     1ee:	80 83       	st	Z, r24
	
}
     1f0:	ff 91       	pop	r31
     1f2:	ef 91       	pop	r30
     1f4:	9f 91       	pop	r25
     1f6:	8f 91       	pop	r24
     1f8:	0f 90       	pop	r0
     1fa:	0f be       	out	0x3f, r0	; 63
     1fc:	0f 90       	pop	r0
     1fe:	1f 90       	pop	r1
     200:	18 95       	reti

00000202 <__vector_12>:

ISR(TIMER1_COMPB_vect){
     202:	1f 92       	push	r1
     204:	0f 92       	push	r0
     206:	0f b6       	in	r0, 0x3f	; 63
     208:	0f 92       	push	r0
     20a:	11 24       	eor	r1, r1
     20c:	2f 93       	push	r18
     20e:	3f 93       	push	r19
     210:	4f 93       	push	r20
     212:	5f 93       	push	r21
     214:	6f 93       	push	r22
     216:	7f 93       	push	r23
     218:	8f 93       	push	r24
     21a:	9f 93       	push	r25
     21c:	af 93       	push	r26
     21e:	bf 93       	push	r27
     220:	ef 93       	push	r30
     222:	ff 93       	push	r31
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
}

static inline void on_timer1_compb_hcsr(){
	HCSR04_TriggerReady(HCSR_1);					//Pongo en LOW el Trigger
     224:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <HCSR_1>
     228:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <HCSR_1+0x1>
     22c:	0e 94 91 00 	call	0x122	; 0x122 <HCSR04_TriggerReady>
	TIFR1 |= (1<<ICF1);								// Timer/Counter1 Output Compare A Match Flag enabled
     230:	86 b3       	in	r24, 0x16	; 22
     232:	80 62       	ori	r24, 0x20	; 32
     234:	86 bb       	out	0x16, r24	; 22
	TCCR1B = (1 << ICNC1) | (1 << ICES1);			// Input Capture Noise Canceler and Input Capture Edge Select activated
     236:	e1 e8       	ldi	r30, 0x81	; 129
     238:	f0 e0       	ldi	r31, 0x00	; 0
     23a:	80 ec       	ldi	r24, 0xC0	; 192
     23c:	80 83       	st	Z, r24
	TCCR1B |= (1 << CS11);							// Prescaler definition (x8): CS12 = 0 and CS10 = 0
     23e:	80 81       	ld	r24, Z
     240:	82 60       	ori	r24, 0x02	; 2
     242:	80 83       	st	Z, r24
	TIMSK1 = (1<<ICIE1) | (1<<OCIE1A);				// Input Capture Interrupt and Output Compare A Match Interrupt enabled <---
     244:	82 e2       	ldi	r24, 0x22	; 34
     246:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	
	on_timer1_compb_hcsr();
	
}
     24a:	ff 91       	pop	r31
     24c:	ef 91       	pop	r30
     24e:	bf 91       	pop	r27
     250:	af 91       	pop	r26
     252:	9f 91       	pop	r25
     254:	8f 91       	pop	r24
     256:	7f 91       	pop	r23
     258:	6f 91       	pop	r22
     25a:	5f 91       	pop	r21
     25c:	4f 91       	pop	r20
     25e:	3f 91       	pop	r19
     260:	2f 91       	pop	r18
     262:	0f 90       	pop	r0
     264:	0f be       	out	0x3f, r0	; 63
     266:	0f 90       	pop	r0
     268:	1f 90       	pop	r1
     26a:	18 95       	reti

0000026c <__vector_10>:

ISR(TIMER1_CAPT_vect){
     26c:	1f 92       	push	r1
     26e:	0f 92       	push	r0
     270:	0f b6       	in	r0, 0x3f	; 63
     272:	0f 92       	push	r0
     274:	11 24       	eor	r1, r1
     276:	2f 93       	push	r18
     278:	3f 93       	push	r19
     27a:	4f 93       	push	r20
     27c:	5f 93       	push	r21
     27e:	6f 93       	push	r22
     280:	7f 93       	push	r23
     282:	8f 93       	push	r24
     284:	9f 93       	push	r25
     286:	af 93       	push	r26
     288:	bf 93       	push	r27
     28a:	ef 93       	push	r30
     28c:	ff 93       	push	r31
}

static inline void on_timer1_capt_hcsr(){
	if (TCCR1B & (1<<ICES1)){						// Si ICES1 = 1  el Timer va a capturar en el flanco de subida (rising edge).
     28e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
     292:	86 ff       	sbrs	r24, 6
     294:	10 c0       	rjmp	.+32     	; 0x2b6 <__vector_10+0x4a>
		
		TCCR1B = (1 << ICNC1) | (1 << CS11);		//preparo para capturar el flanco de bajada
     296:	82 e8       	ldi	r24, 0x82	; 130
     298:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
		HCSR04_RiseEdgeTime(HCSR_1, ICR1 >> 1);		//[[ ICR1 >> 1  ==  ICR1 / 2 ]] -> En ICR1 almacena el valor de TCNT1, Es decir, guardo el momento en que llego el RISE. Como ICR1 obtiene un tick cada 500ns, si contó 3000 ticks, se hace la cuenta 3000 * 0,5us = 1500us. (500ns = 0,5us = 1/2).
     29c:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2a0:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2a4:	76 95       	lsr	r23
     2a6:	67 95       	ror	r22
     2a8:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <HCSR_1>
     2ac:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <HCSR_1+0x1>
     2b0:	0e 94 9b 00 	call	0x136	; 0x136 <HCSR04_RiseEdgeTime>
     2b4:	11 c0       	rjmp	.+34     	; 0x2d8 <__vector_10+0x6c>
		}else{										// Falling edge is used as trigger

		TIMSK1 &= ~_BV(ICIE1);						//desactivo la interrupcion por input capture
     2b6:	ef e6       	ldi	r30, 0x6F	; 111
     2b8:	f0 e0       	ldi	r31, 0x00	; 0
     2ba:	80 81       	ld	r24, Z
     2bc:	8f 7d       	andi	r24, 0xDF	; 223
     2be:	80 83       	st	Z, r24
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
     2c0:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2c4:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2c8:	76 95       	lsr	r23
     2ca:	67 95       	ror	r22
     2cc:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <HCSR_1>
     2d0:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <HCSR_1+0x1>
     2d4:	0e 94 a4 00 	call	0x148	; 0x148 <HCSR04_FallEdgeTime>
	
	on_timer1_capt_hcsr();
	
}
     2d8:	ff 91       	pop	r31
     2da:	ef 91       	pop	r30
     2dc:	bf 91       	pop	r27
     2de:	af 91       	pop	r26
     2e0:	9f 91       	pop	r25
     2e2:	8f 91       	pop	r24
     2e4:	7f 91       	pop	r23
     2e6:	6f 91       	pop	r22
     2e8:	5f 91       	pop	r21
     2ea:	4f 91       	pop	r20
     2ec:	3f 91       	pop	r19
     2ee:	2f 91       	pop	r18
     2f0:	0f 90       	pop	r0
     2f2:	0f be       	out	0x3f, r0	; 63
     2f4:	0f 90       	pop	r0
     2f6:	1f 90       	pop	r1
     2f8:	18 95       	reti

000002fa <__vector_16>:

ISR(TIMER0_OVF_vect){
     2fa:	1f 92       	push	r1
     2fc:	0f 92       	push	r0
     2fe:	0f b6       	in	r0, 0x3f	; 63
     300:	0f 92       	push	r0
     302:	11 24       	eor	r1, r1
     304:	2f 93       	push	r18
     306:	3f 93       	push	r19
     308:	4f 93       	push	r20
     30a:	5f 93       	push	r21
     30c:	6f 93       	push	r22
     30e:	7f 93       	push	r23
     310:	8f 93       	push	r24
     312:	9f 93       	push	r25
     314:	af 93       	push	r26
     316:	bf 93       	push	r27
     318:	ef 93       	push	r30
     31a:	ff 93       	push	r31
	
	writeServo();
     31c:	0e 94 86 06 	call	0xd0c	; 0xd0c <writeServo>
	
}
     320:	ff 91       	pop	r31
     322:	ef 91       	pop	r30
     324:	bf 91       	pop	r27
     326:	af 91       	pop	r26
     328:	9f 91       	pop	r25
     32a:	8f 91       	pop	r24
     32c:	7f 91       	pop	r23
     32e:	6f 91       	pop	r22
     330:	5f 91       	pop	r21
     332:	4f 91       	pop	r20
     334:	3f 91       	pop	r19
     336:	2f 91       	pop	r18
     338:	0f 90       	pop	r0
     33a:	0f be       	out	0x3f, r0	; 63
     33c:	0f 90       	pop	r0
     33e:	1f 90       	pop	r1
     340:	18 95       	reti

00000342 <__vector_18>:

ISR(USART_RX_vect){
     342:	1f 92       	push	r1
     344:	0f 92       	push	r0
     346:	0f b6       	in	r0, 0x3f	; 63
     348:	0f 92       	push	r0
     34a:	11 24       	eor	r1, r1
     34c:	8f 93       	push	r24
     34e:	9f 93       	push	r25
     350:	af 93       	push	r26
     352:	bf 93       	push	r27
     354:	ef 93       	push	r30
     356:	ff 93       	push	r31
	dataRx.buff[dataRx.indexW++] = UDR0;
     358:	e6 e3       	ldi	r30, 0x36	; 54
     35a:	f2 e0       	ldi	r31, 0x02	; 2
     35c:	a0 81       	ld	r26, Z
     35e:	b1 81       	ldd	r27, Z+1	; 0x01
     360:	83 81       	ldd	r24, Z+3	; 0x03
     362:	91 e0       	ldi	r25, 0x01	; 1
     364:	98 0f       	add	r25, r24
     366:	93 83       	std	Z+3, r25	; 0x03
     368:	a8 0f       	add	r26, r24
     36a:	b1 1d       	adc	r27, r1
     36c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     370:	8c 93       	st	X, r24
	dataRx.indexW &= dataRx.mask;
     372:	85 81       	ldd	r24, Z+5	; 0x05
     374:	93 81       	ldd	r25, Z+3	; 0x03
     376:	89 23       	and	r24, r25
     378:	83 83       	std	Z+3, r24	; 0x03
}
     37a:	ff 91       	pop	r31
     37c:	ef 91       	pop	r30
     37e:	bf 91       	pop	r27
     380:	af 91       	pop	r26
     382:	9f 91       	pop	r25
     384:	8f 91       	pop	r24
     386:	0f 90       	pop	r0
     388:	0f be       	out	0x3f, r0	; 63
     38a:	0f 90       	pop	r0
     38c:	1f 90       	pop	r1
     38e:	18 95       	reti

00000390 <ini_ports>:
void ini_ports(){
	
	/************************************************************************/
	/*								OUTPUTS                                 */
	/************************************************************************/
	DDRB = ((1 << LED_BI)| (1 << SV1) | (1 << SV2) | (1<<TRIGGER));
     390:	8a e3       	ldi	r24, 0x3A	; 58
     392:	84 b9       	out	0x04, r24	; 4
	DDRD = (1 << SV0);
     394:	80 e8       	ldi	r24, 0x80	; 128
     396:	8a b9       	out	0x0a, r24	; 10
	
	/************************************************************************/
	/*								INPUTS                                  */
	/************************************************************************/
	DDRB &= ~(1<<ECHO);
     398:	84 b1       	in	r24, 0x04	; 4
     39a:	8e 7f       	andi	r24, 0xFE	; 254
     39c:	84 b9       	out	0x04, r24	; 4
	DDRD &= ~((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     39e:	8a b1       	in	r24, 0x0a	; 10
     3a0:	83 7c       	andi	r24, 0xC3	; 195
     3a2:	8a b9       	out	0x0a, r24	; 10
	
	/*						Activo Pull ups internos						*/
	PORTB = (1<<ECHO);
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	85 b9       	out	0x05, r24	; 5
	PORTD = ((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3a8:	8c e3       	ldi	r24, 0x3C	; 60
     3aa:	8b b9       	out	0x0b, r24	; 11
     3ac:	08 95       	ret

000003ae <ini_timer1>:
/************************************************************************/
/*		Timer 1 es funcional al HCSR y a la accion cada 10ms            */
/************************************************************************/
void ini_timer1(){
	
	TCCR1A = 0x00;
     3ae:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
	/* Configuro noise canceler del input capture, el flanco del input capture y prescaler en 8 (f = 16MHz / 8 = 2MHz ? 1 tick = 0.5 µs) */
	TCCR1B = 0xC2;
     3b2:	82 ec       	ldi	r24, 0xC2	; 194
     3b4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
	TCNT1 = 0x00;
     3b8:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     3bc:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
	/*	Activo la interrupcion por comparador b	*/
	TIMSK1 = (1<<OCIE1A);
     3c0:	82 e0       	ldi	r24, 0x02	; 2
     3c2:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	/* Le doy un valor al comparador B	*/
	OCR1A = 19999;
     3c6:	8f e1       	ldi	r24, 0x1F	; 31
     3c8:	9e e4       	ldi	r25, 0x4E	; 78
     3ca:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     3ce:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
	TIFR1 = TIFR1;
     3d2:	86 b3       	in	r24, 0x16	; 22
     3d4:	86 bb       	out	0x16, r24	; 22
     3d6:	08 95       	ret

000003d8 <ini_timer0>:
/************************************************************************/
/*			Timer 0 funcional a generar el pwm de los servos			*/
/************************************************************************/
void ini_timer0(){
	
	TCCR0A = 0;
     3d8:	14 bc       	out	0x24, r1	; 36
	TCNT0 = 0;
     3da:	16 bc       	out	0x26, r1	; 38
	/*	Pongo las banderas en 0 con TIFR	*/
	TIFR0 = 0x07;
     3dc:	87 e0       	ldi	r24, 0x07	; 7
     3de:	85 bb       	out	0x15, r24	; 21
	/*	Habilito la interrupcion por TOV	*/
	TIMSK0 = (1<<TOIE0);
     3e0:	81 e0       	ldi	r24, 0x01	; 1
     3e2:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
	/*	Prescaler en 8 , obtengo el cuentas de 500ns, tov a 500*256 = 128us		*/
	TCCR0B = (1<<CS01);
     3e6:	82 e0       	ldi	r24, 0x02	; 2
     3e8:	85 bd       	out	0x25, r24	; 37
     3ea:	08 95       	ret

000003ec <ini_USART>:
	
}

void ini_USART(uint8_t ubrr){
	UBRR0H = 0;
     3ec:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = ubrr;
     3f0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	UCSR0A = 0xFE; //inicializo todas las banderas excepto el multiprocesor
     3f4:	8e ef       	ldi	r24, 0xFE	; 254
     3f6:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	UCSR0B =   0x98; // (1<<RXCIE0) | (1<<RXEN0)|(1<<TXEN0); //Activo las banderas de interrupcion de recepcion y la habilitacion del rx y tx
     3fa:	88 e9       	ldi	r24, 0x98	; 152
     3fc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
     400:	86 e0       	ldi	r24, 0x06	; 6
     402:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     406:	08 95       	ret

00000408 <IR_Init>:
	
}

void IR_Init(IRDebounce *ir) {
     408:	ac 01       	movw	r20, r24
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     40a:	20 e0       	ldi	r18, 0x00	; 0
     40c:	30 e0       	ldi	r19, 0x00	; 0
     40e:	0d c0       	rjmp	.+26     	; 0x42a <IR_Init+0x22>
		ir[globalIndex].state = IR_DOWN;
     410:	f9 01       	movw	r30, r18
     412:	ee 0f       	add	r30, r30
     414:	ff 1f       	adc	r31, r31
     416:	ee 0f       	add	r30, r30
     418:	ff 1f       	adc	r31, r31
     41a:	e4 0f       	add	r30, r20
     41c:	f5 1f       	adc	r31, r21
     41e:	93 e0       	ldi	r25, 0x03	; 3
     420:	90 83       	st	Z, r25
		ir[globalIndex].last_sample = 0;
     422:	12 82       	std	Z+2, r1	; 0x02
		ir[globalIndex].stateConfirmed = 0;
     424:	11 82       	std	Z+1, r1	; 0x01
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
	
}

void IR_Init(IRDebounce *ir) {
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     426:	2f 5f       	subi	r18, 0xFF	; 255
     428:	3f 4f       	sbci	r19, 0xFF	; 255
     42a:	24 30       	cpi	r18, 0x04	; 4
     42c:	31 05       	cpc	r19, r1
     42e:	84 f3       	brlt	.-32     	; 0x410 <IR_Init+0x8>
		ir[globalIndex].state = IR_DOWN;
		ir[globalIndex].last_sample = 0;
		ir[globalIndex].stateConfirmed = 0;
	}
}
     430:	08 95       	ret

00000432 <IR_Update>:

void IR_Update(IRDebounce *ir, uint8_t sample) {
     432:	fc 01       	movw	r30, r24
	switch (ir->state) {
     434:	80 81       	ld	r24, Z
     436:	81 30       	cpi	r24, 0x01	; 1
     438:	89 f0       	breq	.+34     	; 0x45c <IR_Update+0x2a>
     43a:	28 f0       	brcs	.+10     	; 0x446 <IR_Update+0x14>
     43c:	82 30       	cpi	r24, 0x02	; 2
     43e:	b1 f0       	breq	.+44     	; 0x46c <IR_Update+0x3a>
     440:	83 30       	cpi	r24, 0x03	; 3
     442:	01 f1       	breq	.+64     	; 0x484 <IR_Update+0x52>
     444:	26 c0       	rjmp	.+76     	; 0x492 <IR_Update+0x60>
		case IR_RISING:
		if (sample == 1 && ir->last_sample == 1){
     446:	61 30       	cpi	r22, 0x01	; 1
     448:	31 f4       	brne	.+12     	; 0x456 <IR_Update+0x24>
     44a:	82 81       	ldd	r24, Z+2	; 0x02
     44c:	81 30       	cpi	r24, 0x01	; 1
     44e:	19 f4       	brne	.+6      	; 0x456 <IR_Update+0x24>
			ir->state = IR_UP;
     450:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x01;
     452:	81 83       	std	Z+1, r24	; 0x01
     454:	20 c0       	rjmp	.+64     	; 0x496 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     456:	83 e0       	ldi	r24, 0x03	; 3
     458:	80 83       	st	Z, r24
     45a:	1d c0       	rjmp	.+58     	; 0x496 <IR_Update+0x64>
		}
		break;

		case IR_UP:
		if (sample == 0){
     45c:	61 11       	cpse	r22, r1
     45e:	03 c0       	rjmp	.+6      	; 0x466 <IR_Update+0x34>
			ir->state = IR_FALLING;
     460:	82 e0       	ldi	r24, 0x02	; 2
     462:	80 83       	st	Z, r24
     464:	18 c0       	rjmp	.+48     	; 0x496 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     466:	81 e0       	ldi	r24, 0x01	; 1
     468:	80 83       	st	Z, r24
     46a:	15 c0       	rjmp	.+42     	; 0x496 <IR_Update+0x64>
		}
		break;

		case IR_FALLING:
		if (sample == 0 && ir->last_sample == 0){
     46c:	61 11       	cpse	r22, r1
     46e:	07 c0       	rjmp	.+14     	; 0x47e <IR_Update+0x4c>
     470:	82 81       	ldd	r24, Z+2	; 0x02
     472:	81 11       	cpse	r24, r1
     474:	04 c0       	rjmp	.+8      	; 0x47e <IR_Update+0x4c>
			ir->state = IR_DOWN;
     476:	83 e0       	ldi	r24, 0x03	; 3
     478:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x00;
     47a:	11 82       	std	Z+1, r1	; 0x01
     47c:	0c c0       	rjmp	.+24     	; 0x496 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	80 83       	st	Z, r24
     482:	09 c0       	rjmp	.+18     	; 0x496 <IR_Update+0x64>
		}
		break;

		case IR_DOWN:
		if (sample == 1){
     484:	61 30       	cpi	r22, 0x01	; 1
     486:	11 f4       	brne	.+4      	; 0x48c <IR_Update+0x5a>
			ir->state = IR_RISING;
     488:	10 82       	st	Z, r1
     48a:	05 c0       	rjmp	.+10     	; 0x496 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     48c:	83 e0       	ldi	r24, 0x03	; 3
     48e:	80 83       	st	Z, r24
     490:	02 c0       	rjmp	.+4      	; 0x496 <IR_Update+0x64>
		}
		break;
		default:
		ir->state = IR_UP;
     492:	81 e0       	ldi	r24, 0x01	; 1
     494:	80 83       	st	Z, r24
		break;
	}

	ir->last_sample = sample;
     496:	62 83       	std	Z+2, r22	; 0x02
     498:	08 95       	ret

0000049a <IR_GetState>:
}

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}
     49a:	fc 01       	movw	r30, r24
     49c:	81 81       	ldd	r24, Z+1	; 0x01
     49e:	08 95       	ret

000004a0 <putHeaderOnTx>:
			dataTx->indexR &= dataTx->mask;
		}
	}
}

uint8_t putHeaderOnTx(_sTx  *dataTx, _eCmd ID, uint8_t frameLength){
     4a0:	fc 01       	movw	r30, r24
	dataTx->chk = 0;
     4a2:	15 82       	std	Z+5, r1	; 0x05
	dataTx->buff[dataTx->indexW++]='U';
     4a4:	a0 81       	ld	r26, Z
     4a6:	b1 81       	ldd	r27, Z+1	; 0x01
     4a8:	83 81       	ldd	r24, Z+3	; 0x03
     4aa:	91 e0       	ldi	r25, 0x01	; 1
     4ac:	98 0f       	add	r25, r24
     4ae:	93 83       	std	Z+3, r25	; 0x03
     4b0:	a8 0f       	add	r26, r24
     4b2:	b1 1d       	adc	r27, r1
     4b4:	85 e5       	ldi	r24, 0x55	; 85
     4b6:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4b8:	84 81       	ldd	r24, Z+4	; 0x04
     4ba:	93 81       	ldd	r25, Z+3	; 0x03
     4bc:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='N';
     4be:	a0 81       	ld	r26, Z
     4c0:	b1 81       	ldd	r27, Z+1	; 0x01
     4c2:	81 e0       	ldi	r24, 0x01	; 1
     4c4:	89 0f       	add	r24, r25
     4c6:	83 83       	std	Z+3, r24	; 0x03
     4c8:	a9 0f       	add	r26, r25
     4ca:	b1 1d       	adc	r27, r1
     4cc:	8e e4       	ldi	r24, 0x4E	; 78
     4ce:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4d0:	84 81       	ldd	r24, Z+4	; 0x04
     4d2:	93 81       	ldd	r25, Z+3	; 0x03
     4d4:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='E';
     4d6:	a0 81       	ld	r26, Z
     4d8:	b1 81       	ldd	r27, Z+1	; 0x01
     4da:	81 e0       	ldi	r24, 0x01	; 1
     4dc:	89 0f       	add	r24, r25
     4de:	83 83       	std	Z+3, r24	; 0x03
     4e0:	a9 0f       	add	r26, r25
     4e2:	b1 1d       	adc	r27, r1
     4e4:	85 e4       	ldi	r24, 0x45	; 69
     4e6:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4e8:	84 81       	ldd	r24, Z+4	; 0x04
     4ea:	93 81       	ldd	r25, Z+3	; 0x03
     4ec:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='R';
     4ee:	a0 81       	ld	r26, Z
     4f0:	b1 81       	ldd	r27, Z+1	; 0x01
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	89 0f       	add	r24, r25
     4f6:	83 83       	std	Z+3, r24	; 0x03
     4f8:	a9 0f       	add	r26, r25
     4fa:	b1 1d       	adc	r27, r1
     4fc:	82 e5       	ldi	r24, 0x52	; 82
     4fe:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     500:	84 81       	ldd	r24, Z+4	; 0x04
     502:	93 81       	ldd	r25, Z+3	; 0x03
     504:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=frameLength+1;
     506:	a0 81       	ld	r26, Z
     508:	b1 81       	ldd	r27, Z+1	; 0x01
     50a:	81 e0       	ldi	r24, 0x01	; 1
     50c:	89 0f       	add	r24, r25
     50e:	83 83       	std	Z+3, r24	; 0x03
     510:	a9 0f       	add	r26, r25
     512:	b1 1d       	adc	r27, r1
     514:	4f 5f       	subi	r20, 0xFF	; 255
     516:	4c 93       	st	X, r20
	dataTx->indexW &= dataTx->mask;
     518:	84 81       	ldd	r24, Z+4	; 0x04
     51a:	93 81       	ldd	r25, Z+3	; 0x03
     51c:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=':';
     51e:	a0 81       	ld	r26, Z
     520:	b1 81       	ldd	r27, Z+1	; 0x01
     522:	81 e0       	ldi	r24, 0x01	; 1
     524:	89 0f       	add	r24, r25
     526:	83 83       	std	Z+3, r24	; 0x03
     528:	a9 0f       	add	r26, r25
     52a:	b1 1d       	adc	r27, r1
     52c:	8a e3       	ldi	r24, 0x3A	; 58
     52e:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     530:	84 81       	ldd	r24, Z+4	; 0x04
     532:	93 81       	ldd	r25, Z+3	; 0x03
     534:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=ID;
     536:	a0 81       	ld	r26, Z
     538:	b1 81       	ldd	r27, Z+1	; 0x01
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	89 0f       	add	r24, r25
     53e:	83 83       	std	Z+3, r24	; 0x03
     540:	a9 0f       	add	r26, r25
     542:	b1 1d       	adc	r27, r1
     544:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     546:	94 81       	ldd	r25, Z+4	; 0x04
     548:	83 81       	ldd	r24, Z+3	; 0x03
     54a:	98 23       	and	r25, r24
     54c:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= (frameLength+1);
     54e:	95 81       	ldd	r25, Z+5	; 0x05
     550:	49 27       	eor	r20, r25
	dataTx->chk ^= ('U' ^'N' ^'E' ^'R' ^ID ^':') ;
     552:	64 27       	eor	r22, r20
     554:	86 e3       	ldi	r24, 0x36	; 54
     556:	86 27       	eor	r24, r22
     558:	85 83       	std	Z+5, r24	; 0x05
	return  dataTx->chk;
}
     55a:	08 95       	ret

0000055c <putByteOnTx>:
uint8_t putByteOnTx(_sTx *dataTx, uint8_t byte)
{
     55c:	fc 01       	movw	r30, r24
	dataTx->buff[dataTx->indexW++]=byte;
     55e:	a0 81       	ld	r26, Z
     560:	b1 81       	ldd	r27, Z+1	; 0x01
     562:	83 81       	ldd	r24, Z+3	; 0x03
     564:	91 e0       	ldi	r25, 0x01	; 1
     566:	98 0f       	add	r25, r24
     568:	93 83       	std	Z+3, r25	; 0x03
     56a:	a8 0f       	add	r26, r24
     56c:	b1 1d       	adc	r27, r1
     56e:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     570:	94 81       	ldd	r25, Z+4	; 0x04
     572:	83 81       	ldd	r24, Z+3	; 0x03
     574:	98 23       	and	r25, r24
     576:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= byte;
     578:	85 81       	ldd	r24, Z+5	; 0x05
     57a:	86 27       	eor	r24, r22
     57c:	85 83       	std	Z+5, r24	; 0x05
	return dataTx->chk;
}
     57e:	08 95       	ret

00000580 <decodeCommand>:
void decodeCommand(_sRx *dataRx, _sTx *dataTx){
     580:	0f 93       	push	r16
     582:	1f 93       	push	r17
     584:	cf 93       	push	r28
     586:	df 93       	push	r29
     588:	eb 01       	movw	r28, r22
	switch(dataRx->buff[dataRx->indexData]){
     58a:	dc 01       	movw	r26, r24
     58c:	ed 91       	ld	r30, X+
     58e:	fc 91       	ld	r31, X
     590:	11 97       	sbiw	r26, 0x01	; 1
     592:	14 96       	adiw	r26, 0x04	; 4
     594:	8c 91       	ld	r24, X
     596:	e8 0f       	add	r30, r24
     598:	f1 1d       	adc	r31, r1
     59a:	60 81       	ld	r22, Z
     59c:	60 3f       	cpi	r22, 0xF0	; 240
     59e:	39 f0       	breq	.+14     	; 0x5ae <decodeCommand+0x2e>
     5a0:	61 3f       	cpi	r22, 0xF1	; 241
     5a2:	09 f4       	brne	.+2      	; 0x5a6 <decodeCommand+0x26>
     5a4:	62 c0       	rjmp	.+196    	; 0x66a <decodeCommand+0xea>
     5a6:	65 3a       	cpi	r22, 0xA5	; 165
     5a8:	09 f0       	breq	.+2      	; 0x5ac <decodeCommand+0x2c>
     5aa:	53 c0       	rjmp	.+166    	; 0x652 <decodeCommand+0xd2>
     5ac:	0e c0       	rjmp	.+28     	; 0x5ca <decodeCommand+0x4a>
		
		case ALIVE:
		
			putHeaderOnTx(dataTx, ALIVE, 2);
     5ae:	42 e0       	ldi	r20, 0x02	; 2
     5b0:	60 ef       	ldi	r22, 0xF0	; 240
     5b2:	ce 01       	movw	r24, r28
     5b4:	0e 94 50 02 	call	0x4a0	; 0x4a0 <putHeaderOnTx>
			putByteOnTx(dataTx, ACK );
     5b8:	6d e0       	ldi	r22, 0x0D	; 13
     5ba:	ce 01       	movw	r24, r28
     5bc:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     5c0:	6d 81       	ldd	r22, Y+5	; 0x05
     5c2:	ce 01       	movw	r24, r28
     5c4:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		
		break;
     5c8:	50 c0       	rjmp	.+160    	; 0x66a <decodeCommand+0xea>
		case FIRMWARE:
		break;

		case DATA:
			myWord.ui16[0]	= globalDistance;
     5ca:	03 e5       	ldi	r16, 0x53	; 83
     5cc:	12 e0       	ldi	r17, 0x02	; 2
     5ce:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <globalDistance>
     5d2:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <globalDistance+0x1>
     5d6:	f8 01       	movw	r30, r16
     5d8:	91 83       	std	Z+1, r25	; 0x01
     5da:	80 83       	st	Z, r24
			putHeaderOnTx(dataTx, DATA, 8);
     5dc:	48 e0       	ldi	r20, 0x08	; 8
     5de:	65 ea       	ldi	r22, 0xA5	; 165
     5e0:	ce 01       	movw	r24, r28
     5e2:	0e 94 50 02 	call	0x4a0	; 0x4a0 <putHeaderOnTx>
			putByteOnTx(dataTx, myWord.ui8[0]);
     5e6:	d8 01       	movw	r26, r16
     5e8:	6c 91       	ld	r22, X
     5ea:	ce 01       	movw	r24, r28
     5ec:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     5f0:	f8 01       	movw	r30, r16
     5f2:	61 81       	ldd	r22, Z+1	; 0x01
     5f4:	ce 01       	movw	r24, r28
     5f6:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, boxToTx);
     5fa:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <boxToTx>
     5fe:	ce 01       	movw	r24, r28
     600:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			myWord.ui16[0] = IR_GetState(&ir_sensor[0]);
     604:	87 e5       	ldi	r24, 0x57	; 87
     606:	92 e0       	ldi	r25, 0x02	; 2
     608:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	68 2f       	mov	r22, r24
     610:	d8 01       	movw	r26, r16
     612:	8d 93       	st	X+, r24
     614:	9c 93       	st	X, r25
			putByteOnTx(dataTx, myWord.ui8[0]);
     616:	ce 01       	movw	r24, r28
     618:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     61c:	f8 01       	movw	r30, r16
     61e:	61 81       	ldd	r22, Z+1	; 0x01
     620:	ce 01       	movw	r24, r28
     622:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			myWord.ui16[0] = Numbox;
     626:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Numbox>
     62a:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Numbox+0x1>
     62e:	68 2f       	mov	r22, r24
     630:	d8 01       	movw	r26, r16
     632:	8c 93       	st	X, r24
     634:	11 96       	adiw	r26, 0x01	; 1
     636:	9c 93       	st	X, r25
			putByteOnTx(dataTx, myWord.ui8[0]);
     638:	ce 01       	movw	r24, r28
     63a:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     63e:	f8 01       	movw	r30, r16
     640:	61 81       	ldd	r22, Z+1	; 0x01
     642:	ce 01       	movw	r24, r28
     644:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     648:	6d 81       	ldd	r22, Y+5	; 0x05
     64a:	ce 01       	movw	r24, r28
     64c:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		break;
     650:	0c c0       	rjmp	.+24     	; 0x66a <decodeCommand+0xea>
		//putByteOnTx(dataTx, dataTx->chk);
		//
		//break;

		default:
			putHeaderOnTx(dataTx, (_eCmd)dataRx->buff[dataRx->indexData], 2);
     652:	42 e0       	ldi	r20, 0x02	; 2
     654:	ce 01       	movw	r24, r28
     656:	0e 94 50 02 	call	0x4a0	; 0x4a0 <putHeaderOnTx>
			putByteOnTx(dataTx,UNKNOWN );
     65a:	6f ef       	ldi	r22, 0xFF	; 255
     65c:	ce 01       	movw	r24, r28
     65e:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     662:	6d 81       	ldd	r22, Y+5	; 0x05
     664:	ce 01       	movw	r24, r28
     666:	0e 94 ae 02 	call	0x55c	; 0x55c <putByteOnTx>
		break;
		
	}
}
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	1f 91       	pop	r17
     670:	0f 91       	pop	r16
     672:	08 95       	ret

00000674 <decodeHeader>:
void decodeHeader(_sRx *dataRx){
     674:	dc 01       	movw	r26, r24
	uint8_t auxIndex=dataRx->indexW;
     676:	13 96       	adiw	r26, 0x03	; 3
     678:	2c 91       	ld	r18, X
     67a:	13 97       	sbiw	r26, 0x03	; 3
	while(dataRx->indexR != auxIndex){
     67c:	c9 c0       	rjmp	.+402    	; 0x810 <__DATA_REGION_LENGTH__+0x10>
		switch(dataRx->header)
     67e:	18 96       	adiw	r26, 0x08	; 8
     680:	ec 91       	ld	r30, X
     682:	18 97       	sbiw	r26, 0x08	; 8
     684:	4e 2f       	mov	r20, r30
     686:	50 e0       	ldi	r21, 0x00	; 0
     688:	47 30       	cpi	r20, 0x07	; 7
     68a:	51 05       	cpc	r21, r1
     68c:	08 f0       	brcs	.+2      	; 0x690 <decodeHeader+0x1c>
     68e:	b2 c0       	rjmp	.+356    	; 0x7f4 <decodeHeader+0x180>
     690:	fa 01       	movw	r30, r20
     692:	ec 5c       	subi	r30, 0xCC	; 204
     694:	ff 4f       	sbci	r31, 0xFF	; 255
     696:	0c 94 e3 06 	jmp	0xdc6	; 0xdc6 <__tablejump2__>
		{
			case HEADER_U:
			if(dataRx->buff[dataRx->indexR] == 'U'){
     69a:	ed 91       	ld	r30, X+
     69c:	fc 91       	ld	r31, X
     69e:	11 97       	sbiw	r26, 0x01	; 1
     6a0:	e8 0f       	add	r30, r24
     6a2:	f1 1d       	adc	r31, r1
     6a4:	80 81       	ld	r24, Z
     6a6:	85 35       	cpi	r24, 0x55	; 85
     6a8:	09 f0       	breq	.+2      	; 0x6ac <decodeHeader+0x38>
     6aa:	a7 c0       	rjmp	.+334    	; 0x7fa <decodeHeader+0x186>
				dataRx->header = HEADER_N;
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	18 96       	adiw	r26, 0x08	; 8
     6b0:	8c 93       	st	X, r24
     6b2:	18 97       	sbiw	r26, 0x08	; 8
     6b4:	a2 c0       	rjmp	.+324    	; 0x7fa <decodeHeader+0x186>
			}
			break;
			case HEADER_N:
			if(dataRx->buff[dataRx->indexR] == 'N'){
     6b6:	ed 91       	ld	r30, X+
     6b8:	fc 91       	ld	r31, X
     6ba:	11 97       	sbiw	r26, 0x01	; 1
     6bc:	e8 0f       	add	r30, r24
     6be:	f1 1d       	adc	r31, r1
     6c0:	90 81       	ld	r25, Z
     6c2:	9e 34       	cpi	r25, 0x4E	; 78
     6c4:	29 f4       	brne	.+10     	; 0x6d0 <decodeHeader+0x5c>
				dataRx->header = HEADER_E;
     6c6:	82 e0       	ldi	r24, 0x02	; 2
     6c8:	18 96       	adiw	r26, 0x08	; 8
     6ca:	8c 93       	st	X, r24
     6cc:	18 97       	sbiw	r26, 0x08	; 8
     6ce:	95 c0       	rjmp	.+298    	; 0x7fa <decodeHeader+0x186>
				}else{
				if(dataRx->buff[dataRx->indexR] != 'U'){
     6d0:	95 35       	cpi	r25, 0x55	; 85
     6d2:	09 f4       	brne	.+2      	; 0x6d6 <decodeHeader+0x62>
     6d4:	92 c0       	rjmp	.+292    	; 0x7fa <decodeHeader+0x186>
					dataRx->header = HEADER_U;
     6d6:	18 96       	adiw	r26, 0x08	; 8
     6d8:	1c 92       	st	X, r1
     6da:	18 97       	sbiw	r26, 0x08	; 8
					dataRx->indexR--;
     6dc:	81 50       	subi	r24, 0x01	; 1
     6de:	12 96       	adiw	r26, 0x02	; 2
     6e0:	8c 93       	st	X, r24
     6e2:	12 97       	sbiw	r26, 0x02	; 2
     6e4:	8a c0       	rjmp	.+276    	; 0x7fa <decodeHeader+0x186>
				}
			}
			break;
			case HEADER_E:
			if(dataRx->buff[dataRx->indexR] == 'E'){
     6e6:	ed 91       	ld	r30, X+
     6e8:	fc 91       	ld	r31, X
     6ea:	11 97       	sbiw	r26, 0x01	; 1
     6ec:	e8 0f       	add	r30, r24
     6ee:	f1 1d       	adc	r31, r1
     6f0:	90 81       	ld	r25, Z
     6f2:	95 34       	cpi	r25, 0x45	; 69
     6f4:	29 f4       	brne	.+10     	; 0x700 <decodeHeader+0x8c>
				dataRx->header = HEADER_R;
     6f6:	83 e0       	ldi	r24, 0x03	; 3
     6f8:	18 96       	adiw	r26, 0x08	; 8
     6fa:	8c 93       	st	X, r24
     6fc:	18 97       	sbiw	r26, 0x08	; 8
     6fe:	7d c0       	rjmp	.+250    	; 0x7fa <decodeHeader+0x186>
				}else{
				dataRx->header = HEADER_U;
     700:	18 96       	adiw	r26, 0x08	; 8
     702:	1c 92       	st	X, r1
     704:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     706:	81 50       	subi	r24, 0x01	; 1
     708:	12 96       	adiw	r26, 0x02	; 2
     70a:	8c 93       	st	X, r24
     70c:	12 97       	sbiw	r26, 0x02	; 2
     70e:	75 c0       	rjmp	.+234    	; 0x7fa <decodeHeader+0x186>
			}
			break;
			case HEADER_R:
			if(dataRx->buff[dataRx->indexR] == 'R'){
     710:	ed 91       	ld	r30, X+
     712:	fc 91       	ld	r31, X
     714:	11 97       	sbiw	r26, 0x01	; 1
     716:	e8 0f       	add	r30, r24
     718:	f1 1d       	adc	r31, r1
     71a:	90 81       	ld	r25, Z
     71c:	92 35       	cpi	r25, 0x52	; 82
     71e:	29 f4       	brne	.+10     	; 0x72a <decodeHeader+0xb6>
				dataRx->header = NBYTES;
     720:	84 e0       	ldi	r24, 0x04	; 4
     722:	18 96       	adiw	r26, 0x08	; 8
     724:	8c 93       	st	X, r24
     726:	18 97       	sbiw	r26, 0x08	; 8
     728:	68 c0       	rjmp	.+208    	; 0x7fa <decodeHeader+0x186>
				}else{
				dataRx->header = HEADER_U;
     72a:	18 96       	adiw	r26, 0x08	; 8
     72c:	1c 92       	st	X, r1
     72e:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     730:	81 50       	subi	r24, 0x01	; 1
     732:	12 96       	adiw	r26, 0x02	; 2
     734:	8c 93       	st	X, r24
     736:	12 97       	sbiw	r26, 0x02	; 2
     738:	60 c0       	rjmp	.+192    	; 0x7fa <decodeHeader+0x186>
			}
			break;
			case NBYTES:
			dataRx->nBytes=dataRx->buff[dataRx->indexR];
     73a:	ed 91       	ld	r30, X+
     73c:	fc 91       	ld	r31, X
     73e:	11 97       	sbiw	r26, 0x01	; 1
     740:	e8 0f       	add	r30, r24
     742:	f1 1d       	adc	r31, r1
     744:	80 81       	ld	r24, Z
     746:	17 96       	adiw	r26, 0x07	; 7
     748:	8c 93       	st	X, r24
     74a:	17 97       	sbiw	r26, 0x07	; 7
			dataRx->header = TOKEN;
     74c:	85 e0       	ldi	r24, 0x05	; 5
     74e:	18 96       	adiw	r26, 0x08	; 8
     750:	8c 93       	st	X, r24
     752:	18 97       	sbiw	r26, 0x08	; 8
			break;
     754:	52 c0       	rjmp	.+164    	; 0x7fa <decodeHeader+0x186>
			case TOKEN:
			if(dataRx->buff[dataRx->indexR] == ':'){
     756:	ed 91       	ld	r30, X+
     758:	fc 91       	ld	r31, X
     75a:	11 97       	sbiw	r26, 0x01	; 1
     75c:	e8 0f       	add	r30, r24
     75e:	f1 1d       	adc	r31, r1
     760:	90 81       	ld	r25, Z
     762:	9a 33       	cpi	r25, 0x3A	; 58
     764:	a9 f4       	brne	.+42     	; 0x790 <decodeHeader+0x11c>
				dataRx->header = PAYLOAD;
     766:	96 e0       	ldi	r25, 0x06	; 6
     768:	18 96       	adiw	r26, 0x08	; 8
     76a:	9c 93       	st	X, r25
     76c:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexData = dataRx->indexR+1;
     76e:	8f 5f       	subi	r24, 0xFF	; 255
				dataRx->indexData &= dataRx->mask;
     770:	15 96       	adiw	r26, 0x05	; 5
     772:	9c 91       	ld	r25, X
     774:	15 97       	sbiw	r26, 0x05	; 5
     776:	89 23       	and	r24, r25
     778:	14 96       	adiw	r26, 0x04	; 4
     77a:	8c 93       	st	X, r24
     77c:	14 97       	sbiw	r26, 0x04	; 4
				dataRx->chk = 0;
				dataRx->chk ^= ('U' ^'N' ^'E' ^'R' ^dataRx->nBytes ^':') ;
     77e:	17 96       	adiw	r26, 0x07	; 7
     780:	9c 91       	ld	r25, X
     782:	17 97       	sbiw	r26, 0x07	; 7
     784:	86 e3       	ldi	r24, 0x36	; 54
     786:	89 27       	eor	r24, r25
     788:	16 96       	adiw	r26, 0x06	; 6
     78a:	8c 93       	st	X, r24
     78c:	16 97       	sbiw	r26, 0x06	; 6
     78e:	35 c0       	rjmp	.+106    	; 0x7fa <decodeHeader+0x186>
				}else{
				dataRx->header = HEADER_U;
     790:	18 96       	adiw	r26, 0x08	; 8
     792:	1c 92       	st	X, r1
     794:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     796:	81 50       	subi	r24, 0x01	; 1
     798:	12 96       	adiw	r26, 0x02	; 2
     79a:	8c 93       	st	X, r24
     79c:	12 97       	sbiw	r26, 0x02	; 2
     79e:	2d c0       	rjmp	.+90     	; 0x7fa <decodeHeader+0x186>
			}
			break;
			case PAYLOAD:
			dataRx->nBytes--;
     7a0:	17 96       	adiw	r26, 0x07	; 7
     7a2:	9c 91       	ld	r25, X
     7a4:	17 97       	sbiw	r26, 0x07	; 7
     7a6:	91 50       	subi	r25, 0x01	; 1
     7a8:	17 96       	adiw	r26, 0x07	; 7
     7aa:	9c 93       	st	X, r25
     7ac:	17 97       	sbiw	r26, 0x07	; 7
			if(dataRx->nBytes>0){
     7ae:	99 23       	and	r25, r25
     7b0:	71 f0       	breq	.+28     	; 0x7ce <decodeHeader+0x15a>
				dataRx->chk ^= dataRx->buff[dataRx->indexR];
     7b2:	ed 91       	ld	r30, X+
     7b4:	fc 91       	ld	r31, X
     7b6:	11 97       	sbiw	r26, 0x01	; 1
     7b8:	e8 0f       	add	r30, r24
     7ba:	f1 1d       	adc	r31, r1
     7bc:	80 81       	ld	r24, Z
     7be:	16 96       	adiw	r26, 0x06	; 6
     7c0:	9c 91       	ld	r25, X
     7c2:	16 97       	sbiw	r26, 0x06	; 6
     7c4:	89 27       	eor	r24, r25
     7c6:	16 96       	adiw	r26, 0x06	; 6
     7c8:	8c 93       	st	X, r24
     7ca:	16 97       	sbiw	r26, 0x06	; 6
     7cc:	16 c0       	rjmp	.+44     	; 0x7fa <decodeHeader+0x186>
				}else{
				dataRx->header = HEADER_U;
     7ce:	18 96       	adiw	r26, 0x08	; 8
     7d0:	1c 92       	st	X, r1
     7d2:	18 97       	sbiw	r26, 0x08	; 8
				if(dataRx->buff[dataRx->indexR] == dataRx->chk)
     7d4:	ed 91       	ld	r30, X+
     7d6:	fc 91       	ld	r31, X
     7d8:	11 97       	sbiw	r26, 0x01	; 1
     7da:	e8 0f       	add	r30, r24
     7dc:	f1 1d       	adc	r31, r1
     7de:	90 81       	ld	r25, Z
     7e0:	16 96       	adiw	r26, 0x06	; 6
     7e2:	8c 91       	ld	r24, X
     7e4:	16 97       	sbiw	r26, 0x06	; 6
     7e6:	98 13       	cpse	r25, r24
     7e8:	08 c0       	rjmp	.+16     	; 0x7fa <decodeHeader+0x186>
				dataRx->isComannd = TRUE;
     7ea:	81 e0       	ldi	r24, 0x01	; 1
     7ec:	1a 96       	adiw	r26, 0x0a	; 10
     7ee:	8c 93       	st	X, r24
     7f0:	1a 97       	sbiw	r26, 0x0a	; 10
     7f2:	03 c0       	rjmp	.+6      	; 0x7fa <decodeHeader+0x186>
			}
			break;
			default:
			dataRx->header = HEADER_U;
     7f4:	18 96       	adiw	r26, 0x08	; 8
     7f6:	1c 92       	st	X, r1
     7f8:	18 97       	sbiw	r26, 0x08	; 8
			break;
		}
		dataRx->indexR++;
     7fa:	12 96       	adiw	r26, 0x02	; 2
     7fc:	8c 91       	ld	r24, X
     7fe:	12 97       	sbiw	r26, 0x02	; 2
     800:	8f 5f       	subi	r24, 0xFF	; 255
		dataRx->indexR &= dataRx->mask;
     802:	15 96       	adiw	r26, 0x05	; 5
     804:	9c 91       	ld	r25, X
     806:	15 97       	sbiw	r26, 0x05	; 5
     808:	89 23       	and	r24, r25
     80a:	12 96       	adiw	r26, 0x02	; 2
     80c:	8c 93       	st	X, r24
     80e:	12 97       	sbiw	r26, 0x02	; 2
		
	}
}
void decodeHeader(_sRx *dataRx){
	uint8_t auxIndex=dataRx->indexW;
	while(dataRx->indexR != auxIndex){
     810:	12 96       	adiw	r26, 0x02	; 2
     812:	8c 91       	ld	r24, X
     814:	12 97       	sbiw	r26, 0x02	; 2
     816:	28 13       	cpse	r18, r24
     818:	32 cf       	rjmp	.-412    	; 0x67e <decodeHeader+0xa>
			break;
		}
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}
     81a:	08 95       	ret

0000081c <serialTask>:

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}

void serialTask(_sRx* dataRx, _sTx* dataTx){
     81c:	0f 93       	push	r16
     81e:	1f 93       	push	r17
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	8c 01       	movw	r16, r24
     826:	eb 01       	movw	r28, r22
	if(dataRx->isComannd){
     828:	fc 01       	movw	r30, r24
     82a:	82 85       	ldd	r24, Z+10	; 0x0a
     82c:	88 23       	and	r24, r24
     82e:	21 f0       	breq	.+8      	; 0x838 <serialTask+0x1c>
		dataRx->isComannd=FALSE;
     830:	12 86       	std	Z+10, r1	; 0x0a
		decodeCommand(dataRx,dataTx);
     832:	c8 01       	movw	r24, r16
     834:	0e 94 c0 02 	call	0x580	; 0x580 <decodeCommand>
	}
	if(dataRx->indexR!=dataRx->indexW){
     838:	f8 01       	movw	r30, r16
     83a:	92 81       	ldd	r25, Z+2	; 0x02
     83c:	83 81       	ldd	r24, Z+3	; 0x03
     83e:	98 17       	cp	r25, r24
     840:	19 f0       	breq	.+6      	; 0x848 <serialTask+0x2c>
		
		decodeHeader(dataRx);
     842:	c8 01       	movw	r24, r16
     844:	0e 94 3a 03 	call	0x674	; 0x674 <decodeHeader>
	}
	if (dataTx->indexR!= dataTx->indexW) {
     848:	8a 81       	ldd	r24, Y+2	; 0x02
     84a:	9b 81       	ldd	r25, Y+3	; 0x03
     84c:	89 17       	cp	r24, r25
     84e:	91 f0       	breq	.+36     	; 0x874 <serialTask+0x58>
		if (UCSR0A & (1 << UDRE0)) { // Si el buffer de transmisión está vacío
     850:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     854:	95 ff       	sbrs	r25, 5
     856:	0e c0       	rjmp	.+28     	; 0x874 <serialTask+0x58>
			UDR0 = dataTx->buff[dataTx->indexR++]; // Enviar el dato
     858:	e8 81       	ld	r30, Y
     85a:	f9 81       	ldd	r31, Y+1	; 0x01
     85c:	91 e0       	ldi	r25, 0x01	; 1
     85e:	98 0f       	add	r25, r24
     860:	9a 83       	std	Y+2, r25	; 0x02
     862:	e8 0f       	add	r30, r24
     864:	f1 1d       	adc	r31, r1
     866:	80 81       	ld	r24, Z
     868:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
			dataTx->indexR &= dataTx->mask;
     86c:	8c 81       	ldd	r24, Y+4	; 0x04
     86e:	9a 81       	ldd	r25, Y+2	; 0x02
     870:	89 23       	and	r24, r25
     872:	8a 83       	std	Y+2, r24	; 0x02
		}
	}
}
     874:	df 91       	pop	r29
     876:	cf 91       	pop	r28
     878:	1f 91       	pop	r17
     87a:	0f 91       	pop	r16
     87c:	08 95       	ret

0000087e <sensorMeasure>:
	count200ms--;
}

void sensorMeasure(uint16_t distance){
	
	globalDistance = distance;
     87e:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <globalDistance+0x1>
     882:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <globalDistance>
     886:	08 95       	ret

00000888 <addBox>:
	
}

void addBox(){
	
		if (globalDistance > 754) { //5-6,5
     888:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <globalDistance>
     88c:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <globalDistance+0x1>
     890:	83 3f       	cpi	r24, 0xF3	; 243
     892:	22 e0       	ldi	r18, 0x02	; 2
     894:	92 07       	cpc	r25, r18
     896:	78 f0       	brcs	.+30     	; 0x8b6 <addBox+0x2e>
			Cajita[Numbox].boxState=isOn;
     898:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <Numbox>
     89c:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <Numbox+0x1>
     8a0:	ee 0f       	add	r30, r30
     8a2:	ff 1f       	adc	r31, r31
     8a4:	e9 59       	subi	r30, 0x99	; 153
     8a6:	fc 4f       	sbci	r31, 0xFC	; 252
     8a8:	11 82       	std	Z+1, r1	; 0x01
			Cajita[Numbox].boxSize=SmallBox;
     8aa:	81 e0       	ldi	r24, 0x01	; 1
     8ac:	80 83       	st	Z, r24
			boxToTx = 0x4;
     8ae:	84 e0       	ldi	r24, 0x04	; 4
     8b0:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <boxToTx>
     8b4:	2d c0       	rjmp	.+90     	; 0x910 <__stack+0x11>
		}
		else if (globalDistance >= boxSizeconfig.mediumboxC && globalDistance < boxSizeconfig.mediumboxF) { //7 -8,5
     8b6:	20 91 30 02 	lds	r18, 0x0230	; 0x800230 <boxSizeconfig+0x6>
     8ba:	30 91 31 02 	lds	r19, 0x0231	; 0x800231 <boxSizeconfig+0x7>
     8be:	82 17       	cp	r24, r18
     8c0:	93 07       	cpc	r25, r19
     8c2:	a8 f0       	brcs	.+42     	; 0x8ee <addBox+0x66>
     8c4:	20 91 2e 02 	lds	r18, 0x022E	; 0x80022e <boxSizeconfig+0x4>
     8c8:	30 91 2f 02 	lds	r19, 0x022F	; 0x80022f <boxSizeconfig+0x5>
     8cc:	82 17       	cp	r24, r18
     8ce:	93 07       	cpc	r25, r19
     8d0:	70 f4       	brcc	.+28     	; 0x8ee <addBox+0x66>
			Cajita[Numbox].boxState=isOn;
     8d2:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <Numbox>
     8d6:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <Numbox+0x1>
     8da:	ee 0f       	add	r30, r30
     8dc:	ff 1f       	adc	r31, r31
     8de:	e9 59       	subi	r30, 0x99	; 153
     8e0:	fc 4f       	sbci	r31, 0xFC	; 252
     8e2:	11 82       	std	Z+1, r1	; 0x01
			Cajita[Numbox].boxSize=MediumBox;
     8e4:	82 e0       	ldi	r24, 0x02	; 2
     8e6:	80 83       	st	Z, r24
			boxToTx = 0x2;
     8e8:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <boxToTx>
     8ec:	11 c0       	rjmp	.+34     	; 0x910 <__stack+0x11>
		}
		else if (globalDistance < 638) { //9-11
     8ee:	8e 37       	cpi	r24, 0x7E	; 126
     8f0:	92 40       	sbci	r25, 0x02	; 2
     8f2:	70 f4       	brcc	.+28     	; 0x910 <__stack+0x11>
			Cajita[Numbox].boxState=isOn;
     8f4:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <Numbox>
     8f8:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <Numbox+0x1>
     8fc:	ee 0f       	add	r30, r30
     8fe:	ff 1f       	adc	r31, r31
     900:	e9 59       	subi	r30, 0x99	; 153
     902:	fc 4f       	sbci	r31, 0xFC	; 252
     904:	11 82       	std	Z+1, r1	; 0x01
			Cajita[Numbox].boxSize=LargeBox;
     906:	83 e0       	ldi	r24, 0x03	; 3
     908:	80 83       	st	Z, r24
			boxToTx = 0x1;
     90a:	81 e0       	ldi	r24, 0x01	; 1
     90c:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <boxToTx>
		}
		//else if (globalDistance < 290 && globalDistance > Cm15){
			//Cajita[Numbox].boxSize=NotSelected;
			//boxToTx = 0x00;
		//}
		Numbox++;
     910:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Numbox>
     914:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Numbox+0x1>
     918:	01 96       	adiw	r24, 0x01	; 1
     91a:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <Numbox+0x1>
     91e:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <Numbox>
	
		if(Numbox>=bufferBox) //reinicio el buffer
     922:	0f 97       	sbiw	r24, 0x0f	; 15
     924:	20 f0       	brcs	.+8      	; 0x92e <__stack+0x2f>
			Numbox=0;
     926:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <Numbox+0x1>
     92a:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <Numbox>
     92e:	08 95       	ret

00000930 <newBox>:
	
}

void newBox(uint16_t distance){
	if(distance<Cm18){
     930:	8c 34       	cpi	r24, 0x4C	; 76
     932:	94 40       	sbci	r25, 0x04	; 4
     934:	f0 f4       	brcc	.+60     	; 0x972 <newBox+0x42>
		if((IR_GetState(&ir_sensor[0]) == 0) && !MEASURINGBOX){
     936:	87 e5       	ldi	r24, 0x57	; 87
     938:	92 e0       	ldi	r25, 0x02	; 2
     93a:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     93e:	81 11       	cpse	r24, r1
     940:	0d c0       	rjmp	.+26     	; 0x95c <newBox+0x2c>
     942:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     946:	81 fd       	sbrc	r24, 1
     948:	09 c0       	rjmp	.+18     	; 0x95c <newBox+0x2c>
			MEASURINGBOX=TRUE;
     94a:	82 60       	ori	r24, 0x02	; 2
     94c:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <flag0>
			addBox();
     950:	0e 94 44 04 	call	0x888	; 0x888 <addBox>
			PORTB ^=(1<<LED_BI);
     954:	95 b1       	in	r25, 0x05	; 5
     956:	80 e2       	ldi	r24, 0x20	; 32
     958:	89 27       	eor	r24, r25
     95a:	85 b9       	out	0x05, r24	; 5
		}
		if ((IR_GetState(&ir_sensor[0]) == 1)) //si IR no mide
     95c:	87 e5       	ldi	r24, 0x57	; 87
     95e:	92 e0       	ldi	r25, 0x02	; 2
     960:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     964:	81 30       	cpi	r24, 0x01	; 1
     966:	29 f4       	brne	.+10     	; 0x972 <newBox+0x42>
				MEASURINGBOX=FALSE;
     968:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     96c:	8d 7f       	andi	r24, 0xFD	; 253
     96e:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <flag0>
     972:	08 95       	ret

00000974 <kickBox>:
	
	static uint8_t read1=0;
	static uint8_t read2=0;
	static uint8_t read3=0;
	
	if (IR_GetState(&ir_sensor[1])==0){
     974:	8b e5       	ldi	r24, 0x5B	; 91
     976:	92 e0       	ldi	r25, 0x02	; 2
     978:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     97c:	81 11       	cpse	r24, r1
     97e:	19 c0       	rjmp	.+50     	; 0x9b2 <kickBox+0x3e>
		if(ir_sensor[1].irType == Cajita[read1].boxSize){
     980:	90 91 5e 02 	lds	r25, 0x025E	; 0x80025e <ir_sensor+0x7>
     984:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <read1.2075>
     988:	f0 e0       	ldi	r31, 0x00	; 0
     98a:	ee 0f       	add	r30, r30
     98c:	ff 1f       	adc	r31, r31
     98e:	e9 59       	subi	r30, 0x99	; 153
     990:	fc 4f       	sbci	r31, 0xFC	; 252
     992:	80 81       	ld	r24, Z
     994:	98 13       	cpse	r25, r24
     996:	0d c0       	rjmp	.+26     	; 0x9b2 <kickBox+0x3e>
			servo_Angle(0,0);
     998:	60 e0       	ldi	r22, 0x00	; 0
     99a:	80 e0       	ldi	r24, 0x00	; 0
     99c:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
			Cajita[read1].boxState=isOut;
     9a0:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <read1.2075>
     9a4:	f0 e0       	ldi	r31, 0x00	; 0
     9a6:	ee 0f       	add	r30, r30
     9a8:	ff 1f       	adc	r31, r31
     9aa:	e9 59       	subi	r30, 0x99	; 153
     9ac:	fc 4f       	sbci	r31, 0xFC	; 252
     9ae:	82 e0       	ldi	r24, 0x02	; 2
     9b0:	81 83       	std	Z+1, r24	; 0x01
		}

	}
	if (IR_GetState(&ir_sensor[2])==0){
     9b2:	8f e5       	ldi	r24, 0x5F	; 95
     9b4:	92 e0       	ldi	r25, 0x02	; 2
     9b6:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     9ba:	81 11       	cpse	r24, r1
     9bc:	1e c0       	rjmp	.+60     	; 0x9fa <kickBox+0x86>
		if(ir_sensor[2].irType == Cajita[read2].boxSize){
     9be:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <ir_sensor+0xb>
     9c2:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <read2.2076>
     9c6:	f0 e0       	ldi	r31, 0x00	; 0
     9c8:	ee 0f       	add	r30, r30
     9ca:	ff 1f       	adc	r31, r31
     9cc:	e9 59       	subi	r30, 0x99	; 153
     9ce:	fc 4f       	sbci	r31, 0xFC	; 252
     9d0:	80 81       	ld	r24, Z
     9d2:	98 13       	cpse	r25, r24
     9d4:	0d c0       	rjmp	.+26     	; 0x9f0 <kickBox+0x7c>
			servo_Angle(1,0);
     9d6:	60 e0       	ldi	r22, 0x00	; 0
     9d8:	81 e0       	ldi	r24, 0x01	; 1
     9da:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
			Cajita[read2].boxState=isOut;
     9de:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <read2.2076>
     9e2:	f0 e0       	ldi	r31, 0x00	; 0
     9e4:	ee 0f       	add	r30, r30
     9e6:	ff 1f       	adc	r31, r31
     9e8:	e9 59       	subi	r30, 0x99	; 153
     9ea:	fc 4f       	sbci	r31, 0xFC	; 252
     9ec:	82 e0       	ldi	r24, 0x02	; 2
     9ee:	81 83       	std	Z+1, r24	; 0x01
		}
		read2++;
     9f0:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <read2.2076>
     9f4:	8f 5f       	subi	r24, 0xFF	; 255
     9f6:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <read2.2076>
	}
	if (IR_GetState(&ir_sensor[3])==0){
     9fa:	83 e6       	ldi	r24, 0x63	; 99
     9fc:	92 e0       	ldi	r25, 0x02	; 2
     9fe:	0e 94 4d 02 	call	0x49a	; 0x49a <IR_GetState>
     a02:	81 11       	cpse	r24, r1
     a04:	1e c0       	rjmp	.+60     	; 0xa42 <kickBox+0xce>
		if(ir_sensor[3].irType == Cajita[read3].boxSize){
     a06:	90 91 66 02 	lds	r25, 0x0266	; 0x800266 <ir_sensor+0xf>
     a0a:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <read3.2077>
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	ee 0f       	add	r30, r30
     a12:	ff 1f       	adc	r31, r31
     a14:	e9 59       	subi	r30, 0x99	; 153
     a16:	fc 4f       	sbci	r31, 0xFC	; 252
     a18:	80 81       	ld	r24, Z
     a1a:	98 13       	cpse	r25, r24
     a1c:	0d c0       	rjmp	.+26     	; 0xa38 <kickBox+0xc4>
			servo_Angle(2,0);
     a1e:	60 e0       	ldi	r22, 0x00	; 0
     a20:	82 e0       	ldi	r24, 0x02	; 2
     a22:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
			Cajita[read3].boxState=isOut;
     a26:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <read3.2077>
     a2a:	f0 e0       	ldi	r31, 0x00	; 0
     a2c:	ee 0f       	add	r30, r30
     a2e:	ff 1f       	adc	r31, r31
     a30:	e9 59       	subi	r30, 0x99	; 153
     a32:	fc 4f       	sbci	r31, 0xFC	; 252
     a34:	82 e0       	ldi	r24, 0x02	; 2
     a36:	81 83       	std	Z+1, r24	; 0x01
		}
		read3++;
     a38:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <read3.2077>
     a3c:	8f 5f       	subi	r24, 0xFF	; 255
     a3e:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <read3.2077>
	}
	if(read1>=bufferBox)
     a42:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <read1.2075>
     a46:	8f 30       	cpi	r24, 0x0F	; 15
     a48:	10 f0       	brcs	.+4      	; 0xa4e <kickBox+0xda>
		read1=0;
     a4a:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <read1.2075>
	if(read2>=bufferBox)
     a4e:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <read2.2076>
     a52:	8f 30       	cpi	r24, 0x0F	; 15
     a54:	10 f0       	brcs	.+4      	; 0xa5a <kickBox+0xe6>
		read2=0;
     a56:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <read2.2076>
	if(read3>=bufferBox)
     a5a:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <read3.2077>
     a5e:	8f 30       	cpi	r24, 0x0F	; 15
     a60:	10 f0       	brcs	.+4      	; 0xa66 <kickBox+0xf2>
		read3=0;
     a62:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <read3.2077>
     a66:	08 95       	ret

00000a68 <servoreset>:
	
}
void servoreset(){
	servo_Angle(0,90);
     a68:	6a e5       	ldi	r22, 0x5A	; 90
     a6a:	80 e0       	ldi	r24, 0x00	; 0
     a6c:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
	servo_Angle(1,90);
     a70:	6a e5       	ldi	r22, 0x5A	; 90
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
	servo_Angle(2,90);
     a78:	6a e5       	ldi	r22, 0x5A	; 90
     a7a:	82 e0       	ldi	r24, 0x02	; 2
     a7c:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
     a80:	08 95       	ret

00000a82 <every10ms>:
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}

void every10ms(){
     a82:	cf 93       	push	r28
     a84:	df 93       	push	r29
	
	if (!count100ms){		//Si pasaron 100ms
     a86:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <count100ms>
     a8a:	81 11       	cpse	r24, r1
     a8c:	1f c0       	rjmp	.+62     	; 0xacc <every10ms+0x4a>

uint32_t	HCSR_1;
uint16_t	aux16 = 0;

static inline void on_reset_hcsr(){
	aux16 = TCNT1;								// Loads actual time in TCNT1 into aux16
     a8e:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
     a92:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
	aux16 += 20;								// 20*500ns = 10us (tiempo del trigger), Adds 10 (us) to the previously saved time at TCNT1
     a96:	44 96       	adiw	r24, 0x14	; 20
     a98:	90 93 14 01 	sts	0x0114, r25	; 0x800114 <aux16+0x1>
     a9c:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <aux16>
	OCR1B = aux16;								// Then loads the value into OCR1B, generating an Output Compare Interrupt
     aa0:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7f808b>
     aa4:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7f808a>
	TIFR1 = (1<<OCF1B) | (1<<OCF1A);			// Flag set after the counter value in TCNT1 equals OCR1A and OCR1B
     aa8:	86 e0       	ldi	r24, 0x06	; 6
     aaa:	86 bb       	out	0x16, r24	; 22
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
     aac:	84 e0       	ldi	r24, 0x04	; 4
     aae:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
     ab2:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <HCSR_1>
     ab6:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <HCSR_1+0x1>
     aba:	0e 94 87 00 	call	0x10e	; 0x10e <HCSR04_Start>
		on_reset_hcsr();
		count100ms = 10;
     abe:	8a e0       	ldi	r24, 0x0A	; 10
     ac0:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <count100ms>
		PORTB ^= (1<<LED_BI);
     ac4:	95 b1       	in	r25, 0x05	; 5
     ac6:	80 e2       	ldi	r24, 0x20	; 32
     ac8:	89 27       	eor	r24, r25
     aca:	85 b9       	out	0x05, r24	; 5
	}
	
	if (!count40ms){
     acc:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <count40ms>
     ad0:	88 23       	and	r24, r24
     ad2:	81 f0       	breq	.+32     	; 0xaf4 <every10ms+0x72>
     ad4:	1f c0       	rjmp	.+62     	; 0xb14 <every10ms+0x92>
		for(int i=0;i<4;i++){
			IR_Update(&ir_sensor[i], raw_input[i]);
     ad6:	fe 01       	movw	r30, r28
     ad8:	e8 5b       	subi	r30, 0xB8	; 184
     ada:	fd 4f       	sbci	r31, 0xFD	; 253
     adc:	ce 01       	movw	r24, r28
     ade:	88 0f       	add	r24, r24
     ae0:	99 1f       	adc	r25, r25
     ae2:	88 0f       	add	r24, r24
     ae4:	99 1f       	adc	r25, r25
     ae6:	60 81       	ld	r22, Z
     ae8:	89 5a       	subi	r24, 0xA9	; 169
     aea:	9d 4f       	sbci	r25, 0xFD	; 253
     aec:	0e 94 19 02 	call	0x432	; 0x432 <IR_Update>
		count100ms = 10;
		PORTB ^= (1<<LED_BI);
	}
	
	if (!count40ms){
		for(int i=0;i<4;i++){
     af0:	21 96       	adiw	r28, 0x01	; 1
     af2:	02 c0       	rjmp	.+4      	; 0xaf8 <every10ms+0x76>
     af4:	c0 e0       	ldi	r28, 0x00	; 0
     af6:	d0 e0       	ldi	r29, 0x00	; 0
     af8:	c4 30       	cpi	r28, 0x04	; 4
     afa:	d1 05       	cpc	r29, r1
     afc:	64 f3       	brlt	.-40     	; 0xad6 <every10ms+0x54>
			IR_Update(&ir_sensor[i], raw_input[i]);
		}
		count40ms = 4;
     afe:	84 e0       	ldi	r24, 0x04	; 4
     b00:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <count40ms>
		newBox(globalDistance);
     b04:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <globalDistance>
     b08:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <globalDistance+0x1>
     b0c:	0e 94 98 04 	call	0x930	; 0x930 <newBox>
		kickBox();
     b10:	0e 94 ba 04 	call	0x974	; 0x974 <kickBox>
	}
	if (!count200ms){
     b14:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <count200ms>
     b18:	81 11       	cpse	r24, r1
     b1a:	05 c0       	rjmp	.+10     	; 0xb26 <every10ms+0xa4>
			servoreset();
     b1c:	0e 94 34 05 	call	0xa68	; 0xa68 <servoreset>
			count200ms = 60;
     b20:	8c e3       	ldi	r24, 0x3C	; 60
     b22:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <count200ms>
			
	}
	raw_input[0] = (PIND & (1<<IR0)) ? 1 : 0;
     b26:	89 b1       	in	r24, 0x09	; 9
     b28:	82 fb       	bst	r24, 2
     b2a:	88 27       	eor	r24, r24
     b2c:	80 f9       	bld	r24, 0
     b2e:	e8 e4       	ldi	r30, 0x48	; 72
     b30:	f2 e0       	ldi	r31, 0x02	; 2
     b32:	80 83       	st	Z, r24
	raw_input[1] = (PIND & (1<<IR1)) ? 1 : 0;
     b34:	89 b1       	in	r24, 0x09	; 9
     b36:	83 fb       	bst	r24, 3
     b38:	88 27       	eor	r24, r24
     b3a:	80 f9       	bld	r24, 0
     b3c:	81 83       	std	Z+1, r24	; 0x01
	raw_input[2] = (PIND & (1<<IR2)) ? 1 : 0;
     b3e:	89 b1       	in	r24, 0x09	; 9
     b40:	82 95       	swap	r24
     b42:	81 70       	andi	r24, 0x01	; 1
     b44:	82 83       	std	Z+2, r24	; 0x02
	raw_input[3] = (PIND & (1<<IR3)) ? 1 : 0;
     b46:	89 b1       	in	r24, 0x09	; 9
     b48:	85 fb       	bst	r24, 5
     b4a:	88 27       	eor	r24, r24
     b4c:	80 f9       	bld	r24, 0
     b4e:	83 83       	std	Z+3, r24	; 0x03
	
	IS10MS = FALSE;
     b50:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     b54:	8e 7f       	andi	r24, 0xFE	; 254
     b56:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <flag0>
	count100ms--;
     b5a:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <count100ms>
     b5e:	81 50       	subi	r24, 0x01	; 1
     b60:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <count100ms>
	count40ms--;
     b64:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <count40ms>
     b68:	81 50       	subi	r24, 0x01	; 1
     b6a:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <count40ms>
	count200ms--;
     b6e:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <count200ms>
     b72:	81 50       	subi	r24, 0x01	; 1
     b74:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <count200ms>
}
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	08 95       	ret

00000b7e <main>:
}
/* END Function prototypes user code ------------------------------------------*/

int main(){
	
	cli();
     b7e:	f8 94       	cli

	/* END Local variables -------------------------------------------------------*/


	/* User code Init ------------------------------------------------------------*/
	flag0.byte = 0;
     b80:	10 92 47 02 	sts	0x0247, r1	; 0x800247 <flag0>
	
	ini_ports();
     b84:	0e 94 c8 01 	call	0x390	; 0x390 <ini_ports>
	ini_timer1();
     b88:	0e 94 d7 01 	call	0x3ae	; 0x3ae <ini_timer1>
	ini_timer0();
     b8c:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <ini_timer0>
	ini_USART(16);
     b90:	80 e1       	ldi	r24, 0x10	; 16
     b92:	0e 94 f6 01 	call	0x3ec	; 0x3ec <ini_USART>
	
	IR_Init(&ir_sensor[0]);
     b96:	87 e5       	ldi	r24, 0x57	; 87
     b98:	92 e0       	ldi	r25, 0x02	; 2
     b9a:	0e 94 04 02 	call	0x408	; 0x408 <IR_Init>
	
	addServo(&PORTD,SV0);
     b9e:	67 e0       	ldi	r22, 0x07	; 7
     ba0:	8b e2       	ldi	r24, 0x2B	; 43
     ba2:	90 e0       	ldi	r25, 0x00	; 0
     ba4:	0e 94 44 06 	call	0xc88	; 0xc88 <addServo>
	addServo(&PORTB,SV1);
     ba8:	64 e0       	ldi	r22, 0x04	; 4
     baa:	85 e2       	ldi	r24, 0x25	; 37
     bac:	90 e0       	ldi	r25, 0x00	; 0
     bae:	0e 94 44 06 	call	0xc88	; 0xc88 <addServo>
	addServo(&PORTB,SV2);
     bb2:	63 e0       	ldi	r22, 0x03	; 3
     bb4:	85 e2       	ldi	r24, 0x25	; 37
     bb6:	90 e0       	ldi	r25, 0x00	; 0
     bb8:	0e 94 44 06 	call	0xc88	; 0xc88 <addServo>
	servo_Angle(0,90);
     bbc:	6a e5       	ldi	r22, 0x5A	; 90
     bbe:	80 e0       	ldi	r24, 0x00	; 0
     bc0:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
	servo_Angle(1,90);
     bc4:	6a e5       	ldi	r22, 0x5A	; 90
     bc6:	81 e0       	ldi	r24, 0x01	; 1
     bc8:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
	servo_Angle(2,90);
     bcc:	6a e5       	ldi	r22, 0x5A	; 90
     bce:	82 e0       	ldi	r24, 0x02	; 2
     bd0:	0e 94 58 06 	call	0xcb0	; 0xcb0 <servo_Angle>
	HCSR_1 = HCSR04_AddNew(&WritePin_HCSR, 16);
     bd4:	40 e1       	ldi	r20, 0x10	; 16
     bd6:	50 e0       	ldi	r21, 0x00	; 0
     bd8:	60 e0       	ldi	r22, 0x00	; 0
     bda:	70 e0       	ldi	r23, 0x00	; 0
     bdc:	88 ed       	ldi	r24, 0xD8	; 216
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	0e 94 5a 00 	call	0xb4	; 0xb4 <HCSR04_AddNew>
     be4:	a0 e0       	ldi	r26, 0x00	; 0
     be6:	b0 e0       	ldi	r27, 0x00	; 0
     be8:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <HCSR_1>
     bec:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <HCSR_1+0x1>
     bf0:	a0 93 27 01 	sts	0x0127, r26	; 0x800127 <HCSR_1+0x2>
     bf4:	b0 93 28 01 	sts	0x0128, r27	; 0x800128 <HCSR_1+0x3>
	
	Numbox = 255;
     bf8:	8f ef       	ldi	r24, 0xFF	; 255
     bfa:	90 e0       	ldi	r25, 0x00	; 0
     bfc:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <Numbox+0x1>
     c00:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <Numbox>
	
	dataRx.buff = (uint8_t *)buffRx;
     c04:	e6 e3       	ldi	r30, 0x36	; 54
     c06:	f2 e0       	ldi	r31, 0x02	; 2
     c08:	8a e2       	ldi	r24, 0x2A	; 42
     c0a:	91 e0       	ldi	r25, 0x01	; 1
     c0c:	91 83       	std	Z+1, r25	; 0x01
     c0e:	80 83       	st	Z, r24
	dataRx.indexR = 0;
     c10:	12 82       	std	Z+2, r1	; 0x02
	dataRx.indexW = 0;
     c12:	13 82       	std	Z+3, r1	; 0x03
	dataRx.header = HEADER_U;
     c14:	10 86       	std	Z+8, r1	; 0x08
	dataRx.mask = RXBUFSIZE - 1;
     c16:	8f ef       	ldi	r24, 0xFF	; 255
     c18:	85 83       	std	Z+5, r24	; 0x05
	
	dataTx.buff = buffTx;
     c1a:	e1 e4       	ldi	r30, 0x41	; 65
     c1c:	f2 e0       	ldi	r31, 0x02	; 2
     c1e:	27 e6       	ldi	r18, 0x67	; 103
     c20:	32 e0       	ldi	r19, 0x02	; 2
     c22:	31 83       	std	Z+1, r19	; 0x01
     c24:	20 83       	st	Z, r18
	dataTx.indexR = 0;
     c26:	12 82       	std	Z+2, r1	; 0x02
	dataTx.indexW = 0;
     c28:	13 82       	std	Z+3, r1	; 0x03
	dataTx.mask = TXBUFSIZE -1;
     c2a:	84 83       	std	Z+4, r24	; 0x04
	
	boxSizeconfig.smallboxF=Cm15;
     c2c:	ea e2       	ldi	r30, 0x2A	; 42
     c2e:	f2 e0       	ldi	r31, 0x02	; 2
     c30:	86 e6       	ldi	r24, 0x66	; 102
     c32:	93 e0       	ldi	r25, 0x03	; 3
     c34:	91 83       	std	Z+1, r25	; 0x01
     c36:	80 83       	st	Z, r24
	boxSizeconfig.smallboxC=Cm13;
     c38:	82 ef       	ldi	r24, 0xF2	; 242
     c3a:	92 e0       	ldi	r25, 0x02	; 2
     c3c:	93 83       	std	Z+3, r25	; 0x03
     c3e:	82 83       	std	Z+2, r24	; 0x02
	boxSizeconfig.mediumboxF=Cm13;
     c40:	95 83       	std	Z+5, r25	; 0x05
     c42:	84 83       	std	Z+4, r24	; 0x04
	boxSizeconfig.mediumboxC=Cm11;
     c44:	8e e7       	ldi	r24, 0x7E	; 126
     c46:	92 e0       	ldi	r25, 0x02	; 2
     c48:	97 83       	std	Z+7, r25	; 0x07
     c4a:	86 83       	std	Z+6, r24	; 0x06
	boxSizeconfig.largeboxF=Cm11;
     c4c:	91 87       	std	Z+9, r25	; 0x09
     c4e:	80 87       	std	Z+8, r24	; 0x08
	boxSizeconfig.largeboxC=Cm9;
     c50:	8a e0       	ldi	r24, 0x0A	; 10
     c52:	92 e0       	ldi	r25, 0x02	; 2
     c54:	93 87       	std	Z+11, r25	; 0x0b
     c56:	82 87       	std	Z+10, r24	; 0x0a
	
	ir_sensor[1].irType = SmallBox;
     c58:	e7 e5       	ldi	r30, 0x57	; 87
     c5a:	f2 e0       	ldi	r31, 0x02	; 2
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	87 83       	std	Z+7, r24	; 0x07
	ir_sensor[2].irType = MediumBox;
     c60:	82 e0       	ldi	r24, 0x02	; 2
     c62:	83 87       	std	Z+11, r24	; 0x0b
	ir_sensor[3].irType = LargeBox;
     c64:	83 e0       	ldi	r24, 0x03	; 3
     c66:	87 87       	std	Z+15, r24	; 0x0f
	
	/* END User code Init --------------------------------------------------------*/
	sei();
     c68:	78 94       	sei

	while (1){
		/* User Code loop ------------------------------------------------------------*/
		task_HCSR();
     c6a:	0e 94 af 00 	call	0x15e	; 0x15e <task_HCSR>
		serialTask(&dataRx,&dataTx);
     c6e:	61 e4       	ldi	r22, 0x41	; 65
     c70:	72 e0       	ldi	r23, 0x02	; 2
     c72:	86 e3       	ldi	r24, 0x36	; 54
     c74:	92 e0       	ldi	r25, 0x02	; 2
     c76:	0e 94 0e 04 	call	0x81c	; 0x81c <serialTask>
		if (IS10MS)
     c7a:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <flag0>
     c7e:	80 ff       	sbrs	r24, 0
     c80:	f4 cf       	rjmp	.-24     	; 0xc6a <main+0xec>
			every10ms();
     c82:	0e 94 41 05 	call	0xa82	; 0xa82 <every10ms>
     c86:	f1 cf       	rjmp	.-30     	; 0xc6a <main+0xec>

00000c88 <addServo>:
static uint8_t ServN = 0;
volatile static uint8_t is20ms=156;
 
void addServo(volatile uint8_t* PORT,uint8_t Pin){
	
	servoHandle[ServN].pin=Pin;
     c88:	20 91 15 01 	lds	r18, 0x0115	; 0x800115 <ServN>
     c8c:	e2 2f       	mov	r30, r18
     c8e:	f0 e0       	ldi	r31, 0x00	; 0
     c90:	af 01       	movw	r20, r30
     c92:	44 0f       	add	r20, r20
     c94:	55 1f       	adc	r21, r21
     c96:	44 0f       	add	r20, r20
     c98:	55 1f       	adc	r21, r21
     c9a:	e4 0f       	add	r30, r20
     c9c:	f5 1f       	adc	r31, r21
     c9e:	ea 5e       	subi	r30, 0xEA	; 234
     ca0:	fe 4f       	sbci	r31, 0xFE	; 254
     ca2:	62 83       	std	Z+2, r22	; 0x02
	servoHandle[ServN].port=PORT;
     ca4:	91 83       	std	Z+1, r25	; 0x01
     ca6:	80 83       	st	Z, r24
	ServN++;
     ca8:	2f 5f       	subi	r18, 0xFF	; 255
     caa:	20 93 15 01 	sts	0x0115, r18	; 0x800115 <ServN>
     cae:	08 95       	ret

00000cb0 <servo_Angle>:
}
void servo_Angle(uint8_t servo,uint8_t angulo){
     cb0:	48 2f       	mov	r20, r24
	
	uint16_t riseValue;
	
	riseValue = (uint16_t)angulo * ANGLE_TO_PWM_SLOPE;
     cb2:	85 e7       	ldi	r24, 0x75	; 117
     cb4:	68 9f       	mul	r22, r24
     cb6:	90 01       	movw	r18, r0
     cb8:	11 24       	eor	r1, r1
	riseValue += ANGLE_TO_PWM_OFFSET;
     cba:	2e 5c       	subi	r18, 0xCE	; 206
     cbc:	36 4d       	sbci	r19, 0xD6	; 214
	riseValue /= 180;
     cbe:	a3 e8       	ldi	r26, 0x83	; 131
     cc0:	bd e2       	ldi	r27, 0x2D	; 45
     cc2:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <__umulhisi3>
     cc6:	96 95       	lsr	r25
     cc8:	87 95       	ror	r24
     cca:	92 95       	swap	r25
     ccc:	82 95       	swap	r24
     cce:	8f 70       	andi	r24, 0x0F	; 15
     cd0:	89 27       	eor	r24, r25
     cd2:	9f 70       	andi	r25, 0x0F	; 15
     cd4:	89 27       	eor	r24, r25
	riseValue += ROUNDING_CORRECTION;
     cd6:	9c 01       	movw	r18, r24
     cd8:	2b 5f       	subi	r18, 0xFB	; 251
     cda:	3f 4f       	sbci	r19, 0xFF	; 255
	riseValue /= 10;
     cdc:	ad ec       	ldi	r26, 0xCD	; 205
     cde:	bc ec       	ldi	r27, 0xCC	; 204
     ce0:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <__umulhisi3>
     ce4:	96 95       	lsr	r25
     ce6:	87 95       	ror	r24
     ce8:	96 95       	lsr	r25
     cea:	87 95       	ror	r24
     cec:	96 95       	lsr	r25
     cee:	87 95       	ror	r24
		
	servoHandle[servo].dutyCycle = (uint8_t)riseValue;
     cf0:	24 2f       	mov	r18, r20
     cf2:	30 e0       	ldi	r19, 0x00	; 0
     cf4:	f9 01       	movw	r30, r18
     cf6:	ee 0f       	add	r30, r30
     cf8:	ff 1f       	adc	r31, r31
     cfa:	ee 0f       	add	r30, r30
     cfc:	ff 1f       	adc	r31, r31
     cfe:	2e 0f       	add	r18, r30
     d00:	3f 1f       	adc	r19, r31
     d02:	f9 01       	movw	r30, r18
     d04:	ea 5e       	subi	r30, 0xEA	; 234
     d06:	fe 4f       	sbci	r31, 0xFE	; 254
     d08:	84 83       	std	Z+4, r24	; 0x04
     d0a:	08 95       	ret

00000d0c <writeServo>:
}

void writeServo(){
	is20ms--;
     d0c:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <is20ms>
     d10:	81 50       	subi	r24, 0x01	; 1
     d12:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <is20ms>
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     d16:	20 e0       	ldi	r18, 0x00	; 0
     d18:	2a c0       	rjmp	.+84     	; 0xd6e <writeServo+0x62>
		servoHandle[counter].cycle--;
     d1a:	82 2f       	mov	r24, r18
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	fc 01       	movw	r30, r24
     d20:	ee 0f       	add	r30, r30
     d22:	ff 1f       	adc	r31, r31
     d24:	ee 0f       	add	r30, r30
     d26:	ff 1f       	adc	r31, r31
     d28:	e8 0f       	add	r30, r24
     d2a:	f9 1f       	adc	r31, r25
     d2c:	ea 5e       	subi	r30, 0xEA	; 234
     d2e:	fe 4f       	sbci	r31, 0xFE	; 254
     d30:	33 81       	ldd	r19, Z+3	; 0x03
     d32:	31 50       	subi	r19, 0x01	; 1
     d34:	33 83       	std	Z+3, r19	; 0x03
		if(!servoHandle[counter].cycle)
     d36:	33 81       	ldd	r19, Z+3	; 0x03
     d38:	31 11       	cpse	r19, r1
     d3a:	18 c0       	rjmp	.+48     	; 0xd6c <writeServo+0x60>
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
     d3c:	fc 01       	movw	r30, r24
     d3e:	ee 0f       	add	r30, r30
     d40:	ff 1f       	adc	r31, r31
     d42:	ee 0f       	add	r30, r30
     d44:	ff 1f       	adc	r31, r31
     d46:	8e 0f       	add	r24, r30
     d48:	9f 1f       	adc	r25, r31
     d4a:	fc 01       	movw	r30, r24
     d4c:	ea 5e       	subi	r30, 0xEA	; 234
     d4e:	fe 4f       	sbci	r31, 0xFE	; 254
     d50:	a0 81       	ld	r26, Z
     d52:	b1 81       	ldd	r27, Z+1	; 0x01
     d54:	3c 91       	ld	r19, X
     d56:	81 e0       	ldi	r24, 0x01	; 1
     d58:	90 e0       	ldi	r25, 0x00	; 0
     d5a:	02 80       	ldd	r0, Z+2	; 0x02
     d5c:	02 c0       	rjmp	.+4      	; 0xd62 <writeServo+0x56>
     d5e:	88 0f       	add	r24, r24
     d60:	99 1f       	adc	r25, r25
     d62:	0a 94       	dec	r0
     d64:	e2 f7       	brpl	.-8      	; 0xd5e <writeServo+0x52>
     d66:	80 95       	com	r24
     d68:	83 23       	and	r24, r19
     d6a:	8c 93       	st	X, r24
void writeServo(){
	is20ms--;
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     d6c:	2f 5f       	subi	r18, 0xFF	; 255
     d6e:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <ServN>
     d72:	28 17       	cp	r18, r24
     d74:	90 f2       	brcs	.-92     	; 0xd1a <writeServo+0xe>
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
     d76:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <is20ms>
     d7a:	99 23       	and	r25, r25
     d7c:	e9 f0       	breq	.+58     	; 0xdb8 <writeServo+0xac>
     d7e:	08 95       	ret
		for(counter = 0; counter < ServN; counter++){
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
     d80:	e9 2f       	mov	r30, r25
     d82:	f0 e0       	ldi	r31, 0x00	; 0
     d84:	9f 01       	movw	r18, r30
     d86:	22 0f       	add	r18, r18
     d88:	33 1f       	adc	r19, r19
     d8a:	22 0f       	add	r18, r18
     d8c:	33 1f       	adc	r19, r19
     d8e:	e2 0f       	add	r30, r18
     d90:	f3 1f       	adc	r31, r19
     d92:	ea 5e       	subi	r30, 0xEA	; 234
     d94:	fe 4f       	sbci	r31, 0xFE	; 254
     d96:	24 81       	ldd	r18, Z+4	; 0x04
     d98:	23 83       	std	Z+3, r18	; 0x03
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
     d9a:	a0 81       	ld	r26, Z
     d9c:	b1 81       	ldd	r27, Z+1	; 0x01
     d9e:	4c 91       	ld	r20, X
     da0:	21 e0       	ldi	r18, 0x01	; 1
     da2:	30 e0       	ldi	r19, 0x00	; 0
     da4:	02 80       	ldd	r0, Z+2	; 0x02
     da6:	02 c0       	rjmp	.+4      	; 0xdac <writeServo+0xa0>
     da8:	22 0f       	add	r18, r18
     daa:	33 1f       	adc	r19, r19
     dac:	0a 94       	dec	r0
     dae:	e2 f7       	brpl	.-8      	; 0xda8 <writeServo+0x9c>
     db0:	24 2b       	or	r18, r20
     db2:	2c 93       	st	X, r18
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
		for(counter = 0; counter < ServN; counter++){
     db4:	9f 5f       	subi	r25, 0xFF	; 255
     db6:	01 c0       	rjmp	.+2      	; 0xdba <writeServo+0xae>
     db8:	90 e0       	ldi	r25, 0x00	; 0
     dba:	98 17       	cp	r25, r24
     dbc:	08 f3       	brcs	.-62     	; 0xd80 <writeServo+0x74>
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
		}
		is20ms = 156;
     dbe:	8c e9       	ldi	r24, 0x9C	; 156
     dc0:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <is20ms>
     dc4:	08 95       	ret

00000dc6 <__tablejump2__>:
     dc6:	ee 0f       	add	r30, r30
     dc8:	ff 1f       	adc	r31, r31
     dca:	05 90       	lpm	r0, Z+
     dcc:	f4 91       	lpm	r31, Z
     dce:	e0 2d       	mov	r30, r0
     dd0:	09 94       	ijmp

00000dd2 <__umulhisi3>:
     dd2:	a2 9f       	mul	r26, r18
     dd4:	b0 01       	movw	r22, r0
     dd6:	b3 9f       	mul	r27, r19
     dd8:	c0 01       	movw	r24, r0
     dda:	a3 9f       	mul	r26, r19
     ddc:	70 0d       	add	r23, r0
     dde:	81 1d       	adc	r24, r1
     de0:	11 24       	eor	r1, r1
     de2:	91 1d       	adc	r25, r1
     de4:	b2 9f       	mul	r27, r18
     de6:	70 0d       	add	r23, r0
     de8:	81 1d       	adc	r24, r1
     dea:	11 24       	eor	r1, r1
     dec:	91 1d       	adc	r25, r1
     dee:	08 95       	ret

00000df0 <malloc>:
     df0:	0f 93       	push	r16
     df2:	1f 93       	push	r17
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	82 30       	cpi	r24, 0x02	; 2
     dfa:	91 05       	cpc	r25, r1
     dfc:	10 f4       	brcc	.+4      	; 0xe02 <malloc+0x12>
     dfe:	82 e0       	ldi	r24, 0x02	; 2
     e00:	90 e0       	ldi	r25, 0x00	; 0
     e02:	e0 91 87 03 	lds	r30, 0x0387	; 0x800387 <__flp>
     e06:	f0 91 88 03 	lds	r31, 0x0388	; 0x800388 <__flp+0x1>
     e0a:	20 e0       	ldi	r18, 0x00	; 0
     e0c:	30 e0       	ldi	r19, 0x00	; 0
     e0e:	a0 e0       	ldi	r26, 0x00	; 0
     e10:	b0 e0       	ldi	r27, 0x00	; 0
     e12:	30 97       	sbiw	r30, 0x00	; 0
     e14:	19 f1       	breq	.+70     	; 0xe5c <malloc+0x6c>
     e16:	40 81       	ld	r20, Z
     e18:	51 81       	ldd	r21, Z+1	; 0x01
     e1a:	02 81       	ldd	r16, Z+2	; 0x02
     e1c:	13 81       	ldd	r17, Z+3	; 0x03
     e1e:	48 17       	cp	r20, r24
     e20:	59 07       	cpc	r21, r25
     e22:	c8 f0       	brcs	.+50     	; 0xe56 <malloc+0x66>
     e24:	84 17       	cp	r24, r20
     e26:	95 07       	cpc	r25, r21
     e28:	69 f4       	brne	.+26     	; 0xe44 <malloc+0x54>
     e2a:	10 97       	sbiw	r26, 0x00	; 0
     e2c:	31 f0       	breq	.+12     	; 0xe3a <malloc+0x4a>
     e2e:	12 96       	adiw	r26, 0x02	; 2
     e30:	0c 93       	st	X, r16
     e32:	12 97       	sbiw	r26, 0x02	; 2
     e34:	13 96       	adiw	r26, 0x03	; 3
     e36:	1c 93       	st	X, r17
     e38:	27 c0       	rjmp	.+78     	; 0xe88 <malloc+0x98>
     e3a:	00 93 87 03 	sts	0x0387, r16	; 0x800387 <__flp>
     e3e:	10 93 88 03 	sts	0x0388, r17	; 0x800388 <__flp+0x1>
     e42:	22 c0       	rjmp	.+68     	; 0xe88 <malloc+0x98>
     e44:	21 15       	cp	r18, r1
     e46:	31 05       	cpc	r19, r1
     e48:	19 f0       	breq	.+6      	; 0xe50 <malloc+0x60>
     e4a:	42 17       	cp	r20, r18
     e4c:	53 07       	cpc	r21, r19
     e4e:	18 f4       	brcc	.+6      	; 0xe56 <malloc+0x66>
     e50:	9a 01       	movw	r18, r20
     e52:	bd 01       	movw	r22, r26
     e54:	ef 01       	movw	r28, r30
     e56:	df 01       	movw	r26, r30
     e58:	f8 01       	movw	r30, r16
     e5a:	db cf       	rjmp	.-74     	; 0xe12 <malloc+0x22>
     e5c:	21 15       	cp	r18, r1
     e5e:	31 05       	cpc	r19, r1
     e60:	f9 f0       	breq	.+62     	; 0xea0 <malloc+0xb0>
     e62:	28 1b       	sub	r18, r24
     e64:	39 0b       	sbc	r19, r25
     e66:	24 30       	cpi	r18, 0x04	; 4
     e68:	31 05       	cpc	r19, r1
     e6a:	80 f4       	brcc	.+32     	; 0xe8c <malloc+0x9c>
     e6c:	8a 81       	ldd	r24, Y+2	; 0x02
     e6e:	9b 81       	ldd	r25, Y+3	; 0x03
     e70:	61 15       	cp	r22, r1
     e72:	71 05       	cpc	r23, r1
     e74:	21 f0       	breq	.+8      	; 0xe7e <malloc+0x8e>
     e76:	fb 01       	movw	r30, r22
     e78:	93 83       	std	Z+3, r25	; 0x03
     e7a:	82 83       	std	Z+2, r24	; 0x02
     e7c:	04 c0       	rjmp	.+8      	; 0xe86 <malloc+0x96>
     e7e:	90 93 88 03 	sts	0x0388, r25	; 0x800388 <__flp+0x1>
     e82:	80 93 87 03 	sts	0x0387, r24	; 0x800387 <__flp>
     e86:	fe 01       	movw	r30, r28
     e88:	32 96       	adiw	r30, 0x02	; 2
     e8a:	44 c0       	rjmp	.+136    	; 0xf14 <malloc+0x124>
     e8c:	fe 01       	movw	r30, r28
     e8e:	e2 0f       	add	r30, r18
     e90:	f3 1f       	adc	r31, r19
     e92:	81 93       	st	Z+, r24
     e94:	91 93       	st	Z+, r25
     e96:	22 50       	subi	r18, 0x02	; 2
     e98:	31 09       	sbc	r19, r1
     e9a:	39 83       	std	Y+1, r19	; 0x01
     e9c:	28 83       	st	Y, r18
     e9e:	3a c0       	rjmp	.+116    	; 0xf14 <malloc+0x124>
     ea0:	20 91 85 03 	lds	r18, 0x0385	; 0x800385 <__brkval>
     ea4:	30 91 86 03 	lds	r19, 0x0386	; 0x800386 <__brkval+0x1>
     ea8:	23 2b       	or	r18, r19
     eaa:	41 f4       	brne	.+16     	; 0xebc <malloc+0xcc>
     eac:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
     eb0:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
     eb4:	30 93 86 03 	sts	0x0386, r19	; 0x800386 <__brkval+0x1>
     eb8:	20 93 85 03 	sts	0x0385, r18	; 0x800385 <__brkval>
     ebc:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     ec0:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     ec4:	21 15       	cp	r18, r1
     ec6:	31 05       	cpc	r19, r1
     ec8:	41 f4       	brne	.+16     	; 0xeda <malloc+0xea>
     eca:	2d b7       	in	r18, 0x3d	; 61
     ecc:	3e b7       	in	r19, 0x3e	; 62
     ece:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
     ed2:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
     ed6:	24 1b       	sub	r18, r20
     ed8:	35 0b       	sbc	r19, r21
     eda:	e0 91 85 03 	lds	r30, 0x0385	; 0x800385 <__brkval>
     ede:	f0 91 86 03 	lds	r31, 0x0386	; 0x800386 <__brkval+0x1>
     ee2:	e2 17       	cp	r30, r18
     ee4:	f3 07       	cpc	r31, r19
     ee6:	a0 f4       	brcc	.+40     	; 0xf10 <malloc+0x120>
     ee8:	2e 1b       	sub	r18, r30
     eea:	3f 0b       	sbc	r19, r31
     eec:	28 17       	cp	r18, r24
     eee:	39 07       	cpc	r19, r25
     ef0:	78 f0       	brcs	.+30     	; 0xf10 <malloc+0x120>
     ef2:	ac 01       	movw	r20, r24
     ef4:	4e 5f       	subi	r20, 0xFE	; 254
     ef6:	5f 4f       	sbci	r21, 0xFF	; 255
     ef8:	24 17       	cp	r18, r20
     efa:	35 07       	cpc	r19, r21
     efc:	48 f0       	brcs	.+18     	; 0xf10 <malloc+0x120>
     efe:	4e 0f       	add	r20, r30
     f00:	5f 1f       	adc	r21, r31
     f02:	50 93 86 03 	sts	0x0386, r21	; 0x800386 <__brkval+0x1>
     f06:	40 93 85 03 	sts	0x0385, r20	; 0x800385 <__brkval>
     f0a:	81 93       	st	Z+, r24
     f0c:	91 93       	st	Z+, r25
     f0e:	02 c0       	rjmp	.+4      	; 0xf14 <malloc+0x124>
     f10:	e0 e0       	ldi	r30, 0x00	; 0
     f12:	f0 e0       	ldi	r31, 0x00	; 0
     f14:	cf 01       	movw	r24, r30
     f16:	df 91       	pop	r29
     f18:	cf 91       	pop	r28
     f1a:	1f 91       	pop	r17
     f1c:	0f 91       	pop	r16
     f1e:	08 95       	ret

00000f20 <free>:
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	00 97       	sbiw	r24, 0x00	; 0
     f26:	09 f4       	brne	.+2      	; 0xf2a <free+0xa>
     f28:	81 c0       	rjmp	.+258    	; 0x102c <free+0x10c>
     f2a:	fc 01       	movw	r30, r24
     f2c:	32 97       	sbiw	r30, 0x02	; 2
     f2e:	13 82       	std	Z+3, r1	; 0x03
     f30:	12 82       	std	Z+2, r1	; 0x02
     f32:	a0 91 87 03 	lds	r26, 0x0387	; 0x800387 <__flp>
     f36:	b0 91 88 03 	lds	r27, 0x0388	; 0x800388 <__flp+0x1>
     f3a:	10 97       	sbiw	r26, 0x00	; 0
     f3c:	81 f4       	brne	.+32     	; 0xf5e <free+0x3e>
     f3e:	20 81       	ld	r18, Z
     f40:	31 81       	ldd	r19, Z+1	; 0x01
     f42:	82 0f       	add	r24, r18
     f44:	93 1f       	adc	r25, r19
     f46:	20 91 85 03 	lds	r18, 0x0385	; 0x800385 <__brkval>
     f4a:	30 91 86 03 	lds	r19, 0x0386	; 0x800386 <__brkval+0x1>
     f4e:	28 17       	cp	r18, r24
     f50:	39 07       	cpc	r19, r25
     f52:	51 f5       	brne	.+84     	; 0xfa8 <free+0x88>
     f54:	f0 93 86 03 	sts	0x0386, r31	; 0x800386 <__brkval+0x1>
     f58:	e0 93 85 03 	sts	0x0385, r30	; 0x800385 <__brkval>
     f5c:	67 c0       	rjmp	.+206    	; 0x102c <free+0x10c>
     f5e:	ed 01       	movw	r28, r26
     f60:	20 e0       	ldi	r18, 0x00	; 0
     f62:	30 e0       	ldi	r19, 0x00	; 0
     f64:	ce 17       	cp	r28, r30
     f66:	df 07       	cpc	r29, r31
     f68:	40 f4       	brcc	.+16     	; 0xf7a <free+0x5a>
     f6a:	4a 81       	ldd	r20, Y+2	; 0x02
     f6c:	5b 81       	ldd	r21, Y+3	; 0x03
     f6e:	9e 01       	movw	r18, r28
     f70:	41 15       	cp	r20, r1
     f72:	51 05       	cpc	r21, r1
     f74:	f1 f0       	breq	.+60     	; 0xfb2 <free+0x92>
     f76:	ea 01       	movw	r28, r20
     f78:	f5 cf       	rjmp	.-22     	; 0xf64 <free+0x44>
     f7a:	d3 83       	std	Z+3, r29	; 0x03
     f7c:	c2 83       	std	Z+2, r28	; 0x02
     f7e:	40 81       	ld	r20, Z
     f80:	51 81       	ldd	r21, Z+1	; 0x01
     f82:	84 0f       	add	r24, r20
     f84:	95 1f       	adc	r25, r21
     f86:	c8 17       	cp	r28, r24
     f88:	d9 07       	cpc	r29, r25
     f8a:	59 f4       	brne	.+22     	; 0xfa2 <free+0x82>
     f8c:	88 81       	ld	r24, Y
     f8e:	99 81       	ldd	r25, Y+1	; 0x01
     f90:	84 0f       	add	r24, r20
     f92:	95 1f       	adc	r25, r21
     f94:	02 96       	adiw	r24, 0x02	; 2
     f96:	91 83       	std	Z+1, r25	; 0x01
     f98:	80 83       	st	Z, r24
     f9a:	8a 81       	ldd	r24, Y+2	; 0x02
     f9c:	9b 81       	ldd	r25, Y+3	; 0x03
     f9e:	93 83       	std	Z+3, r25	; 0x03
     fa0:	82 83       	std	Z+2, r24	; 0x02
     fa2:	21 15       	cp	r18, r1
     fa4:	31 05       	cpc	r19, r1
     fa6:	29 f4       	brne	.+10     	; 0xfb2 <free+0x92>
     fa8:	f0 93 88 03 	sts	0x0388, r31	; 0x800388 <__flp+0x1>
     fac:	e0 93 87 03 	sts	0x0387, r30	; 0x800387 <__flp>
     fb0:	3d c0       	rjmp	.+122    	; 0x102c <free+0x10c>
     fb2:	e9 01       	movw	r28, r18
     fb4:	fb 83       	std	Y+3, r31	; 0x03
     fb6:	ea 83       	std	Y+2, r30	; 0x02
     fb8:	49 91       	ld	r20, Y+
     fba:	59 91       	ld	r21, Y+
     fbc:	c4 0f       	add	r28, r20
     fbe:	d5 1f       	adc	r29, r21
     fc0:	ec 17       	cp	r30, r28
     fc2:	fd 07       	cpc	r31, r29
     fc4:	61 f4       	brne	.+24     	; 0xfde <free+0xbe>
     fc6:	80 81       	ld	r24, Z
     fc8:	91 81       	ldd	r25, Z+1	; 0x01
     fca:	84 0f       	add	r24, r20
     fcc:	95 1f       	adc	r25, r21
     fce:	02 96       	adiw	r24, 0x02	; 2
     fd0:	e9 01       	movw	r28, r18
     fd2:	99 83       	std	Y+1, r25	; 0x01
     fd4:	88 83       	st	Y, r24
     fd6:	82 81       	ldd	r24, Z+2	; 0x02
     fd8:	93 81       	ldd	r25, Z+3	; 0x03
     fda:	9b 83       	std	Y+3, r25	; 0x03
     fdc:	8a 83       	std	Y+2, r24	; 0x02
     fde:	e0 e0       	ldi	r30, 0x00	; 0
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	12 96       	adiw	r26, 0x02	; 2
     fe4:	8d 91       	ld	r24, X+
     fe6:	9c 91       	ld	r25, X
     fe8:	13 97       	sbiw	r26, 0x03	; 3
     fea:	00 97       	sbiw	r24, 0x00	; 0
     fec:	19 f0       	breq	.+6      	; 0xff4 <free+0xd4>
     fee:	fd 01       	movw	r30, r26
     ff0:	dc 01       	movw	r26, r24
     ff2:	f7 cf       	rjmp	.-18     	; 0xfe2 <free+0xc2>
     ff4:	8d 91       	ld	r24, X+
     ff6:	9c 91       	ld	r25, X
     ff8:	11 97       	sbiw	r26, 0x01	; 1
     ffa:	9d 01       	movw	r18, r26
     ffc:	2e 5f       	subi	r18, 0xFE	; 254
     ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    1000:	82 0f       	add	r24, r18
    1002:	93 1f       	adc	r25, r19
    1004:	20 91 85 03 	lds	r18, 0x0385	; 0x800385 <__brkval>
    1008:	30 91 86 03 	lds	r19, 0x0386	; 0x800386 <__brkval+0x1>
    100c:	28 17       	cp	r18, r24
    100e:	39 07       	cpc	r19, r25
    1010:	69 f4       	brne	.+26     	; 0x102c <free+0x10c>
    1012:	30 97       	sbiw	r30, 0x00	; 0
    1014:	29 f4       	brne	.+10     	; 0x1020 <free+0x100>
    1016:	10 92 88 03 	sts	0x0388, r1	; 0x800388 <__flp+0x1>
    101a:	10 92 87 03 	sts	0x0387, r1	; 0x800387 <__flp>
    101e:	02 c0       	rjmp	.+4      	; 0x1024 <free+0x104>
    1020:	13 82       	std	Z+3, r1	; 0x03
    1022:	12 82       	std	Z+2, r1	; 0x02
    1024:	b0 93 86 03 	sts	0x0386, r27	; 0x800386 <__brkval+0x1>
    1028:	a0 93 85 03 	sts	0x0385, r26	; 0x800385 <__brkval>
    102c:	df 91       	pop	r29
    102e:	cf 91       	pop	r28
    1030:	08 95       	ret

00001032 <_exit>:
    1032:	f8 94       	cli

00001034 <__stop_program>:
    1034:	ff cf       	rjmp	.-2      	; 0x1034 <__stop_program>
