
Cinta_Final.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000080  00800100  00001924  000019b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001924  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000314  00800180  00800180  00001a38  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001a38  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001a94  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000160  00000000  00000000  00001ad4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001e9a  00000000  00000000  00001c34  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c31  00000000  00000000  00003ace  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000101a  00000000  00000000  000046ff  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000498  00000000  00000000  0000571c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009ff  00000000  00000000  00005bb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000e31  00000000  00000000  000065b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000160  00000000  00000000  000073e4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
       4:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       8:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      28:	0c 94 47 01 	jmp	0x28e	; 0x28e <__vector_10>
      2c:	0c 94 f3 00 	jmp	0x1e6	; 0x1e6 <__vector_11>
      30:	0c 94 12 01 	jmp	0x224	; 0x224 <__vector_12>
      34:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      40:	0c 94 8e 01 	jmp	0x31c	; 0x31c <__vector_16>
      44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      48:	0c 94 b2 01 	jmp	0x364	; 0x364 <__vector_18>
      4c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      54:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      58:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      5c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      60:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      64:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      68:	52 03       	mulsu	r21, r18
      6a:	60 03       	mulsu	r22, r16
      6c:	78 03       	fmul	r23, r16
      6e:	8d 03       	fmulsu	r16, r21
      70:	a2 03       	fmuls	r18, r18
      72:	b0 03       	fmuls	r19, r16
      74:	d5 03       	fmuls	r21, r21

00000076 <__ctors_end>:
      76:	11 24       	eor	r1, r1
      78:	1f be       	out	0x3f, r1	; 63
      7a:	cf ef       	ldi	r28, 0xFF	; 255
      7c:	d8 e0       	ldi	r29, 0x08	; 8
      7e:	de bf       	out	0x3e, r29	; 62
      80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
      82:	11 e0       	ldi	r17, 0x01	; 1
      84:	a0 e0       	ldi	r26, 0x00	; 0
      86:	b1 e0       	ldi	r27, 0x01	; 1
      88:	e4 e2       	ldi	r30, 0x24	; 36
      8a:	f9 e1       	ldi	r31, 0x19	; 25
      8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
      8e:	05 90       	lpm	r0, Z+
      90:	0d 92       	st	X+, r0
      92:	a0 38       	cpi	r26, 0x80	; 128
      94:	b1 07       	cpc	r27, r17
      96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
      98:	24 e0       	ldi	r18, 0x04	; 4
      9a:	a0 e8       	ldi	r26, 0x80	; 128
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
      a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
      a2:	a4 39       	cpi	r26, 0x94	; 148
      a4:	b2 07       	cpc	r27, r18
      a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
      a8:	0e 94 0c 07 	call	0xe18	; 0xe18 <main>
      ac:	0c 94 90 0c 	jmp	0x1920	; 0x1920 <_exit>

000000b0 <__bad_interrupt>:
      b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <HCSR04_AddNew>:

//variable interna estatica
static _sHCSR04Handle *mySensor;		//puntero a la estructura _sHCSR04Handle. Se usa como variable auxiliar para manipular los datos de los sensores ultrasónicos HCSR04.

unsigned int HCSR04_AddNew(void (*WritePin_HCSR04)(uint8_t value), uint32_t ticks)
{
      b4:	cf 92       	push	r12
      b6:	df 92       	push	r13
      b8:	ef 92       	push	r14
      ba:	ff 92       	push	r15
      bc:	cf 93       	push	r28
      be:	df 93       	push	r29
      c0:	ec 01       	movw	r28, r24
      c2:	6a 01       	movw	r12, r20
      c4:	7b 01       	movw	r14, r22
	mySensor = (_sHCSR04Handle *)malloc(sizeof(_sHCSR04Handle));	//myHandleAux almacena un nuevo sensor dinámicamente, por lo que myHandleAux apunta a la nueva estructura creada.
      c6:	8f e0       	ldi	r24, 0x0F	; 15
      c8:	90 e0       	ldi	r25, 0x00	; 0
      ca:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <malloc>
      ce:	fc 01       	movw	r30, r24
      d0:	90 93 81 01 	sts	0x0181, r25	; 0x800181 <__data_end+0x1>
      d4:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__data_end>

	mySensor->WritePin = WritePin_HCSR04;
      d8:	d1 83       	std	Z+1, r29	; 0x01
      da:	c0 83       	st	Z, r28
	mySensor->ticks = ticks;
      dc:	c2 86       	std	Z+10, r12	; 0x0a
      de:	d3 86       	std	Z+11, r13	; 0x0b
      e0:	e4 86       	std	Z+12, r14	; 0x0c
      e2:	f5 86       	std	Z+13, r15	; 0x0d
	mySensor->flags.byte = 0;								
      e4:	16 86       	std	Z+14, r1	; 0x0e
	mySensor->lastDistanceUs = 0;
      e6:	11 86       	std	Z+9, r1	; 0x09
      e8:	10 86       	std	Z+8, r1	; 0x08
	mySensor->usTimeRise = 0;
      ea:	15 82       	std	Z+5, r1	; 0x05
      ec:	14 82       	std	Z+4, r1	; 0x04
	mySensor->usTimeFall = 0;
      ee:	17 82       	std	Z+7, r1	; 0x07
      f0:	16 82       	std	Z+6, r1	; 0x06
	mySensor->WritePin(0);		
      f2:	80 e0       	ldi	r24, 0x00	; 0
      f4:	fe 01       	movw	r30, r28
      f6:	09 95       	icall
	
	return (unsigned int)mySensor;
}
      f8:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <__data_end>
      fc:	90 91 81 01 	lds	r25, 0x0181	; 0x800181 <__data_end+0x1>
     100:	df 91       	pop	r29
     102:	cf 91       	pop	r28
     104:	ff 90       	pop	r15
     106:	ef 90       	pop	r14
     108:	df 90       	pop	r13
     10a:	cf 90       	pop	r12
     10c:	08 95       	ret

0000010e <HCSR04_Start>:
//}


void HCSR04_Start(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     10e:	90 93 81 01 	sts	0x0181, r25	; 0x800181 <__data_end+0x1>
     112:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__data_end>
	
	mySensor->WritePin(1);					
     116:	dc 01       	movw	r26, r24
     118:	ed 91       	ld	r30, X+
     11a:	fc 91       	ld	r31, X
     11c:	81 e0       	ldi	r24, 0x01	; 1
     11e:	09 95       	icall
     120:	08 95       	ret

00000122 <HCSR04_TriggerReady>:
	
}

void HCSR04_TriggerReady(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     122:	90 93 81 01 	sts	0x0181, r25	; 0x800181 <__data_end+0x1>
     126:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__data_end>
	
	mySensor->WritePin(0);
     12a:	dc 01       	movw	r26, r24
     12c:	ed 91       	ld	r30, X+
     12e:	fc 91       	ld	r31, X
     130:	80 e0       	ldi	r24, 0x00	; 0
     132:	09 95       	icall
     134:	08 95       	ret

00000136 <HCSR04_RiseEdgeTime>:
}

void HCSR04_RiseEdgeTime(unsigned int handleHCSR04, uint16_t usTimeRise)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     136:	90 93 81 01 	sts	0x0181, r25	; 0x800181 <__data_end+0x1>
     13a:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__data_end>

	mySensor->usTimeRise = usTimeRise;	//Cargo cuando se pone en RISE
     13e:	fc 01       	movw	r30, r24
     140:	75 83       	std	Z+5, r23	; 0x05
     142:	64 83       	std	Z+4, r22	; 0x04
	mySensor->flags.byte = 0;
     144:	16 86       	std	Z+14, r1	; 0x0e
     146:	08 95       	ret

00000148 <HCSR04_FallEdgeTime>:

}

void HCSR04_FallEdgeTime(unsigned int handleHCSR04, uint16_t usTimeFall)
{
     148:	fc 01       	movw	r30, r24
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     14a:	90 93 81 01 	sts	0x0181, r25	; 0x800181 <__data_end+0x1>
     14e:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__data_end>

	mySensor->usTimeFall = usTimeFall;	//Cargo cuando se pone en Fall 
     152:	77 83       	std	Z+7, r23	; 0x07
     154:	66 83       	std	Z+6, r22	; 0x06
	mySensor->flags.bit.EDGEREADY = 1;
     156:	86 85       	ldd	r24, Z+14	; 0x0e
     158:	81 60       	ori	r24, 0x01	; 1
     15a:	86 87       	std	Z+14, r24	; 0x0e
     15c:	08 95       	ret

0000015e <task_HCSR>:
	
}

void task_HCSR()
{
	if (mySensor != NULL)
     15e:	e0 91 80 01 	lds	r30, 0x0180	; 0x800180 <__data_end>
     162:	f0 91 81 01 	lds	r31, 0x0181	; 0x800181 <__data_end+0x1>
     166:	30 97       	sbiw	r30, 0x00	; 0
     168:	11 f1       	breq	.+68     	; 0x1ae <task_HCSR+0x50>
	{
		if (mySensor->flags.bit.EDGEREADY) //¿el sensor midió? Esto indica que ya se recibieron los dos flancos (rising y falling) y se puede calcular el tiempo que tardó el eco en volver = la distancia.
     16a:	86 85       	ldd	r24, Z+14	; 0x0e
     16c:	80 ff       	sbrs	r24, 0
     16e:	1f c0       	rjmp	.+62     	; 0x1ae <task_HCSR+0x50>
		{
			mySensor->flags.byte = 0;
     170:	16 86       	std	Z+14, r1	; 0x0e
			
			if(mySensor->usTimeRise < mySensor->usTimeFall){ //si no hubo overflow
     172:	24 81       	ldd	r18, Z+4	; 0x04
     174:	35 81       	ldd	r19, Z+5	; 0x05
     176:	86 81       	ldd	r24, Z+6	; 0x06
     178:	97 81       	ldd	r25, Z+7	; 0x07
     17a:	28 17       	cp	r18, r24
     17c:	39 07       	cpc	r19, r25
     17e:	28 f4       	brcc	.+10     	; 0x18a <task_HCSR+0x2c>
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise; //distancia medida
     180:	82 1b       	sub	r24, r18
     182:	93 0b       	sbc	r25, r19
     184:	91 87       	std	Z+9, r25	; 0x09
     186:	80 87       	std	Z+8, r24	; 0x08
     188:	05 c0       	rjmp	.+10     	; 0x194 <task_HCSR+0x36>
				}else{ //hubo overflow
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise + 0xFFFF; //para corregir
     18a:	82 1b       	sub	r24, r18
     18c:	93 0b       	sbc	r25, r19
     18e:	01 97       	sbiw	r24, 0x01	; 1
     190:	91 87       	std	Z+9, r25	; 0x09
     192:	80 87       	std	Z+8, r24	; 0x08
			}
			
			if(mySensor->lastDistanceUs > 11764) //2 metros
     194:	80 85       	ldd	r24, Z+8	; 0x08
     196:	91 85       	ldd	r25, Z+9	; 0x09
     198:	85 3f       	cpi	r24, 0xF5	; 245
     19a:	9d 42       	sbci	r25, 0x2D	; 45
     19c:	20 f0       	brcs	.+8      	; 0x1a6 <task_HCSR+0x48>
				mySensor->lastDistanceUs = 0xFFFF;
     19e:	8f ef       	ldi	r24, 0xFF	; 255
     1a0:	9f ef       	ldi	r25, 0xFF	; 255
     1a2:	91 87       	std	Z+9, r25	; 0x09
     1a4:	80 87       	std	Z+8, r24	; 0x08
			
			sensorMeasure(mySensor->lastDistanceUs);
     1a6:	80 85       	ldd	r24, Z+8	; 0x08
     1a8:	91 85       	ldd	r25, Z+9	; 0x09
     1aa:	0e 94 44 04 	call	0x888	; 0x888 <sensorMeasure>
     1ae:	08 95       	ret

000001b0 <WritePin_HCSR>:
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
	}
}

void WritePin_HCSR(uint8_t value){
	if (value)
     1b0:	88 23       	and	r24, r24
     1b2:	21 f0       	breq	.+8      	; 0x1bc <WritePin_HCSR+0xc>
	PORTB |= (1<<TRIGGER);				// Sets a HIGH state (1) in the TRIGGER pin
     1b4:	85 b1       	in	r24, 0x05	; 5
     1b6:	82 60       	ori	r24, 0x02	; 2
     1b8:	85 b9       	out	0x05, r24	; 5
     1ba:	08 95       	ret
	else
	PORTB &= ~(1<<TRIGGER);				// Sets a LOW state (0) in the TRIGGER pin
     1bc:	85 b1       	in	r24, 0x05	; 5
     1be:	8d 7f       	andi	r24, 0xFD	; 253
     1c0:	85 b9       	out	0x05, r24	; 5
     1c2:	08 95       	ret

000001c4 <USART_putchar>:
#include "HCSR04.h"
#include "util.h"

#include <stdio.h>

int USART_putchar(char c, FILE *stream) {
     1c4:	cf 93       	push	r28
     1c6:	c8 2f       	mov	r28, r24
	if (c == '\n') USART_putchar('\r', stream);  // salto de línea para terminal
     1c8:	8a 30       	cpi	r24, 0x0A	; 10
     1ca:	19 f4       	brne	.+6      	; 0x1d2 <USART_putchar+0xe>
     1cc:	8d e0       	ldi	r24, 0x0D	; 13
     1ce:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <USART_putchar>
	while (!(UCSR0A & (1 << UDRE0)));  // Espera a que el buffer esté vacío
     1d2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     1d6:	85 ff       	sbrs	r24, 5
     1d8:	fc cf       	rjmp	.-8      	; 0x1d2 <USART_putchar+0xe>
	UDR0 = c;
     1da:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	return 0;
}
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <__vector_11>:

/* END Constant in Flash -----------------------------------------------------*/


/* Function ISR --------------------------------------------------------------*/
ISR(TIMER1_COMPA_vect){
     1e6:	1f 92       	push	r1
     1e8:	0f 92       	push	r0
     1ea:	0f b6       	in	r0, 0x3f	; 63
     1ec:	0f 92       	push	r0
     1ee:	11 24       	eor	r1, r1
     1f0:	8f 93       	push	r24
     1f2:	9f 93       	push	r25
     1f4:	ef 93       	push	r30
     1f6:	ff 93       	push	r31
	
	/*		Con el OCR1B en 20000 , cuento cada 10ms		*/
	IS10MS=TRUE;
     1f8:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     1fc:	81 60       	ori	r24, 0x01	; 1
     1fe:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
	OCR1A += 19999;
     202:	e8 e8       	ldi	r30, 0x88	; 136
     204:	f0 e0       	ldi	r31, 0x00	; 0
     206:	80 81       	ld	r24, Z
     208:	91 81       	ldd	r25, Z+1	; 0x01
     20a:	81 5e       	subi	r24, 0xE1	; 225
     20c:	91 4b       	sbci	r25, 0xB1	; 177
     20e:	91 83       	std	Z+1, r25	; 0x01
     210:	80 83       	st	Z, r24
	
}
     212:	ff 91       	pop	r31
     214:	ef 91       	pop	r30
     216:	9f 91       	pop	r25
     218:	8f 91       	pop	r24
     21a:	0f 90       	pop	r0
     21c:	0f be       	out	0x3f, r0	; 63
     21e:	0f 90       	pop	r0
     220:	1f 90       	pop	r1
     222:	18 95       	reti

00000224 <__vector_12>:

ISR(TIMER1_COMPB_vect){
     224:	1f 92       	push	r1
     226:	0f 92       	push	r0
     228:	0f b6       	in	r0, 0x3f	; 63
     22a:	0f 92       	push	r0
     22c:	11 24       	eor	r1, r1
     22e:	2f 93       	push	r18
     230:	3f 93       	push	r19
     232:	4f 93       	push	r20
     234:	5f 93       	push	r21
     236:	6f 93       	push	r22
     238:	7f 93       	push	r23
     23a:	8f 93       	push	r24
     23c:	9f 93       	push	r25
     23e:	af 93       	push	r26
     240:	bf 93       	push	r27
     242:	ef 93       	push	r30
     244:	ff 93       	push	r31
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
}

static inline void on_timer1_compb_hcsr(){
	HCSR04_TriggerReady(HCSR_1);					//Pongo en LOW el Trigger
     246:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <HCSR_1>
     24a:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <HCSR_1+0x1>
     24e:	0e 94 91 00 	call	0x122	; 0x122 <HCSR04_TriggerReady>
	TIFR1 |= (1<<ICF1);								// Timer/Counter1 Output Compare A Match Flag enabled
     252:	86 b3       	in	r24, 0x16	; 22
     254:	80 62       	ori	r24, 0x20	; 32
     256:	86 bb       	out	0x16, r24	; 22
	TCCR1B = (1 << ICNC1) | (1 << ICES1);			// Input Capture Noise Canceler and Input Capture Edge Select activated
     258:	e1 e8       	ldi	r30, 0x81	; 129
     25a:	f0 e0       	ldi	r31, 0x00	; 0
     25c:	80 ec       	ldi	r24, 0xC0	; 192
     25e:	80 83       	st	Z, r24
	TCCR1B |= (1 << CS11);							// Prescaler definition (x8): CS12 = 0 and CS10 = 0
     260:	80 81       	ld	r24, Z
     262:	82 60       	ori	r24, 0x02	; 2
     264:	80 83       	st	Z, r24
	TIMSK1 = (1<<ICIE1) | (1<<OCIE1A);				// Input Capture Interrupt and Output Compare A Match Interrupt enabled <---
     266:	82 e2       	ldi	r24, 0x22	; 34
     268:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	
	on_timer1_compb_hcsr();
	
}
     26c:	ff 91       	pop	r31
     26e:	ef 91       	pop	r30
     270:	bf 91       	pop	r27
     272:	af 91       	pop	r26
     274:	9f 91       	pop	r25
     276:	8f 91       	pop	r24
     278:	7f 91       	pop	r23
     27a:	6f 91       	pop	r22
     27c:	5f 91       	pop	r21
     27e:	4f 91       	pop	r20
     280:	3f 91       	pop	r19
     282:	2f 91       	pop	r18
     284:	0f 90       	pop	r0
     286:	0f be       	out	0x3f, r0	; 63
     288:	0f 90       	pop	r0
     28a:	1f 90       	pop	r1
     28c:	18 95       	reti

0000028e <__vector_10>:

ISR(TIMER1_CAPT_vect){
     28e:	1f 92       	push	r1
     290:	0f 92       	push	r0
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	0f 92       	push	r0
     296:	11 24       	eor	r1, r1
     298:	2f 93       	push	r18
     29a:	3f 93       	push	r19
     29c:	4f 93       	push	r20
     29e:	5f 93       	push	r21
     2a0:	6f 93       	push	r22
     2a2:	7f 93       	push	r23
     2a4:	8f 93       	push	r24
     2a6:	9f 93       	push	r25
     2a8:	af 93       	push	r26
     2aa:	bf 93       	push	r27
     2ac:	ef 93       	push	r30
     2ae:	ff 93       	push	r31
}

static inline void on_timer1_capt_hcsr(){
	if (TCCR1B & (1<<ICES1)){						// Si ICES1 = 1  el Timer va a capturar en el flanco de subida (rising edge).
     2b0:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
     2b4:	86 ff       	sbrs	r24, 6
     2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <__vector_10+0x4a>
		
		TCCR1B = (1 << ICNC1) | (1 << CS11);		//preparo para capturar el flanco de bajada
     2b8:	82 e8       	ldi	r24, 0x82	; 130
     2ba:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
		HCSR04_RiseEdgeTime(HCSR_1, ICR1 >> 1);		//[[ ICR1 >> 1  ==  ICR1 / 2 ]] -> En ICR1 almacena el valor de TCNT1, Es decir, guardo el momento en que llego el RISE. Como ICR1 obtiene un tick cada 500ns, si contó 3000 ticks, se hace la cuenta 3000 * 0,5us = 1500us. (500ns = 0,5us = 1/2).
     2be:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2c2:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2c6:	76 95       	lsr	r23
     2c8:	67 95       	ror	r22
     2ca:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <HCSR_1>
     2ce:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <HCSR_1+0x1>
     2d2:	0e 94 9b 00 	call	0x136	; 0x136 <HCSR04_RiseEdgeTime>
     2d6:	11 c0       	rjmp	.+34     	; 0x2fa <__vector_10+0x6c>
		}else{										// Falling edge is used as trigger

		TIMSK1 &= ~_BV(ICIE1);						//desactivo la interrupcion por input capture
     2d8:	ef e6       	ldi	r30, 0x6F	; 111
     2da:	f0 e0       	ldi	r31, 0x00	; 0
     2dc:	80 81       	ld	r24, Z
     2de:	8f 7d       	andi	r24, 0xDF	; 223
     2e0:	80 83       	st	Z, r24
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
     2e2:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2e6:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2ea:	76 95       	lsr	r23
     2ec:	67 95       	ror	r22
     2ee:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <HCSR_1>
     2f2:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <HCSR_1+0x1>
     2f6:	0e 94 a4 00 	call	0x148	; 0x148 <HCSR04_FallEdgeTime>
	
	on_timer1_capt_hcsr();
	
}
     2fa:	ff 91       	pop	r31
     2fc:	ef 91       	pop	r30
     2fe:	bf 91       	pop	r27
     300:	af 91       	pop	r26
     302:	9f 91       	pop	r25
     304:	8f 91       	pop	r24
     306:	7f 91       	pop	r23
     308:	6f 91       	pop	r22
     30a:	5f 91       	pop	r21
     30c:	4f 91       	pop	r20
     30e:	3f 91       	pop	r19
     310:	2f 91       	pop	r18
     312:	0f 90       	pop	r0
     314:	0f be       	out	0x3f, r0	; 63
     316:	0f 90       	pop	r0
     318:	1f 90       	pop	r1
     31a:	18 95       	reti

0000031c <__vector_16>:

ISR(TIMER0_OVF_vect){
     31c:	1f 92       	push	r1
     31e:	0f 92       	push	r0
     320:	0f b6       	in	r0, 0x3f	; 63
     322:	0f 92       	push	r0
     324:	11 24       	eor	r1, r1
     326:	2f 93       	push	r18
     328:	3f 93       	push	r19
     32a:	4f 93       	push	r20
     32c:	5f 93       	push	r21
     32e:	6f 93       	push	r22
     330:	7f 93       	push	r23
     332:	8f 93       	push	r24
     334:	9f 93       	push	r25
     336:	af 93       	push	r26
     338:	bf 93       	push	r27
     33a:	ef 93       	push	r30
     33c:	ff 93       	push	r31
	
	writeServo();
     33e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <writeServo>
	
}
     342:	ff 91       	pop	r31
     344:	ef 91       	pop	r30
     346:	bf 91       	pop	r27
     348:	af 91       	pop	r26
     34a:	9f 91       	pop	r25
     34c:	8f 91       	pop	r24
     34e:	7f 91       	pop	r23
     350:	6f 91       	pop	r22
     352:	5f 91       	pop	r21
     354:	4f 91       	pop	r20
     356:	3f 91       	pop	r19
     358:	2f 91       	pop	r18
     35a:	0f 90       	pop	r0
     35c:	0f be       	out	0x3f, r0	; 63
     35e:	0f 90       	pop	r0
     360:	1f 90       	pop	r1
     362:	18 95       	reti

00000364 <__vector_18>:

ISR(USART_RX_vect){
     364:	1f 92       	push	r1
     366:	0f 92       	push	r0
     368:	0f b6       	in	r0, 0x3f	; 63
     36a:	0f 92       	push	r0
     36c:	11 24       	eor	r1, r1
     36e:	8f 93       	push	r24
     370:	9f 93       	push	r25
     372:	af 93       	push	r26
     374:	bf 93       	push	r27
     376:	ef 93       	push	r30
     378:	ff 93       	push	r31
	dataRx.buff[dataRx.indexW++] = UDR0;
     37a:	eb ea       	ldi	r30, 0xAB	; 171
     37c:	f2 e0       	ldi	r31, 0x02	; 2
     37e:	a0 81       	ld	r26, Z
     380:	b1 81       	ldd	r27, Z+1	; 0x01
     382:	83 81       	ldd	r24, Z+3	; 0x03
     384:	91 e0       	ldi	r25, 0x01	; 1
     386:	98 0f       	add	r25, r24
     388:	93 83       	std	Z+3, r25	; 0x03
     38a:	a8 0f       	add	r26, r24
     38c:	b1 1d       	adc	r27, r1
     38e:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     392:	8c 93       	st	X, r24
	dataRx.indexW &= dataRx.mask;
     394:	85 81       	ldd	r24, Z+5	; 0x05
     396:	93 81       	ldd	r25, Z+3	; 0x03
     398:	89 23       	and	r24, r25
     39a:	83 83       	std	Z+3, r24	; 0x03
}
     39c:	ff 91       	pop	r31
     39e:	ef 91       	pop	r30
     3a0:	bf 91       	pop	r27
     3a2:	af 91       	pop	r26
     3a4:	9f 91       	pop	r25
     3a6:	8f 91       	pop	r24
     3a8:	0f 90       	pop	r0
     3aa:	0f be       	out	0x3f, r0	; 63
     3ac:	0f 90       	pop	r0
     3ae:	1f 90       	pop	r1
     3b0:	18 95       	reti

000003b2 <ini_ports>:
void ini_ports(){
	
	/************************************************************************/
	/*								OUTPUTS                                 */
	/************************************************************************/
	DDRB = ((1 << LED_BI)| (1 << SV1) | (1 << SV2) | (1<<TRIGGER));
     3b2:	8a e3       	ldi	r24, 0x3A	; 58
     3b4:	84 b9       	out	0x04, r24	; 4
	DDRD = (1 << SV0);
     3b6:	80 e8       	ldi	r24, 0x80	; 128
     3b8:	8a b9       	out	0x0a, r24	; 10
	
	/************************************************************************/
	/*								INPUTS                                  */
	/************************************************************************/
	DDRB &= ~(1<<ECHO);
     3ba:	84 b1       	in	r24, 0x04	; 4
     3bc:	8e 7f       	andi	r24, 0xFE	; 254
     3be:	84 b9       	out	0x04, r24	; 4
	DDRD &= ~((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3c0:	8a b1       	in	r24, 0x0a	; 10
     3c2:	83 7c       	andi	r24, 0xC3	; 195
     3c4:	8a b9       	out	0x0a, r24	; 10
	
	/*						Activo Pull ups internos						*/
	PORTB = (1<<ECHO);
     3c6:	81 e0       	ldi	r24, 0x01	; 1
     3c8:	85 b9       	out	0x05, r24	; 5
	PORTD = ((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3ca:	8c e3       	ldi	r24, 0x3C	; 60
     3cc:	8b b9       	out	0x0b, r24	; 11
     3ce:	08 95       	ret

000003d0 <ini_timer1>:
/************************************************************************/
/*		Timer 1 es funcional al HCSR y a la accion cada 10ms            */
/************************************************************************/
void ini_timer1(){
	
	TCCR1A = 0x00;
     3d0:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
	/* Configuro noise canceler del input capture, el flanco del input capture y prescaler en 8 (f = 16MHz / 8 = 2MHz ? 1 tick = 0.5 µs) */
	TCCR1B = 0xC2;
     3d4:	82 ec       	ldi	r24, 0xC2	; 194
     3d6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
	TCNT1 = 0x00;
     3da:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     3de:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
	/*	Activo la interrupcion por comparador b	*/
	TIMSK1 = (1<<OCIE1A);
     3e2:	82 e0       	ldi	r24, 0x02	; 2
     3e4:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	/* Le doy un valor al comparador B	*/
	OCR1A = 19999;
     3e8:	8f e1       	ldi	r24, 0x1F	; 31
     3ea:	9e e4       	ldi	r25, 0x4E	; 78
     3ec:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     3f0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
	TIFR1 = TIFR1;
     3f4:	86 b3       	in	r24, 0x16	; 22
     3f6:	86 bb       	out	0x16, r24	; 22
     3f8:	08 95       	ret

000003fa <ini_timer0>:
/************************************************************************/
/*			Timer 0 funcional a generar el pwm de los servos			*/
/************************************************************************/
void ini_timer0(){
	
	TCCR0A = 0;
     3fa:	14 bc       	out	0x24, r1	; 36
	TCNT0 = 0;
     3fc:	16 bc       	out	0x26, r1	; 38
	/*	Pongo las banderas en 0 con TIFR	*/
	TIFR0 = 0x07;
     3fe:	87 e0       	ldi	r24, 0x07	; 7
     400:	85 bb       	out	0x15, r24	; 21
	/*	Habilito la interrupcion por TOV	*/
	TIMSK0 = (1<<TOIE0);
     402:	81 e0       	ldi	r24, 0x01	; 1
     404:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
	/*	Prescaler en 8 , obtengo el cuentas de 500ns, tov a 500*256 = 128us		*/
	TCCR0B = (1<<CS01);
     408:	82 e0       	ldi	r24, 0x02	; 2
     40a:	85 bd       	out	0x25, r24	; 37
     40c:	08 95       	ret

0000040e <ini_USART>:
	
}

void ini_USART(uint8_t ubrr){
	UBRR0H = 0;
     40e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = ubrr;
     412:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	UCSR0A = 0xFE; //inicializo todas las banderas excepto el multiprocesor
     416:	8e ef       	ldi	r24, 0xFE	; 254
     418:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	UCSR0B =   0x98; // (1<<RXCIE0) | (1<<RXEN0)|(1<<TXEN0); //Activo las banderas de interrupcion de recepcion y la habilitacion del rx y tx
     41c:	88 e9       	ldi	r24, 0x98	; 152
     41e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
     422:	86 e0       	ldi	r24, 0x06	; 6
     424:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     428:	08 95       	ret

0000042a <IR_Init>:
	
}

void IR_Init(IRDebounce *ir) {
     42a:	ac 01       	movw	r20, r24
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     42c:	20 e0       	ldi	r18, 0x00	; 0
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	0d c0       	rjmp	.+26     	; 0x44c <IR_Init+0x22>
		ir[globalIndex].state = IR_DOWN;
     432:	f9 01       	movw	r30, r18
     434:	ee 0f       	add	r30, r30
     436:	ff 1f       	adc	r31, r31
     438:	ee 0f       	add	r30, r30
     43a:	ff 1f       	adc	r31, r31
     43c:	e4 0f       	add	r30, r20
     43e:	f5 1f       	adc	r31, r21
     440:	93 e0       	ldi	r25, 0x03	; 3
     442:	90 83       	st	Z, r25
		ir[globalIndex].last_sample = 0;
     444:	12 82       	std	Z+2, r1	; 0x02
		ir[globalIndex].stateConfirmed = 0;
     446:	11 82       	std	Z+1, r1	; 0x01
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
	
}

void IR_Init(IRDebounce *ir) {
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     448:	2f 5f       	subi	r18, 0xFF	; 255
     44a:	3f 4f       	sbci	r19, 0xFF	; 255
     44c:	24 30       	cpi	r18, 0x04	; 4
     44e:	31 05       	cpc	r19, r1
     450:	84 f3       	brlt	.-32     	; 0x432 <IR_Init+0x8>
		ir[globalIndex].state = IR_DOWN;
		ir[globalIndex].last_sample = 0;
		ir[globalIndex].stateConfirmed = 0;
	}
}
     452:	08 95       	ret

00000454 <IR_Update>:

void IR_Update(IRDebounce *ir, uint8_t sample) {
     454:	fc 01       	movw	r30, r24
	switch (ir->state) {
     456:	80 81       	ld	r24, Z
     458:	81 30       	cpi	r24, 0x01	; 1
     45a:	89 f0       	breq	.+34     	; 0x47e <IR_Update+0x2a>
     45c:	28 f0       	brcs	.+10     	; 0x468 <IR_Update+0x14>
     45e:	82 30       	cpi	r24, 0x02	; 2
     460:	b1 f0       	breq	.+44     	; 0x48e <IR_Update+0x3a>
     462:	83 30       	cpi	r24, 0x03	; 3
     464:	01 f1       	breq	.+64     	; 0x4a6 <IR_Update+0x52>
     466:	26 c0       	rjmp	.+76     	; 0x4b4 <IR_Update+0x60>
		case IR_RISING:
		if (sample == 1 && ir->last_sample == 1){
     468:	61 30       	cpi	r22, 0x01	; 1
     46a:	31 f4       	brne	.+12     	; 0x478 <IR_Update+0x24>
     46c:	82 81       	ldd	r24, Z+2	; 0x02
     46e:	81 30       	cpi	r24, 0x01	; 1
     470:	19 f4       	brne	.+6      	; 0x478 <IR_Update+0x24>
			ir->state = IR_UP;
     472:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x01;
     474:	81 83       	std	Z+1, r24	; 0x01
     476:	20 c0       	rjmp	.+64     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     478:	83 e0       	ldi	r24, 0x03	; 3
     47a:	80 83       	st	Z, r24
     47c:	1d c0       	rjmp	.+58     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_UP:
		if (sample == 0){
     47e:	61 11       	cpse	r22, r1
     480:	03 c0       	rjmp	.+6      	; 0x488 <IR_Update+0x34>
			ir->state = IR_FALLING;
     482:	82 e0       	ldi	r24, 0x02	; 2
     484:	80 83       	st	Z, r24
     486:	18 c0       	rjmp	.+48     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	80 83       	st	Z, r24
     48c:	15 c0       	rjmp	.+42     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_FALLING:
		if (sample == 0 && ir->last_sample == 0){
     48e:	61 11       	cpse	r22, r1
     490:	07 c0       	rjmp	.+14     	; 0x4a0 <IR_Update+0x4c>
     492:	82 81       	ldd	r24, Z+2	; 0x02
     494:	81 11       	cpse	r24, r1
     496:	04 c0       	rjmp	.+8      	; 0x4a0 <IR_Update+0x4c>
			ir->state = IR_DOWN;
     498:	83 e0       	ldi	r24, 0x03	; 3
     49a:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x00;
     49c:	11 82       	std	Z+1, r1	; 0x01
     49e:	0c c0       	rjmp	.+24     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     4a0:	81 e0       	ldi	r24, 0x01	; 1
     4a2:	80 83       	st	Z, r24
     4a4:	09 c0       	rjmp	.+18     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_DOWN:
		if (sample == 1){
     4a6:	61 30       	cpi	r22, 0x01	; 1
     4a8:	11 f4       	brne	.+4      	; 0x4ae <IR_Update+0x5a>
			ir->state = IR_RISING;
     4aa:	10 82       	st	Z, r1
     4ac:	05 c0       	rjmp	.+10     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     4ae:	83 e0       	ldi	r24, 0x03	; 3
     4b0:	80 83       	st	Z, r24
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <IR_Update+0x64>
		}
		break;
		default:
		ir->state = IR_UP;
     4b4:	81 e0       	ldi	r24, 0x01	; 1
     4b6:	80 83       	st	Z, r24
		break;
	}

	ir->last_sample = sample;
     4b8:	62 83       	std	Z+2, r22	; 0x02
     4ba:	08 95       	ret

000004bc <IR_GetState>:
}

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}
     4bc:	fc 01       	movw	r30, r24
     4be:	81 81       	ldd	r24, Z+1	; 0x01
     4c0:	08 95       	ret

000004c2 <putHeaderOnTx>:
			dataTx->indexR &= dataTx->mask;
		}
	}
}

uint8_t putHeaderOnTx(_sTx  *dataTx, _eCmd ID, uint8_t frameLength){
     4c2:	fc 01       	movw	r30, r24
	dataTx->chk = 0;
     4c4:	15 82       	std	Z+5, r1	; 0x05
	dataTx->buff[dataTx->indexW++]='U';
     4c6:	a0 81       	ld	r26, Z
     4c8:	b1 81       	ldd	r27, Z+1	; 0x01
     4ca:	83 81       	ldd	r24, Z+3	; 0x03
     4cc:	91 e0       	ldi	r25, 0x01	; 1
     4ce:	98 0f       	add	r25, r24
     4d0:	93 83       	std	Z+3, r25	; 0x03
     4d2:	a8 0f       	add	r26, r24
     4d4:	b1 1d       	adc	r27, r1
     4d6:	85 e5       	ldi	r24, 0x55	; 85
     4d8:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4da:	84 81       	ldd	r24, Z+4	; 0x04
     4dc:	93 81       	ldd	r25, Z+3	; 0x03
     4de:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='N';
     4e0:	a0 81       	ld	r26, Z
     4e2:	b1 81       	ldd	r27, Z+1	; 0x01
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	89 0f       	add	r24, r25
     4e8:	83 83       	std	Z+3, r24	; 0x03
     4ea:	a9 0f       	add	r26, r25
     4ec:	b1 1d       	adc	r27, r1
     4ee:	8e e4       	ldi	r24, 0x4E	; 78
     4f0:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4f2:	84 81       	ldd	r24, Z+4	; 0x04
     4f4:	93 81       	ldd	r25, Z+3	; 0x03
     4f6:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='E';
     4f8:	a0 81       	ld	r26, Z
     4fa:	b1 81       	ldd	r27, Z+1	; 0x01
     4fc:	81 e0       	ldi	r24, 0x01	; 1
     4fe:	89 0f       	add	r24, r25
     500:	83 83       	std	Z+3, r24	; 0x03
     502:	a9 0f       	add	r26, r25
     504:	b1 1d       	adc	r27, r1
     506:	85 e4       	ldi	r24, 0x45	; 69
     508:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     50a:	84 81       	ldd	r24, Z+4	; 0x04
     50c:	93 81       	ldd	r25, Z+3	; 0x03
     50e:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='R';
     510:	a0 81       	ld	r26, Z
     512:	b1 81       	ldd	r27, Z+1	; 0x01
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	89 0f       	add	r24, r25
     518:	83 83       	std	Z+3, r24	; 0x03
     51a:	a9 0f       	add	r26, r25
     51c:	b1 1d       	adc	r27, r1
     51e:	82 e5       	ldi	r24, 0x52	; 82
     520:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     522:	84 81       	ldd	r24, Z+4	; 0x04
     524:	93 81       	ldd	r25, Z+3	; 0x03
     526:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=frameLength+1;
     528:	a0 81       	ld	r26, Z
     52a:	b1 81       	ldd	r27, Z+1	; 0x01
     52c:	81 e0       	ldi	r24, 0x01	; 1
     52e:	89 0f       	add	r24, r25
     530:	83 83       	std	Z+3, r24	; 0x03
     532:	a9 0f       	add	r26, r25
     534:	b1 1d       	adc	r27, r1
     536:	4f 5f       	subi	r20, 0xFF	; 255
     538:	4c 93       	st	X, r20
	dataTx->indexW &= dataTx->mask;
     53a:	84 81       	ldd	r24, Z+4	; 0x04
     53c:	93 81       	ldd	r25, Z+3	; 0x03
     53e:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=':';
     540:	a0 81       	ld	r26, Z
     542:	b1 81       	ldd	r27, Z+1	; 0x01
     544:	81 e0       	ldi	r24, 0x01	; 1
     546:	89 0f       	add	r24, r25
     548:	83 83       	std	Z+3, r24	; 0x03
     54a:	a9 0f       	add	r26, r25
     54c:	b1 1d       	adc	r27, r1
     54e:	8a e3       	ldi	r24, 0x3A	; 58
     550:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     552:	84 81       	ldd	r24, Z+4	; 0x04
     554:	93 81       	ldd	r25, Z+3	; 0x03
     556:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=ID;
     558:	a0 81       	ld	r26, Z
     55a:	b1 81       	ldd	r27, Z+1	; 0x01
     55c:	81 e0       	ldi	r24, 0x01	; 1
     55e:	89 0f       	add	r24, r25
     560:	83 83       	std	Z+3, r24	; 0x03
     562:	a9 0f       	add	r26, r25
     564:	b1 1d       	adc	r27, r1
     566:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     568:	94 81       	ldd	r25, Z+4	; 0x04
     56a:	83 81       	ldd	r24, Z+3	; 0x03
     56c:	98 23       	and	r25, r24
     56e:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= (frameLength+1);
     570:	95 81       	ldd	r25, Z+5	; 0x05
     572:	49 27       	eor	r20, r25
	dataTx->chk ^= ('U' ^'N' ^'E' ^'R' ^ID ^':') ;
     574:	64 27       	eor	r22, r20
     576:	86 e3       	ldi	r24, 0x36	; 54
     578:	86 27       	eor	r24, r22
     57a:	85 83       	std	Z+5, r24	; 0x05
	return  dataTx->chk;
}
     57c:	08 95       	ret

0000057e <putByteOnTx>:
uint8_t putByteOnTx(_sTx *dataTx, uint8_t byte)
{
     57e:	fc 01       	movw	r30, r24
	dataTx->buff[dataTx->indexW++]=byte;
     580:	a0 81       	ld	r26, Z
     582:	b1 81       	ldd	r27, Z+1	; 0x01
     584:	83 81       	ldd	r24, Z+3	; 0x03
     586:	91 e0       	ldi	r25, 0x01	; 1
     588:	98 0f       	add	r25, r24
     58a:	93 83       	std	Z+3, r25	; 0x03
     58c:	a8 0f       	add	r26, r24
     58e:	b1 1d       	adc	r27, r1
     590:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     592:	94 81       	ldd	r25, Z+4	; 0x04
     594:	83 81       	ldd	r24, Z+3	; 0x03
     596:	98 23       	and	r25, r24
     598:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= byte;
     59a:	85 81       	ldd	r24, Z+5	; 0x05
     59c:	86 27       	eor	r24, r22
     59e:	85 83       	std	Z+5, r24	; 0x05
	return dataTx->chk;
}
     5a0:	08 95       	ret

000005a2 <decodeCommand>:
void decodeCommand(_sRx *dataRx, _sTx *dataTx){
     5a2:	0f 93       	push	r16
     5a4:	1f 93       	push	r17
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	eb 01       	movw	r28, r22
	switch(dataRx->buff[dataRx->indexData]){
     5ac:	dc 01       	movw	r26, r24
     5ae:	ed 91       	ld	r30, X+
     5b0:	fc 91       	ld	r31, X
     5b2:	11 97       	sbiw	r26, 0x01	; 1
     5b4:	14 96       	adiw	r26, 0x04	; 4
     5b6:	8c 91       	ld	r24, X
     5b8:	e8 0f       	add	r30, r24
     5ba:	f1 1d       	adc	r31, r1
     5bc:	60 81       	ld	r22, Z
     5be:	60 3f       	cpi	r22, 0xF0	; 240
     5c0:	39 f0       	breq	.+14     	; 0x5d0 <decodeCommand+0x2e>
     5c2:	61 3f       	cpi	r22, 0xF1	; 241
     5c4:	09 f4       	brne	.+2      	; 0x5c8 <decodeCommand+0x26>
     5c6:	56 c0       	rjmp	.+172    	; 0x674 <decodeCommand+0xd2>
     5c8:	65 3a       	cpi	r22, 0xA5	; 165
     5ca:	09 f0       	breq	.+2      	; 0x5ce <decodeCommand+0x2c>
     5cc:	47 c0       	rjmp	.+142    	; 0x65c <decodeCommand+0xba>
     5ce:	0e c0       	rjmp	.+28     	; 0x5ec <decodeCommand+0x4a>
		
		case ALIVE:
		
			putHeaderOnTx(dataTx, ALIVE, 2);
     5d0:	42 e0       	ldi	r20, 0x02	; 2
     5d2:	60 ef       	ldi	r22, 0xF0	; 240
     5d4:	ce 01       	movw	r24, r28
     5d6:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx, ACK );
     5da:	6d e0       	ldi	r22, 0x0D	; 13
     5dc:	ce 01       	movw	r24, r28
     5de:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     5e2:	6d 81       	ldd	r22, Y+5	; 0x05
     5e4:	ce 01       	movw	r24, r28
     5e6:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		
		break;
     5ea:	44 c0       	rjmp	.+136    	; 0x674 <decodeCommand+0xd2>
		case FIRMWARE:
		break;

		case DATA:
			myWord.ui16[0]	= globalDistance;
     5ec:	02 ec       	ldi	r16, 0xC2	; 194
     5ee:	12 e0       	ldi	r17, 0x02	; 2
     5f0:	80 91 85 01 	lds	r24, 0x0185	; 0x800185 <globalDistance>
     5f4:	90 91 86 01 	lds	r25, 0x0186	; 0x800186 <globalDistance+0x1>
     5f8:	f8 01       	movw	r30, r16
     5fa:	91 83       	std	Z+1, r25	; 0x01
     5fc:	80 83       	st	Z, r24
			putHeaderOnTx(dataTx, DATA, 7);
     5fe:	47 e0       	ldi	r20, 0x07	; 7
     600:	65 ea       	ldi	r22, 0xA5	; 165
     602:	ce 01       	movw	r24, r28
     604:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx, myWord.ui8[0]);
     608:	d8 01       	movw	r26, r16
     60a:	6c 91       	ld	r22, X
     60c:	ce 01       	movw	r24, r28
     60e:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     612:	f8 01       	movw	r30, r16
     614:	61 81       	ldd	r22, Z+1	; 0x01
     616:	ce 01       	movw	r24, r28
     618:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, boxToTx);
     61c:	60 91 9e 01 	lds	r22, 0x019E	; 0x80019e <boxToTx>
     620:	ce 01       	movw	r24, r28
     622:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			myWord.ui16[0] = IR_GetState(&ir_sensor[0]);
     626:	86 ec       	ldi	r24, 0xC6	; 198
     628:	92 e0       	ldi	r25, 0x02	; 2
     62a:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	68 2f       	mov	r22, r24
     632:	d8 01       	movw	r26, r16
     634:	8d 93       	st	X+, r24
     636:	9c 93       	st	X, r25
			putByteOnTx(dataTx, myWord.ui8[0]);
     638:	ce 01       	movw	r24, r28
     63a:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     63e:	f8 01       	movw	r30, r16
     640:	61 81       	ldd	r22, Z+1	; 0x01
     642:	ce 01       	movw	r24, r28
     644:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, Numbox);
     648:	60 91 87 01 	lds	r22, 0x0187	; 0x800187 <Numbox>
     64c:	ce 01       	movw	r24, r28
     64e:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     652:	6d 81       	ldd	r22, Y+5	; 0x05
     654:	ce 01       	movw	r24, r28
     656:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		break;
     65a:	0c c0       	rjmp	.+24     	; 0x674 <decodeCommand+0xd2>
		//putByteOnTx(dataTx, dataTx->chk);
		//
		//break;

		default:
			putHeaderOnTx(dataTx, (_eCmd)dataRx->buff[dataRx->indexData], 2);
     65c:	42 e0       	ldi	r20, 0x02	; 2
     65e:	ce 01       	movw	r24, r28
     660:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx,UNKNOWN );
     664:	6f ef       	ldi	r22, 0xFF	; 255
     666:	ce 01       	movw	r24, r28
     668:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     66c:	6d 81       	ldd	r22, Y+5	; 0x05
     66e:	ce 01       	movw	r24, r28
     670:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		break;
		
	}
}
     674:	df 91       	pop	r29
     676:	cf 91       	pop	r28
     678:	1f 91       	pop	r17
     67a:	0f 91       	pop	r16
     67c:	08 95       	ret

0000067e <decodeHeader>:
void decodeHeader(_sRx *dataRx){
     67e:	dc 01       	movw	r26, r24
	uint8_t auxIndex=dataRx->indexW;
     680:	13 96       	adiw	r26, 0x03	; 3
     682:	2c 91       	ld	r18, X
     684:	13 97       	sbiw	r26, 0x03	; 3
	while(dataRx->indexR != auxIndex){
     686:	c9 c0       	rjmp	.+402    	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
		switch(dataRx->header)
     688:	18 96       	adiw	r26, 0x08	; 8
     68a:	ec 91       	ld	r30, X
     68c:	18 97       	sbiw	r26, 0x08	; 8
     68e:	4e 2f       	mov	r20, r30
     690:	50 e0       	ldi	r21, 0x00	; 0
     692:	47 30       	cpi	r20, 0x07	; 7
     694:	51 05       	cpc	r21, r1
     696:	08 f0       	brcs	.+2      	; 0x69a <decodeHeader+0x1c>
     698:	b2 c0       	rjmp	.+356    	; 0x7fe <decodeHeader+0x180>
     69a:	fa 01       	movw	r30, r20
     69c:	ec 5c       	subi	r30, 0xCC	; 204
     69e:	ff 4f       	sbci	r31, 0xFF	; 255
     6a0:	0c 94 45 08 	jmp	0x108a	; 0x108a <__tablejump2__>
		{
			case HEADER_U:
			if(dataRx->buff[dataRx->indexR] == 'U'){
     6a4:	ed 91       	ld	r30, X+
     6a6:	fc 91       	ld	r31, X
     6a8:	11 97       	sbiw	r26, 0x01	; 1
     6aa:	e8 0f       	add	r30, r24
     6ac:	f1 1d       	adc	r31, r1
     6ae:	80 81       	ld	r24, Z
     6b0:	85 35       	cpi	r24, 0x55	; 85
     6b2:	09 f0       	breq	.+2      	; 0x6b6 <decodeHeader+0x38>
     6b4:	a7 c0       	rjmp	.+334    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				dataRx->header = HEADER_N;
     6b6:	81 e0       	ldi	r24, 0x01	; 1
     6b8:	18 96       	adiw	r26, 0x08	; 8
     6ba:	8c 93       	st	X, r24
     6bc:	18 97       	sbiw	r26, 0x08	; 8
     6be:	a2 c0       	rjmp	.+324    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case HEADER_N:
			if(dataRx->buff[dataRx->indexR] == 'N'){
     6c0:	ed 91       	ld	r30, X+
     6c2:	fc 91       	ld	r31, X
     6c4:	11 97       	sbiw	r26, 0x01	; 1
     6c6:	e8 0f       	add	r30, r24
     6c8:	f1 1d       	adc	r31, r1
     6ca:	90 81       	ld	r25, Z
     6cc:	9e 34       	cpi	r25, 0x4E	; 78
     6ce:	29 f4       	brne	.+10     	; 0x6da <decodeHeader+0x5c>
				dataRx->header = HEADER_E;
     6d0:	82 e0       	ldi	r24, 0x02	; 2
     6d2:	18 96       	adiw	r26, 0x08	; 8
     6d4:	8c 93       	st	X, r24
     6d6:	18 97       	sbiw	r26, 0x08	; 8
     6d8:	95 c0       	rjmp	.+298    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				if(dataRx->buff[dataRx->indexR] != 'U'){
     6da:	95 35       	cpi	r25, 0x55	; 85
     6dc:	09 f4       	brne	.+2      	; 0x6e0 <decodeHeader+0x62>
     6de:	92 c0       	rjmp	.+292    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
					dataRx->header = HEADER_U;
     6e0:	18 96       	adiw	r26, 0x08	; 8
     6e2:	1c 92       	st	X, r1
     6e4:	18 97       	sbiw	r26, 0x08	; 8
					dataRx->indexR--;
     6e6:	81 50       	subi	r24, 0x01	; 1
     6e8:	12 96       	adiw	r26, 0x02	; 2
     6ea:	8c 93       	st	X, r24
     6ec:	12 97       	sbiw	r26, 0x02	; 2
     6ee:	8a c0       	rjmp	.+276    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}
			}
			break;
			case HEADER_E:
			if(dataRx->buff[dataRx->indexR] == 'E'){
     6f0:	ed 91       	ld	r30, X+
     6f2:	fc 91       	ld	r31, X
     6f4:	11 97       	sbiw	r26, 0x01	; 1
     6f6:	e8 0f       	add	r30, r24
     6f8:	f1 1d       	adc	r31, r1
     6fa:	90 81       	ld	r25, Z
     6fc:	95 34       	cpi	r25, 0x45	; 69
     6fe:	29 f4       	brne	.+10     	; 0x70a <decodeHeader+0x8c>
				dataRx->header = HEADER_R;
     700:	83 e0       	ldi	r24, 0x03	; 3
     702:	18 96       	adiw	r26, 0x08	; 8
     704:	8c 93       	st	X, r24
     706:	18 97       	sbiw	r26, 0x08	; 8
     708:	7d c0       	rjmp	.+250    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     70a:	18 96       	adiw	r26, 0x08	; 8
     70c:	1c 92       	st	X, r1
     70e:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     710:	81 50       	subi	r24, 0x01	; 1
     712:	12 96       	adiw	r26, 0x02	; 2
     714:	8c 93       	st	X, r24
     716:	12 97       	sbiw	r26, 0x02	; 2
     718:	75 c0       	rjmp	.+234    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case HEADER_R:
			if(dataRx->buff[dataRx->indexR] == 'R'){
     71a:	ed 91       	ld	r30, X+
     71c:	fc 91       	ld	r31, X
     71e:	11 97       	sbiw	r26, 0x01	; 1
     720:	e8 0f       	add	r30, r24
     722:	f1 1d       	adc	r31, r1
     724:	90 81       	ld	r25, Z
     726:	92 35       	cpi	r25, 0x52	; 82
     728:	29 f4       	brne	.+10     	; 0x734 <decodeHeader+0xb6>
				dataRx->header = NBYTES;
     72a:	84 e0       	ldi	r24, 0x04	; 4
     72c:	18 96       	adiw	r26, 0x08	; 8
     72e:	8c 93       	st	X, r24
     730:	18 97       	sbiw	r26, 0x08	; 8
     732:	68 c0       	rjmp	.+208    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     734:	18 96       	adiw	r26, 0x08	; 8
     736:	1c 92       	st	X, r1
     738:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     73a:	81 50       	subi	r24, 0x01	; 1
     73c:	12 96       	adiw	r26, 0x02	; 2
     73e:	8c 93       	st	X, r24
     740:	12 97       	sbiw	r26, 0x02	; 2
     742:	60 c0       	rjmp	.+192    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case NBYTES:
			dataRx->nBytes=dataRx->buff[dataRx->indexR];
     744:	ed 91       	ld	r30, X+
     746:	fc 91       	ld	r31, X
     748:	11 97       	sbiw	r26, 0x01	; 1
     74a:	e8 0f       	add	r30, r24
     74c:	f1 1d       	adc	r31, r1
     74e:	80 81       	ld	r24, Z
     750:	17 96       	adiw	r26, 0x07	; 7
     752:	8c 93       	st	X, r24
     754:	17 97       	sbiw	r26, 0x07	; 7
			dataRx->header = TOKEN;
     756:	85 e0       	ldi	r24, 0x05	; 5
     758:	18 96       	adiw	r26, 0x08	; 8
     75a:	8c 93       	st	X, r24
     75c:	18 97       	sbiw	r26, 0x08	; 8
			break;
     75e:	52 c0       	rjmp	.+164    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			case TOKEN:
			if(dataRx->buff[dataRx->indexR] == ':'){
     760:	ed 91       	ld	r30, X+
     762:	fc 91       	ld	r31, X
     764:	11 97       	sbiw	r26, 0x01	; 1
     766:	e8 0f       	add	r30, r24
     768:	f1 1d       	adc	r31, r1
     76a:	90 81       	ld	r25, Z
     76c:	9a 33       	cpi	r25, 0x3A	; 58
     76e:	a9 f4       	brne	.+42     	; 0x79a <decodeHeader+0x11c>
				dataRx->header = PAYLOAD;
     770:	96 e0       	ldi	r25, 0x06	; 6
     772:	18 96       	adiw	r26, 0x08	; 8
     774:	9c 93       	st	X, r25
     776:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexData = dataRx->indexR+1;
     778:	8f 5f       	subi	r24, 0xFF	; 255
				dataRx->indexData &= dataRx->mask;
     77a:	15 96       	adiw	r26, 0x05	; 5
     77c:	9c 91       	ld	r25, X
     77e:	15 97       	sbiw	r26, 0x05	; 5
     780:	89 23       	and	r24, r25
     782:	14 96       	adiw	r26, 0x04	; 4
     784:	8c 93       	st	X, r24
     786:	14 97       	sbiw	r26, 0x04	; 4
				dataRx->chk = 0;
				dataRx->chk ^= ('U' ^'N' ^'E' ^'R' ^dataRx->nBytes ^':') ;
     788:	17 96       	adiw	r26, 0x07	; 7
     78a:	9c 91       	ld	r25, X
     78c:	17 97       	sbiw	r26, 0x07	; 7
     78e:	86 e3       	ldi	r24, 0x36	; 54
     790:	89 27       	eor	r24, r25
     792:	16 96       	adiw	r26, 0x06	; 6
     794:	8c 93       	st	X, r24
     796:	16 97       	sbiw	r26, 0x06	; 6
     798:	35 c0       	rjmp	.+106    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     79a:	18 96       	adiw	r26, 0x08	; 8
     79c:	1c 92       	st	X, r1
     79e:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     7a0:	81 50       	subi	r24, 0x01	; 1
     7a2:	12 96       	adiw	r26, 0x02	; 2
     7a4:	8c 93       	st	X, r24
     7a6:	12 97       	sbiw	r26, 0x02	; 2
     7a8:	2d c0       	rjmp	.+90     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case PAYLOAD:
			dataRx->nBytes--;
     7aa:	17 96       	adiw	r26, 0x07	; 7
     7ac:	9c 91       	ld	r25, X
     7ae:	17 97       	sbiw	r26, 0x07	; 7
     7b0:	91 50       	subi	r25, 0x01	; 1
     7b2:	17 96       	adiw	r26, 0x07	; 7
     7b4:	9c 93       	st	X, r25
     7b6:	17 97       	sbiw	r26, 0x07	; 7
			if(dataRx->nBytes>0){
     7b8:	99 23       	and	r25, r25
     7ba:	71 f0       	breq	.+28     	; 0x7d8 <decodeHeader+0x15a>
				dataRx->chk ^= dataRx->buff[dataRx->indexR];
     7bc:	ed 91       	ld	r30, X+
     7be:	fc 91       	ld	r31, X
     7c0:	11 97       	sbiw	r26, 0x01	; 1
     7c2:	e8 0f       	add	r30, r24
     7c4:	f1 1d       	adc	r31, r1
     7c6:	80 81       	ld	r24, Z
     7c8:	16 96       	adiw	r26, 0x06	; 6
     7ca:	9c 91       	ld	r25, X
     7cc:	16 97       	sbiw	r26, 0x06	; 6
     7ce:	89 27       	eor	r24, r25
     7d0:	16 96       	adiw	r26, 0x06	; 6
     7d2:	8c 93       	st	X, r24
     7d4:	16 97       	sbiw	r26, 0x06	; 6
     7d6:	16 c0       	rjmp	.+44     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     7d8:	18 96       	adiw	r26, 0x08	; 8
     7da:	1c 92       	st	X, r1
     7dc:	18 97       	sbiw	r26, 0x08	; 8
				if(dataRx->buff[dataRx->indexR] == dataRx->chk)
     7de:	ed 91       	ld	r30, X+
     7e0:	fc 91       	ld	r31, X
     7e2:	11 97       	sbiw	r26, 0x01	; 1
     7e4:	e8 0f       	add	r30, r24
     7e6:	f1 1d       	adc	r31, r1
     7e8:	90 81       	ld	r25, Z
     7ea:	16 96       	adiw	r26, 0x06	; 6
     7ec:	8c 91       	ld	r24, X
     7ee:	16 97       	sbiw	r26, 0x06	; 6
     7f0:	98 13       	cpse	r25, r24
     7f2:	08 c0       	rjmp	.+16     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				dataRx->isComannd = TRUE;
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	1a 96       	adiw	r26, 0x0a	; 10
     7f8:	8c 93       	st	X, r24
     7fa:	1a 97       	sbiw	r26, 0x0a	; 10
     7fc:	03 c0       	rjmp	.+6      	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			default:
			dataRx->header = HEADER_U;
     7fe:	18 96       	adiw	r26, 0x08	; 8
     800:	1c 92       	st	X, r1
     802:	18 97       	sbiw	r26, 0x08	; 8
			break;
		}
		dataRx->indexR++;
     804:	12 96       	adiw	r26, 0x02	; 2
     806:	8c 91       	ld	r24, X
     808:	12 97       	sbiw	r26, 0x02	; 2
     80a:	8f 5f       	subi	r24, 0xFF	; 255
		dataRx->indexR &= dataRx->mask;
     80c:	15 96       	adiw	r26, 0x05	; 5
     80e:	9c 91       	ld	r25, X
     810:	15 97       	sbiw	r26, 0x05	; 5
     812:	89 23       	and	r24, r25
     814:	12 96       	adiw	r26, 0x02	; 2
     816:	8c 93       	st	X, r24
     818:	12 97       	sbiw	r26, 0x02	; 2
		
	}
}
void decodeHeader(_sRx *dataRx){
	uint8_t auxIndex=dataRx->indexW;
	while(dataRx->indexR != auxIndex){
     81a:	12 96       	adiw	r26, 0x02	; 2
     81c:	8c 91       	ld	r24, X
     81e:	12 97       	sbiw	r26, 0x02	; 2
     820:	28 13       	cpse	r18, r24
     822:	32 cf       	rjmp	.-412    	; 0x688 <decodeHeader+0xa>
			break;
		}
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}
     824:	08 95       	ret

00000826 <serialTask>:

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}

void serialTask(_sRx* dataRx, _sTx* dataTx){
     826:	0f 93       	push	r16
     828:	1f 93       	push	r17
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	8c 01       	movw	r16, r24
     830:	eb 01       	movw	r28, r22
	if(dataRx->isComannd){
     832:	fc 01       	movw	r30, r24
     834:	82 85       	ldd	r24, Z+10	; 0x0a
     836:	88 23       	and	r24, r24
     838:	21 f0       	breq	.+8      	; 0x842 <serialTask+0x1c>
		dataRx->isComannd=FALSE;
     83a:	12 86       	std	Z+10, r1	; 0x0a
		decodeCommand(dataRx,dataTx);
     83c:	c8 01       	movw	r24, r16
     83e:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <decodeCommand>
	}
	if(dataRx->indexR!=dataRx->indexW){
     842:	f8 01       	movw	r30, r16
     844:	92 81       	ldd	r25, Z+2	; 0x02
     846:	83 81       	ldd	r24, Z+3	; 0x03
     848:	98 17       	cp	r25, r24
     84a:	19 f0       	breq	.+6      	; 0x852 <serialTask+0x2c>
		
		decodeHeader(dataRx);
     84c:	c8 01       	movw	r24, r16
     84e:	0e 94 3f 03 	call	0x67e	; 0x67e <decodeHeader>
	}
	if (dataTx->indexR!= dataTx->indexW) {
     852:	8a 81       	ldd	r24, Y+2	; 0x02
     854:	9b 81       	ldd	r25, Y+3	; 0x03
     856:	89 17       	cp	r24, r25
     858:	91 f0       	breq	.+36     	; 0x87e <serialTask+0x58>
		if (UCSR0A & (1 << UDRE0)) { // Si el buffer de transmisión está vacío
     85a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     85e:	95 ff       	sbrs	r25, 5
     860:	0e c0       	rjmp	.+28     	; 0x87e <serialTask+0x58>
			UDR0 = dataTx->buff[dataTx->indexR++]; // Enviar el dato
     862:	e8 81       	ld	r30, Y
     864:	f9 81       	ldd	r31, Y+1	; 0x01
     866:	91 e0       	ldi	r25, 0x01	; 1
     868:	98 0f       	add	r25, r24
     86a:	9a 83       	std	Y+2, r25	; 0x02
     86c:	e8 0f       	add	r30, r24
     86e:	f1 1d       	adc	r31, r1
     870:	80 81       	ld	r24, Z
     872:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
			dataTx->indexR &= dataTx->mask;
     876:	8c 81       	ldd	r24, Y+4	; 0x04
     878:	9a 81       	ldd	r25, Y+2	; 0x02
     87a:	89 23       	and	r24, r25
     87c:	8a 83       	std	Y+2, r24	; 0x02
		}
	}
}
     87e:	df 91       	pop	r29
     880:	cf 91       	pop	r28
     882:	1f 91       	pop	r17
     884:	0f 91       	pop	r16
     886:	08 95       	ret

00000888 <sensorMeasure>:
	countservoReset--;
}

void sensorMeasure(uint16_t distance){
	
	globalDistance = distance;
     888:	90 93 86 01 	sts	0x0186, r25	; 0x800186 <globalDistance+0x1>
     88c:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <globalDistance>
     890:	08 95       	ret

00000892 <addBox>:
	
}

void addBox(uint16_t distance){
     892:	cf 93       	push	r28
	static uint8_t i = 1, j = 1, k = 1;
	
	if ((distance >= Cm13) && (distance < Cm15)) { //si la distancia se encuentra entre 15 y 13 cm es caja chica
     894:	9c 01       	movw	r18, r24
     896:	22 5f       	subi	r18, 0xF2	; 242
     898:	32 40       	sbci	r19, 0x02	; 2
     89a:	24 37       	cpi	r18, 0x74	; 116
     89c:	31 05       	cpc	r19, r1
     89e:	d0 f5       	brcc	.+116    	; 0x914 <__stack+0x15>
		Cajita[Numbox].boxState=isOn;
     8a0:	e0 91 87 01 	lds	r30, 0x0187	; 0x800187 <Numbox>
     8a4:	f0 e0       	ldi	r31, 0x00	; 0
     8a6:	ee 0f       	add	r30, r30
     8a8:	ff 1f       	adc	r31, r31
     8aa:	e4 59       	subi	r30, 0x94	; 148
     8ac:	fb 4f       	sbci	r31, 0xFB	; 251
     8ae:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=SmallBox;
     8b0:	91 e0       	ldi	r25, 0x01	; 1
     8b2:	90 83       	st	Z, r25
		boxToTx = 0x4;
     8b4:	84 e0       	ldi	r24, 0x04	; 4
     8b6:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <boxToTx>
		CajitaArr[0][i] = 1;
     8ba:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <i.2283>
     8be:	e8 2f       	mov	r30, r24
     8c0:	f0 e0       	ldi	r31, 0x00	; 0
     8c2:	ea 52       	subi	r30, 0x2A	; 42
     8c4:	fd 4f       	sbci	r31, 0xFD	; 253
     8c6:	90 83       	st	Z, r25
		i++;
     8c8:	8f 5f       	subi	r24, 0xFF	; 255
     8ca:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <i.2283>
			
		printf("Fila SmallBox: ");
     8ce:	8b e1       	ldi	r24, 0x1B	; 27
     8d0:	91 e0       	ldi	r25, 0x01	; 1
     8d2:	9f 93       	push	r25
     8d4:	8f 93       	push	r24
     8d6:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		for (uint8_t n = 0; n < 20; n++) {
     8da:	0f 90       	pop	r0
     8dc:	0f 90       	pop	r0
     8de:	c0 e0       	ldi	r28, 0x00	; 0
     8e0:	12 c0       	rjmp	.+36     	; 0x906 <__stack+0x7>
			printf("%u ", CajitaArr[0][n]);
     8e2:	ec 2f       	mov	r30, r28
     8e4:	f0 e0       	ldi	r31, 0x00	; 0
     8e6:	ea 52       	subi	r30, 0x2A	; 42
     8e8:	fd 4f       	sbci	r31, 0xFD	; 253
     8ea:	80 81       	ld	r24, Z
     8ec:	1f 92       	push	r1
     8ee:	8f 93       	push	r24
     8f0:	81 e6       	ldi	r24, 0x61	; 97
     8f2:	91 e0       	ldi	r25, 0x01	; 1
     8f4:	9f 93       	push	r25
     8f6:	8f 93       	push	r24
     8f8:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		boxToTx = 0x4;
		CajitaArr[0][i] = 1;
		i++;
			
		printf("Fila SmallBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     8fc:	cf 5f       	subi	r28, 0xFF	; 255
     8fe:	0f 90       	pop	r0
     900:	0f 90       	pop	r0
     902:	0f 90       	pop	r0
     904:	0f 90       	pop	r0
     906:	c4 31       	cpi	r28, 0x14	; 20
     908:	60 f3       	brcs	.-40     	; 0x8e2 <addBox+0x50>
			printf("%u ", CajitaArr[0][n]);
		}
		printf("\n");
     90a:	8a e0       	ldi	r24, 0x0A	; 10
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	0e 94 91 09 	call	0x1322	; 0x1322 <putchar>
     912:	e7 c0       	rjmp	.+462    	; 0xae2 <__stack+0x1e3>
	}
	else if ((distance >= Cm11) && (distance < Cm13)){
     914:	9c 01       	movw	r18, r24
     916:	2e 57       	subi	r18, 0x7E	; 126
     918:	32 40       	sbci	r19, 0x02	; 2
     91a:	24 37       	cpi	r18, 0x74	; 116
     91c:	31 05       	cpc	r19, r1
     91e:	08 f0       	brcs	.+2      	; 0x922 <__stack+0x23>
     920:	44 c0       	rjmp	.+136    	; 0x9aa <__stack+0xab>
		Cajita[Numbox].boxState=isOn;
     922:	e0 91 87 01 	lds	r30, 0x0187	; 0x800187 <Numbox>
     926:	f0 e0       	ldi	r31, 0x00	; 0
     928:	ee 0f       	add	r30, r30
     92a:	ff 1f       	adc	r31, r31
     92c:	e4 59       	subi	r30, 0x94	; 148
     92e:	fb 4f       	sbci	r31, 0xFB	; 251
     930:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=MediumBox;
     932:	82 e0       	ldi	r24, 0x02	; 2
     934:	80 83       	st	Z, r24
		boxToTx = 0x2;
     936:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <boxToTx>
		CajitaArr[1][j] = 1;
     93a:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <j.2284>
     93e:	e9 2f       	mov	r30, r25
     940:	f0 e0       	ldi	r31, 0x00	; 0
     942:	ea 52       	subi	r30, 0x2A	; 42
     944:	fd 4f       	sbci	r31, 0xFD	; 253
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	82 ab       	std	Z+50, r24	; 0x32
		CajitaArr[0][i] = 0;
     94a:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <i.2283>
     94e:	e8 2f       	mov	r30, r24
     950:	f0 e0       	ldi	r31, 0x00	; 0
     952:	ea 52       	subi	r30, 0x2A	; 42
     954:	fd 4f       	sbci	r31, 0xFD	; 253
     956:	10 82       	st	Z, r1
		j++;
     958:	9f 5f       	subi	r25, 0xFF	; 255
     95a:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <j.2284>
		i++;
     95e:	8f 5f       	subi	r24, 0xFF	; 255
     960:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <i.2283>
			
		printf("Fila MediumBox: ");
     964:	8b e2       	ldi	r24, 0x2B	; 43
     966:	91 e0       	ldi	r25, 0x01	; 1
     968:	9f 93       	push	r25
     96a:	8f 93       	push	r24
     96c:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		for (uint8_t n = 0; n < 20; n++) {
     970:	0f 90       	pop	r0
     972:	0f 90       	pop	r0
     974:	c0 e0       	ldi	r28, 0x00	; 0
     976:	12 c0       	rjmp	.+36     	; 0x99c <__stack+0x9d>
			printf("%u ", CajitaArr[1][n]);
     978:	ec 2f       	mov	r30, r28
     97a:	f0 e0       	ldi	r31, 0x00	; 0
     97c:	ea 52       	subi	r30, 0x2A	; 42
     97e:	fd 4f       	sbci	r31, 0xFD	; 253
     980:	82 a9       	ldd	r24, Z+50	; 0x32
     982:	1f 92       	push	r1
     984:	8f 93       	push	r24
     986:	81 e6       	ldi	r24, 0x61	; 97
     988:	91 e0       	ldi	r25, 0x01	; 1
     98a:	9f 93       	push	r25
     98c:	8f 93       	push	r24
     98e:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		CajitaArr[0][i] = 0;
		j++;
		i++;
			
		printf("Fila MediumBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     992:	cf 5f       	subi	r28, 0xFF	; 255
     994:	0f 90       	pop	r0
     996:	0f 90       	pop	r0
     998:	0f 90       	pop	r0
     99a:	0f 90       	pop	r0
     99c:	c4 31       	cpi	r28, 0x14	; 20
     99e:	60 f3       	brcs	.-40     	; 0x978 <__stack+0x79>
			printf("%u ", CajitaArr[1][n]);
		}
		printf("\n");
     9a0:	8a e0       	ldi	r24, 0x0A	; 10
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	0e 94 91 09 	call	0x1322	; 0x1322 <putchar>
     9a8:	9c c0       	rjmp	.+312    	; 0xae2 <__stack+0x1e3>
	}
	else if ((distance >= Cm9) && (distance < Cm11)){
     9aa:	9c 01       	movw	r18, r24
     9ac:	2a 50       	subi	r18, 0x0A	; 10
     9ae:	32 40       	sbci	r19, 0x02	; 2
     9b0:	24 37       	cpi	r18, 0x74	; 116
     9b2:	31 05       	cpc	r19, r1
     9b4:	08 f0       	brcs	.+2      	; 0x9b8 <__stack+0xb9>
     9b6:	4e c0       	rjmp	.+156    	; 0xa54 <__stack+0x155>
		Cajita[Numbox].boxState=isOn;
     9b8:	e0 91 87 01 	lds	r30, 0x0187	; 0x800187 <Numbox>
     9bc:	f0 e0       	ldi	r31, 0x00	; 0
     9be:	ee 0f       	add	r30, r30
     9c0:	ff 1f       	adc	r31, r31
     9c2:	e4 59       	subi	r30, 0x94	; 148
     9c4:	fb 4f       	sbci	r31, 0xFB	; 251
     9c6:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=LargeBox;
     9c8:	83 e0       	ldi	r24, 0x03	; 3
     9ca:	80 83       	st	Z, r24
		boxToTx = 0x1;
     9cc:	31 e0       	ldi	r19, 0x01	; 1
     9ce:	30 93 9e 01 	sts	0x019E, r19	; 0x80019e <boxToTx>
		CajitaArr[0][i] = 0;
     9d2:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <i.2283>
     9d6:	e9 2f       	mov	r30, r25
     9d8:	f0 e0       	ldi	r31, 0x00	; 0
     9da:	ea 52       	subi	r30, 0x2A	; 42
     9dc:	fd 4f       	sbci	r31, 0xFD	; 253
     9de:	10 82       	st	Z, r1
		CajitaArr[1][j] = 0;
     9e0:	20 91 07 01 	lds	r18, 0x0107	; 0x800107 <j.2284>
     9e4:	e2 2f       	mov	r30, r18
     9e6:	f0 e0       	ldi	r31, 0x00	; 0
     9e8:	ea 52       	subi	r30, 0x2A	; 42
     9ea:	fd 4f       	sbci	r31, 0xFD	; 253
     9ec:	12 aa       	std	Z+50, r1	; 0x32
		CajitaArr[2][k] = 1;
     9ee:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <k.2285>
     9f2:	e8 2f       	mov	r30, r24
     9f4:	f0 e0       	ldi	r31, 0x00	; 0
     9f6:	e6 5c       	subi	r30, 0xC6	; 198
     9f8:	fc 4f       	sbci	r31, 0xFC	; 252
     9fa:	30 83       	st	Z, r19
		j++;
     9fc:	2f 5f       	subi	r18, 0xFF	; 255
     9fe:	20 93 07 01 	sts	0x0107, r18	; 0x800107 <j.2284>
		i++;
     a02:	9f 5f       	subi	r25, 0xFF	; 255
     a04:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <i.2283>
		k++;
     a08:	8f 5f       	subi	r24, 0xFF	; 255
     a0a:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <k.2285>
					
		printf("Fila LargeBox: ");
     a0e:	8c e3       	ldi	r24, 0x3C	; 60
     a10:	91 e0       	ldi	r25, 0x01	; 1
     a12:	9f 93       	push	r25
     a14:	8f 93       	push	r24
     a16:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		for (uint8_t n = 0; n < 20; n++) {
     a1a:	0f 90       	pop	r0
     a1c:	0f 90       	pop	r0
     a1e:	c0 e0       	ldi	r28, 0x00	; 0
     a20:	12 c0       	rjmp	.+36     	; 0xa46 <__stack+0x147>
			printf("%u ", CajitaArr[2][n]);
     a22:	ec 2f       	mov	r30, r28
     a24:	f0 e0       	ldi	r31, 0x00	; 0
     a26:	e6 5c       	subi	r30, 0xC6	; 198
     a28:	fc 4f       	sbci	r31, 0xFC	; 252
     a2a:	80 81       	ld	r24, Z
     a2c:	1f 92       	push	r1
     a2e:	8f 93       	push	r24
     a30:	81 e6       	ldi	r24, 0x61	; 97
     a32:	91 e0       	ldi	r25, 0x01	; 1
     a34:	9f 93       	push	r25
     a36:	8f 93       	push	r24
     a38:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		j++;
		i++;
		k++;
					
		printf("Fila LargeBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     a3c:	cf 5f       	subi	r28, 0xFF	; 255
     a3e:	0f 90       	pop	r0
     a40:	0f 90       	pop	r0
     a42:	0f 90       	pop	r0
     a44:	0f 90       	pop	r0
     a46:	c4 31       	cpi	r28, 0x14	; 20
     a48:	60 f3       	brcs	.-40     	; 0xa22 <__stack+0x123>
			printf("%u ", CajitaArr[2][n]);
		}
		printf("\n");
     a4a:	8a e0       	ldi	r24, 0x0A	; 10
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	0e 94 91 09 	call	0x1322	; 0x1322 <putchar>
     a52:	47 c0       	rjmp	.+142    	; 0xae2 <__stack+0x1e3>
		
	}
	else if (((distance < Cm9) || (distance >= Cm15)) && distance>1 ){
     a54:	2c 35       	cpi	r18, 0x5C	; 92
     a56:	31 40       	sbci	r19, 0x01	; 1
     a58:	08 f4       	brcc	.+2      	; 0xa5c <__stack+0x15d>
     a5a:	43 c0       	rjmp	.+134    	; 0xae2 <__stack+0x1e3>
     a5c:	82 30       	cpi	r24, 0x02	; 2
     a5e:	91 05       	cpc	r25, r1
     a60:	08 f4       	brcc	.+2      	; 0xa64 <__stack+0x165>
     a62:	3f c0       	rjmp	.+126    	; 0xae2 <__stack+0x1e3>
		Cajita[Numbox].boxSize=NotSelected;
     a64:	e0 91 87 01 	lds	r30, 0x0187	; 0x800187 <Numbox>
     a68:	f0 e0       	ldi	r31, 0x00	; 0
     a6a:	ee 0f       	add	r30, r30
     a6c:	ff 1f       	adc	r31, r31
     a6e:	e4 59       	subi	r30, 0x94	; 148
     a70:	fb 4f       	sbci	r31, 0xFB	; 251
     a72:	24 e0       	ldi	r18, 0x04	; 4
     a74:	20 83       	st	Z, r18
		CajitaArr[0][i] = 0;
     a76:	30 91 08 01 	lds	r19, 0x0108	; 0x800108 <i.2283>
     a7a:	e3 2f       	mov	r30, r19
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	ea 52       	subi	r30, 0x2A	; 42
     a80:	fd 4f       	sbci	r31, 0xFD	; 253
     a82:	10 82       	st	Z, r1
		CajitaArr[1][j] = 0;
     a84:	40 91 07 01 	lds	r20, 0x0107	; 0x800107 <j.2284>
     a88:	e4 2f       	mov	r30, r20
     a8a:	f0 e0       	ldi	r31, 0x00	; 0
     a8c:	ea 52       	subi	r30, 0x2A	; 42
     a8e:	fd 4f       	sbci	r31, 0xFD	; 253
     a90:	12 aa       	std	Z+50, r1	; 0x32
		CajitaArr[2][k] = 0;
     a92:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <k.2285>
     a96:	e2 2f       	mov	r30, r18
     a98:	f0 e0       	ldi	r31, 0x00	; 0
     a9a:	e6 5c       	subi	r30, 0xC6	; 198
     a9c:	fc 4f       	sbci	r31, 0xFC	; 252
     a9e:	10 82       	st	Z, r1
		j++;
     aa0:	4f 5f       	subi	r20, 0xFF	; 255
     aa2:	40 93 07 01 	sts	0x0107, r20	; 0x800107 <j.2284>
		i++;
     aa6:	3f 5f       	subi	r19, 0xFF	; 255
     aa8:	30 93 08 01 	sts	0x0108, r19	; 0x800108 <i.2283>
		k++;
     aac:	2f 5f       	subi	r18, 0xFF	; 255
     aae:	20 93 06 01 	sts	0x0106, r18	; 0x800106 <k.2285>
		Kick1 = 0;
     ab2:	20 91 bc 02 	lds	r18, 0x02BC	; 0x8002bc <flag0>
		Kick2 = 0;
		Kick3 = 0;
     ab6:	23 7f       	andi	r18, 0xF3	; 243
     ab8:	2f 7e       	andi	r18, 0xEF	; 239
     aba:	20 93 bc 02 	sts	0x02BC, r18	; 0x8002bc <flag0>
		boxToTx = 0x0;
     abe:	10 92 9e 01 	sts	0x019E, r1	; 0x80019e <boxToTx>
		printf("%i\n",distance);
     ac2:	9f 93       	push	r25
     ac4:	8f 93       	push	r24
     ac6:	8c e4       	ldi	r24, 0x4C	; 76
     ac8:	91 e0       	ldi	r25, 0x01	; 1
     aca:	9f 93       	push	r25
     acc:	8f 93       	push	r24
     ace:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		printf("NotSelected\n");
     ad2:	80 e5       	ldi	r24, 0x50	; 80
     ad4:	91 e0       	ldi	r25, 0x01	; 1
     ad6:	0e 94 98 09 	call	0x1330	; 0x1330 <puts>
     ada:	0f 90       	pop	r0
     adc:	0f 90       	pop	r0
     ade:	0f 90       	pop	r0
     ae0:	0f 90       	pop	r0
	}
	Numbox++;
     ae2:	80 91 87 01 	lds	r24, 0x0187	; 0x800187 <Numbox>
     ae6:	8f 5f       	subi	r24, 0xFF	; 255
     ae8:	80 93 87 01 	sts	0x0187, r24	; 0x800187 <Numbox>
	
	if(Numbox>=bufferBox) //reinicio el buffer
     aec:	8f 30       	cpi	r24, 0x0F	; 15
     aee:	10 f0       	brcs	.+4      	; 0xaf4 <__stack+0x1f5>
	Numbox=0;
     af0:	10 92 87 01 	sts	0x0187, r1	; 0x800187 <Numbox>
}
     af4:	cf 91       	pop	r28
     af6:	08 95       	ret

00000af8 <newBox>:

void newBox(uint16_t distance){
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
	if(distance<Cm18){
     afc:	8c 34       	cpi	r24, 0x4C	; 76
     afe:	24 e0       	ldi	r18, 0x04	; 4
     b00:	92 07       	cpc	r25, r18
     b02:	00 f5       	brcc	.+64     	; 0xb44 <newBox+0x4c>
     b04:	ec 01       	movw	r28, r24
		if((IR_GetState(&ir_sensor[0]) == 0) && !MEASURINGBOX){
     b06:	86 ec       	ldi	r24, 0xC6	; 198
     b08:	92 e0       	ldi	r25, 0x02	; 2
     b0a:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     b0e:	81 11       	cpse	r24, r1
     b10:	0e c0       	rjmp	.+28     	; 0xb2e <newBox+0x36>
     b12:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     b16:	81 fd       	sbrc	r24, 1
     b18:	0a c0       	rjmp	.+20     	; 0xb2e <newBox+0x36>
			MEASURINGBOX=TRUE;
     b1a:	82 60       	ori	r24, 0x02	; 2
     b1c:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
			addBox(distance);
     b20:	ce 01       	movw	r24, r28
     b22:	0e 94 49 04 	call	0x892	; 0x892 <addBox>
			PORTB ^=(1<<LED_BI);
     b26:	95 b1       	in	r25, 0x05	; 5
     b28:	80 e2       	ldi	r24, 0x20	; 32
     b2a:	89 27       	eor	r24, r25
     b2c:	85 b9       	out	0x05, r24	; 5
		}
		if ((IR_GetState(&ir_sensor[0]) == 1)) //si IR no mide
     b2e:	86 ec       	ldi	r24, 0xC6	; 198
     b30:	92 e0       	ldi	r25, 0x02	; 2
     b32:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     b36:	81 30       	cpi	r24, 0x01	; 1
     b38:	29 f4       	brne	.+10     	; 0xb44 <newBox+0x4c>
			MEASURINGBOX=FALSE;
     b3a:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     b3e:	8d 7f       	andi	r24, 0xFD	; 253
     b40:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
	}
}
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	08 95       	ret

00000b4a <kickBox>:

void kickBox(){
	

	if (ir_sensor[1].state== IR_FALLING){
     b4a:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <ir_sensor+0x4>
     b4e:	82 30       	cpi	r24, 0x02	; 2
     b50:	51 f5       	brne	.+84     	; 0xba6 <kickBox+0x5c>
		sIR1++;
     b52:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <sIR1>
     b56:	8f 5f       	subi	r24, 0xFF	; 255
     b58:	80 93 84 01 	sts	0x0184, r24	; 0x800184 <sIR1>
		printf("sIR1:%u ", sIR1);
     b5c:	1f 92       	push	r1
     b5e:	8f 93       	push	r24
     b60:	8c e5       	ldi	r24, 0x5C	; 92
     b62:	91 e0       	ldi	r25, 0x01	; 1
     b64:	9f 93       	push	r25
     b66:	8f 93       	push	r24
     b68:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		if(CajitaArr[0][sIR1] == 1){
     b6c:	e0 91 84 01 	lds	r30, 0x0184	; 0x800184 <sIR1>
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	ea 52       	subi	r30, 0x2A	; 42
     b74:	fd 4f       	sbci	r31, 0xFD	; 253
     b76:	80 81       	ld	r24, Z
     b78:	0f 90       	pop	r0
     b7a:	0f 90       	pop	r0
     b7c:	0f 90       	pop	r0
     b7e:	0f 90       	pop	r0
     b80:	81 30       	cpi	r24, 0x01	; 1
     b82:	89 f4       	brne	.+34     	; 0xba6 <kickBox+0x5c>
			printf("ENTRE: ");
     b84:	85 e6       	ldi	r24, 0x65	; 101
     b86:	91 e0       	ldi	r25, 0x01	; 1
     b88:	9f 93       	push	r25
     b8a:	8f 93       	push	r24
     b8c:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
			printf("\n");
     b90:	8a e0       	ldi	r24, 0x0A	; 10
     b92:	90 e0       	ldi	r25, 0x00	; 0
     b94:	0e 94 91 09 	call	0x1322	; 0x1322 <putchar>
			Kick1=1;
     b98:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     b9c:	84 60       	ori	r24, 0x04	; 4
     b9e:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
     ba2:	0f 90       	pop	r0
     ba4:	0f 90       	pop	r0
		}
	}
	
	if (ir_sensor[2].state== IR_FALLING){
     ba6:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <ir_sensor+0x8>
     baa:	82 30       	cpi	r24, 0x02	; 2
     bac:	51 f5       	brne	.+84     	; 0xc02 <kickBox+0xb8>
		sIR2++;
     bae:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <sIR2>
     bb2:	8f 5f       	subi	r24, 0xFF	; 255
     bb4:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <sIR2>
		printf("sIR2:%u ", sIR2);
     bb8:	1f 92       	push	r1
     bba:	8f 93       	push	r24
     bbc:	8d e6       	ldi	r24, 0x6D	; 109
     bbe:	91 e0       	ldi	r25, 0x01	; 1
     bc0:	9f 93       	push	r25
     bc2:	8f 93       	push	r24
     bc4:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		if(CajitaArr[1][sIR2] == 1){
     bc8:	e0 91 83 01 	lds	r30, 0x0183	; 0x800183 <sIR2>
     bcc:	f0 e0       	ldi	r31, 0x00	; 0
     bce:	ea 52       	subi	r30, 0x2A	; 42
     bd0:	fd 4f       	sbci	r31, 0xFD	; 253
     bd2:	82 a9       	ldd	r24, Z+50	; 0x32
     bd4:	0f 90       	pop	r0
     bd6:	0f 90       	pop	r0
     bd8:	0f 90       	pop	r0
     bda:	0f 90       	pop	r0
     bdc:	81 30       	cpi	r24, 0x01	; 1
     bde:	89 f4       	brne	.+34     	; 0xc02 <kickBox+0xb8>
			printf("ENTRE: ");
     be0:	85 e6       	ldi	r24, 0x65	; 101
     be2:	91 e0       	ldi	r25, 0x01	; 1
     be4:	9f 93       	push	r25
     be6:	8f 93       	push	r24
     be8:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
			printf("\n");
     bec:	8a e0       	ldi	r24, 0x0A	; 10
     bee:	90 e0       	ldi	r25, 0x00	; 0
     bf0:	0e 94 91 09 	call	0x1322	; 0x1322 <putchar>
			Kick2=1;
     bf4:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     bf8:	88 60       	ori	r24, 0x08	; 8
     bfa:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
     bfe:	0f 90       	pop	r0
     c00:	0f 90       	pop	r0
		}
	}
	
	if (ir_sensor[3].state== IR_FALLING){
     c02:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <ir_sensor+0xc>
     c06:	82 30       	cpi	r24, 0x02	; 2
     c08:	51 f5       	brne	.+84     	; 0xc5e <kickBox+0x114>
		sIR3++;
     c0a:	80 91 82 01 	lds	r24, 0x0182	; 0x800182 <sIR3>
     c0e:	8f 5f       	subi	r24, 0xFF	; 255
     c10:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <sIR3>
		printf("sIR3:%u ", sIR3);
     c14:	1f 92       	push	r1
     c16:	8f 93       	push	r24
     c18:	86 e7       	ldi	r24, 0x76	; 118
     c1a:	91 e0       	ldi	r25, 0x01	; 1
     c1c:	9f 93       	push	r25
     c1e:	8f 93       	push	r24
     c20:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
		if(CajitaArr[2][sIR3] == 1){
     c24:	e0 91 82 01 	lds	r30, 0x0182	; 0x800182 <sIR3>
     c28:	f0 e0       	ldi	r31, 0x00	; 0
     c2a:	e6 5c       	subi	r30, 0xC6	; 198
     c2c:	fc 4f       	sbci	r31, 0xFC	; 252
     c2e:	80 81       	ld	r24, Z
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	0f 90       	pop	r0
     c38:	81 30       	cpi	r24, 0x01	; 1
     c3a:	89 f4       	brne	.+34     	; 0xc5e <kickBox+0x114>
			printf("ENTRE: ");
     c3c:	85 e6       	ldi	r24, 0x65	; 101
     c3e:	91 e0       	ldi	r25, 0x01	; 1
     c40:	9f 93       	push	r25
     c42:	8f 93       	push	r24
     c44:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <printf>
			printf("\n");
     c48:	8a e0       	ldi	r24, 0x0A	; 10
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	0e 94 91 09 	call	0x1322	; 0x1322 <putchar>
			Kick3=1;
     c50:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     c54:	80 61       	ori	r24, 0x10	; 16
     c56:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
     c5a:	0f 90       	pop	r0
     c5c:	0f 90       	pop	r0
		}
	}
	if(sIR1>50)
     c5e:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <sIR1>
     c62:	83 33       	cpi	r24, 0x33	; 51
     c64:	10 f0       	brcs	.+4      	; 0xc6a <kickBox+0x120>
		sIR1=0;
     c66:	10 92 84 01 	sts	0x0184, r1	; 0x800184 <sIR1>
	if(sIR2>50)
     c6a:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <sIR2>
     c6e:	83 33       	cpi	r24, 0x33	; 51
     c70:	10 f0       	brcs	.+4      	; 0xc76 <kickBox+0x12c>
		sIR1=0;
     c72:	10 92 84 01 	sts	0x0184, r1	; 0x800184 <sIR1>
	if(sIR3>50)
     c76:	80 91 82 01 	lds	r24, 0x0182	; 0x800182 <sIR3>
     c7a:	83 33       	cpi	r24, 0x33	; 51
     c7c:	10 f0       	brcs	.+4      	; 0xc82 <kickBox+0x138>
		sIR1=0;
     c7e:	10 92 84 01 	sts	0x0184, r1	; 0x800184 <sIR1>
	if(ir_sensor[1].state== IR_RISING && Kick1){
     c82:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <ir_sensor+0x4>
     c86:	81 11       	cpse	r24, r1
     c88:	11 c0       	rjmp	.+34     	; 0xcac <kickBox+0x162>
     c8a:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     c8e:	82 ff       	sbrs	r24, 2
     c90:	0d c0       	rjmp	.+26     	; 0xcac <kickBox+0x162>
		servo_Angle(0,0);
     c92:	60 e0       	ldi	r22, 0x00	; 0
     c94:	80 e0       	ldi	r24, 0x00	; 0
     c96:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
		Kick1=0;	
     c9a:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
		needtoReset=1;
     c9e:	8b 7f       	andi	r24, 0xFB	; 251
     ca0:	80 62       	ori	r24, 0x20	; 32
     ca2:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
		countservoReset=50;
     ca6:	82 e3       	ldi	r24, 0x32	; 50
     ca8:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <countservoReset>
	}
		
	if(ir_sensor[2].state== IR_RISING && Kick2){
     cac:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <ir_sensor+0x8>
     cb0:	81 11       	cpse	r24, r1
     cb2:	11 c0       	rjmp	.+34     	; 0xcd6 <kickBox+0x18c>
     cb4:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     cb8:	83 ff       	sbrs	r24, 3
     cba:	0d c0       	rjmp	.+26     	; 0xcd6 <kickBox+0x18c>
		servo_Angle(1,0);
     cbc:	60 e0       	ldi	r22, 0x00	; 0
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
		Kick2=0;
     cc4:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
		needtoReset=1;
     cc8:	87 7f       	andi	r24, 0xF7	; 247
     cca:	80 62       	ori	r24, 0x20	; 32
     ccc:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
		countservoReset=50;
     cd0:	82 e3       	ldi	r24, 0x32	; 50
     cd2:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <countservoReset>
	}
	
	if(ir_sensor[3].state== IR_RISING && Kick3){
     cd6:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <ir_sensor+0xc>
     cda:	81 11       	cpse	r24, r1
     cdc:	11 c0       	rjmp	.+34     	; 0xd00 <kickBox+0x1b6>
     cde:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     ce2:	84 ff       	sbrs	r24, 4
     ce4:	0d c0       	rjmp	.+26     	; 0xd00 <kickBox+0x1b6>
		servo_Angle(2,0);
     ce6:	60 e0       	ldi	r22, 0x00	; 0
     ce8:	82 e0       	ldi	r24, 0x02	; 2
     cea:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
		Kick3=0;
     cee:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
		needtoReset=1;
     cf2:	8f 7e       	andi	r24, 0xEF	; 239
     cf4:	80 62       	ori	r24, 0x20	; 32
     cf6:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
		countservoReset=50;
     cfa:	82 e3       	ldi	r24, 0x32	; 50
     cfc:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <countservoReset>
     d00:	08 95       	ret

00000d02 <servoreset>:
	}
		
}

void servoreset(){
	servo_Angle(0,120);
     d02:	68 e7       	ldi	r22, 0x78	; 120
     d04:	80 e0       	ldi	r24, 0x00	; 0
     d06:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
	servo_Angle(1,120);
     d0a:	68 e7       	ldi	r22, 0x78	; 120
     d0c:	81 e0       	ldi	r24, 0x01	; 1
     d0e:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
	servo_Angle(2,120);
     d12:	68 e7       	ldi	r22, 0x78	; 120
     d14:	82 e0       	ldi	r24, 0x02	; 2
     d16:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
     d1a:	08 95       	ret

00000d1c <every10ms>:
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}

void every10ms(){
     d1c:	cf 93       	push	r28
     d1e:	df 93       	push	r29
	
	if (!count100ms){		//Si pasaron 100ms
     d20:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <count100ms>
     d24:	81 11       	cpse	r24, r1
     d26:	1f c0       	rjmp	.+62     	; 0xd66 <every10ms+0x4a>

uint32_t	HCSR_1;
uint16_t	aux16 = 0;

static inline void on_reset_hcsr(){
	aux16 = TCNT1;								// Loads actual time in TCNT1 into aux16
     d28:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
     d2c:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
	aux16 += 20;								// 20*500ns = 10us (tiempo del trigger), Adds 10 (us) to the previously saved time at TCNT1
     d30:	44 96       	adiw	r24, 0x14	; 20
     d32:	90 93 89 01 	sts	0x0189, r25	; 0x800189 <aux16+0x1>
     d36:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <aux16>
	OCR1B = aux16;								// Then loads the value into OCR1B, generating an Output Compare Interrupt
     d3a:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7f808b>
     d3e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7f808a>
	TIFR1 = (1<<OCF1B) | (1<<OCF1A);			// Flag set after the counter value in TCNT1 equals OCR1A and OCR1B
     d42:	86 e0       	ldi	r24, 0x06	; 6
     d44:	86 bb       	out	0x16, r24	; 22
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
     d46:	84 e0       	ldi	r24, 0x04	; 4
     d48:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
     d4c:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <HCSR_1>
     d50:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <HCSR_1+0x1>
     d54:	0e 94 87 00 	call	0x10e	; 0x10e <HCSR04_Start>
		on_reset_hcsr();
		count100ms = 10;
     d58:	8a e0       	ldi	r24, 0x0A	; 10
     d5a:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <count100ms>
		PORTB ^= (1<<LED_BI);
     d5e:	95 b1       	in	r25, 0x05	; 5
     d60:	80 e2       	ldi	r24, 0x20	; 32
     d62:	89 27       	eor	r24, r25
     d64:	85 b9       	out	0x05, r24	; 5
	}
	
	if (!count40ms){
     d66:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count40ms>
     d6a:	88 23       	and	r24, r24
     d6c:	81 f0       	breq	.+32     	; 0xd8e <every10ms+0x72>
     d6e:	1f c0       	rjmp	.+62     	; 0xdae <every10ms+0x92>
		for(int i=0;i<4;i++){
			IR_Update(&ir_sensor[i], raw_input[i]);
     d70:	fe 01       	movw	r30, r28
     d72:	e3 54       	subi	r30, 0x43	; 67
     d74:	fd 4f       	sbci	r31, 0xFD	; 253
     d76:	ce 01       	movw	r24, r28
     d78:	88 0f       	add	r24, r24
     d7a:	99 1f       	adc	r25, r25
     d7c:	88 0f       	add	r24, r24
     d7e:	99 1f       	adc	r25, r25
     d80:	60 81       	ld	r22, Z
     d82:	8a 53       	subi	r24, 0x3A	; 58
     d84:	9d 4f       	sbci	r25, 0xFD	; 253
     d86:	0e 94 2a 02 	call	0x454	; 0x454 <IR_Update>
		count100ms = 10;
		PORTB ^= (1<<LED_BI);
	}
	
	if (!count40ms){
		for(int i=0;i<4;i++){
     d8a:	21 96       	adiw	r28, 0x01	; 1
     d8c:	02 c0       	rjmp	.+4      	; 0xd92 <every10ms+0x76>
     d8e:	c0 e0       	ldi	r28, 0x00	; 0
     d90:	d0 e0       	ldi	r29, 0x00	; 0
     d92:	c4 30       	cpi	r28, 0x04	; 4
     d94:	d1 05       	cpc	r29, r1
     d96:	64 f3       	brlt	.-40     	; 0xd70 <every10ms+0x54>
			IR_Update(&ir_sensor[i], raw_input[i]);
		}
		count40ms = 4;
     d98:	84 e0       	ldi	r24, 0x04	; 4
     d9a:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <count40ms>
		newBox(globalDistance);
     d9e:	80 91 85 01 	lds	r24, 0x0185	; 0x800185 <globalDistance>
     da2:	90 91 86 01 	lds	r25, 0x0186	; 0x800186 <globalDistance+0x1>
     da6:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <newBox>
		kickBox();
     daa:	0e 94 a5 05 	call	0xb4a	; 0xb4a <kickBox>
	}
	if (!countservoReset && needtoReset){
     dae:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <countservoReset>
     db2:	81 11       	cpse	r24, r1
     db4:	05 c0       	rjmp	.+10     	; 0xdc0 <every10ms+0xa4>
     db6:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     dba:	85 fd       	sbrc	r24, 5
		servoreset();
     dbc:	0e 94 81 06 	call	0xd02	; 0xd02 <servoreset>
	}
	raw_input[0] = (PIND & (1<<IR0)) ? 1 : 0;
     dc0:	89 b1       	in	r24, 0x09	; 9
     dc2:	82 fb       	bst	r24, 2
     dc4:	88 27       	eor	r24, r24
     dc6:	80 f9       	bld	r24, 0
     dc8:	ed eb       	ldi	r30, 0xBD	; 189
     dca:	f2 e0       	ldi	r31, 0x02	; 2
     dcc:	80 83       	st	Z, r24
	raw_input[1] = (PIND & (1<<IR1)) ? 1 : 0;
     dce:	89 b1       	in	r24, 0x09	; 9
     dd0:	83 fb       	bst	r24, 3
     dd2:	88 27       	eor	r24, r24
     dd4:	80 f9       	bld	r24, 0
     dd6:	81 83       	std	Z+1, r24	; 0x01
	raw_input[2] = (PIND & (1<<IR2)) ? 1 : 0;
     dd8:	89 b1       	in	r24, 0x09	; 9
     dda:	82 95       	swap	r24
     ddc:	81 70       	andi	r24, 0x01	; 1
     dde:	82 83       	std	Z+2, r24	; 0x02
	raw_input[3] = (PIND & (1<<IR3)) ? 1 : 0;
     de0:	89 b1       	in	r24, 0x09	; 9
     de2:	85 fb       	bst	r24, 5
     de4:	88 27       	eor	r24, r24
     de6:	80 f9       	bld	r24, 0
     de8:	83 83       	std	Z+3, r24	; 0x03
	
	IS10MS = FALSE;
     dea:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     dee:	8e 7f       	andi	r24, 0xFE	; 254
     df0:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <flag0>
	count100ms--;
     df4:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <count100ms>
     df8:	81 50       	subi	r24, 0x01	; 1
     dfa:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <count100ms>
	count40ms--;
     dfe:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count40ms>
     e02:	81 50       	subi	r24, 0x01	; 1
     e04:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <count40ms>
	countservoReset--;
     e08:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <countservoReset>
     e0c:	81 50       	subi	r24, 0x01	; 1
     e0e:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <countservoReset>
}
     e12:	df 91       	pop	r29
     e14:	cf 91       	pop	r28
     e16:	08 95       	ret

00000e18 <main>:
}
/* END Function prototypes user code ------------------------------------------*/

int main(){
	
	cli();
     e18:	f8 94       	cli

	/* END Local variables -------------------------------------------------------*/


	/* User code Init ------------------------------------------------------------*/
	flag0.byte = 0;
     e1a:	10 92 bc 02 	sts	0x02BC, r1	; 0x8002bc <flag0>
	
	ini_ports();
     e1e:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <ini_ports>
	ini_timer1();
     e22:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <ini_timer1>
	ini_timer0();
     e26:	0e 94 fd 01 	call	0x3fa	; 0x3fa <ini_timer0>
	ini_USART(16);
     e2a:	80 e1       	ldi	r24, 0x10	; 16
     e2c:	0e 94 07 02 	call	0x40e	; 0x40e <ini_USART>
	
	IR_Init(&ir_sensor[0]);
     e30:	86 ec       	ldi	r24, 0xC6	; 198
     e32:	92 e0       	ldi	r25, 0x02	; 2
     e34:	0e 94 15 02 	call	0x42a	; 0x42a <IR_Init>
	stdout = &usart_output;
     e38:	8c e0       	ldi	r24, 0x0C	; 12
     e3a:	91 e0       	ldi	r25, 0x01	; 1
     e3c:	90 93 91 04 	sts	0x0491, r25	; 0x800491 <__iob+0x3>
     e40:	80 93 90 04 	sts	0x0490, r24	; 0x800490 <__iob+0x2>
	
	addServo(&PORTD,SV0);
     e44:	67 e0       	ldi	r22, 0x07	; 7
     e46:	8b e2       	ldi	r24, 0x2B	; 43
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	0e 94 a6 07 	call	0xf4c	; 0xf4c <addServo>
	addServo(&PORTB,SV1);
     e4e:	64 e0       	ldi	r22, 0x04	; 4
     e50:	85 e2       	ldi	r24, 0x25	; 37
     e52:	90 e0       	ldi	r25, 0x00	; 0
     e54:	0e 94 a6 07 	call	0xf4c	; 0xf4c <addServo>
	addServo(&PORTB,SV2);
     e58:	63 e0       	ldi	r22, 0x03	; 3
     e5a:	85 e2       	ldi	r24, 0x25	; 37
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	0e 94 a6 07 	call	0xf4c	; 0xf4c <addServo>
	servo_Angle(0,90);
     e62:	6a e5       	ldi	r22, 0x5A	; 90
     e64:	80 e0       	ldi	r24, 0x00	; 0
     e66:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
	servo_Angle(1,90);
     e6a:	6a e5       	ldi	r22, 0x5A	; 90
     e6c:	81 e0       	ldi	r24, 0x01	; 1
     e6e:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
	servo_Angle(2,90);
     e72:	6a e5       	ldi	r22, 0x5A	; 90
     e74:	82 e0       	ldi	r24, 0x02	; 2
     e76:	0e 94 ba 07 	call	0xf74	; 0xf74 <servo_Angle>
	HCSR_1 = HCSR04_AddNew(&WritePin_HCSR, 16);
     e7a:	40 e1       	ldi	r20, 0x10	; 16
     e7c:	50 e0       	ldi	r21, 0x00	; 0
     e7e:	60 e0       	ldi	r22, 0x00	; 0
     e80:	70 e0       	ldi	r23, 0x00	; 0
     e82:	88 ed       	ldi	r24, 0xD8	; 216
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	0e 94 5a 00 	call	0xb4	; 0xb4 <HCSR04_AddNew>
     e8a:	a0 e0       	ldi	r26, 0x00	; 0
     e8c:	b0 e0       	ldi	r27, 0x00	; 0
     e8e:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <HCSR_1>
     e92:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <HCSR_1+0x1>
     e96:	a0 93 9c 01 	sts	0x019C, r26	; 0x80019c <HCSR_1+0x2>
     e9a:	b0 93 9d 01 	sts	0x019D, r27	; 0x80019d <HCSR_1+0x3>
	
	Numbox = 255;
     e9e:	8f ef       	ldi	r24, 0xFF	; 255
     ea0:	80 93 87 01 	sts	0x0187, r24	; 0x800187 <Numbox>
	
	dataRx.buff = (uint8_t *)buffRx;
     ea4:	eb ea       	ldi	r30, 0xAB	; 171
     ea6:	f2 e0       	ldi	r31, 0x02	; 2
     ea8:	2f e9       	ldi	r18, 0x9F	; 159
     eaa:	31 e0       	ldi	r19, 0x01	; 1
     eac:	31 83       	std	Z+1, r19	; 0x01
     eae:	20 83       	st	Z, r18
	dataRx.indexR = 0;
     eb0:	12 82       	std	Z+2, r1	; 0x02
	dataRx.indexW = 0;
     eb2:	13 82       	std	Z+3, r1	; 0x03
	dataRx.header = HEADER_U;
     eb4:	10 86       	std	Z+8, r1	; 0x08
	dataRx.mask = RXBUFSIZE - 1;
     eb6:	85 83       	std	Z+5, r24	; 0x05
	
	dataTx.buff = buffTx;
     eb8:	e6 eb       	ldi	r30, 0xB6	; 182
     eba:	f2 e0       	ldi	r31, 0x02	; 2
     ebc:	2c e6       	ldi	r18, 0x6C	; 108
     ebe:	33 e0       	ldi	r19, 0x03	; 3
     ec0:	31 83       	std	Z+1, r19	; 0x01
     ec2:	20 83       	st	Z, r18
	dataTx.indexR = 0;
     ec4:	12 82       	std	Z+2, r1	; 0x02
	dataTx.indexW = 0;
     ec6:	13 82       	std	Z+3, r1	; 0x03
	dataTx.mask = TXBUFSIZE -1;
     ec8:	84 83       	std	Z+4, r24	; 0x04
	
	boxSizeconfig.smallboxF=Cm15;
     eca:	ef e9       	ldi	r30, 0x9F	; 159
     ecc:	f2 e0       	ldi	r31, 0x02	; 2
     ece:	86 e6       	ldi	r24, 0x66	; 102
     ed0:	93 e0       	ldi	r25, 0x03	; 3
     ed2:	91 83       	std	Z+1, r25	; 0x01
     ed4:	80 83       	st	Z, r24
	boxSizeconfig.smallboxC=Cm13;
     ed6:	82 ef       	ldi	r24, 0xF2	; 242
     ed8:	92 e0       	ldi	r25, 0x02	; 2
     eda:	93 83       	std	Z+3, r25	; 0x03
     edc:	82 83       	std	Z+2, r24	; 0x02
	boxSizeconfig.mediumboxF=Cm13;
     ede:	95 83       	std	Z+5, r25	; 0x05
     ee0:	84 83       	std	Z+4, r24	; 0x04
	boxSizeconfig.mediumboxC=Cm11;
     ee2:	8e e7       	ldi	r24, 0x7E	; 126
     ee4:	92 e0       	ldi	r25, 0x02	; 2
     ee6:	97 83       	std	Z+7, r25	; 0x07
     ee8:	86 83       	std	Z+6, r24	; 0x06
	boxSizeconfig.largeboxF=Cm11;
     eea:	91 87       	std	Z+9, r25	; 0x09
     eec:	80 87       	std	Z+8, r24	; 0x08
	boxSizeconfig.largeboxC=Cm9;
     eee:	8a e0       	ldi	r24, 0x0A	; 10
     ef0:	92 e0       	ldi	r25, 0x02	; 2
     ef2:	93 87       	std	Z+11, r25	; 0x0b
     ef4:	82 87       	std	Z+10, r24	; 0x0a
	
	ir_sensor[1].irType = SmallBox;
     ef6:	e6 ec       	ldi	r30, 0xC6	; 198
     ef8:	f2 e0       	ldi	r31, 0x02	; 2
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	87 83       	std	Z+7, r24	; 0x07
	ir_sensor[2].irType = MediumBox;
     efe:	82 e0       	ldi	r24, 0x02	; 2
     f00:	83 87       	std	Z+11, r24	; 0x0b
	ir_sensor[3].irType = LargeBox;
     f02:	83 e0       	ldi	r24, 0x03	; 3
     f04:	87 87       	std	Z+15, r24	; 0x0f
	
	for (uint8_t i = 0; i < 3; i++) {
     f06:	80 e0       	ldi	r24, 0x00	; 0
     f08:	0f c0       	rjmp	.+30     	; 0xf28 <main+0x110>
		for (uint8_t j = 0; j < 20; j++) {
			CajitaArr[i][j] = 0;
     f0a:	22 e3       	ldi	r18, 0x32	; 50
     f0c:	82 9f       	mul	r24, r18
     f0e:	f0 01       	movw	r30, r0
     f10:	11 24       	eor	r1, r1
     f12:	ea 52       	subi	r30, 0x2A	; 42
     f14:	fd 4f       	sbci	r31, 0xFD	; 253
     f16:	e9 0f       	add	r30, r25
     f18:	f1 1d       	adc	r31, r1
     f1a:	10 82       	st	Z, r1
	ir_sensor[1].irType = SmallBox;
	ir_sensor[2].irType = MediumBox;
	ir_sensor[3].irType = LargeBox;
	
	for (uint8_t i = 0; i < 3; i++) {
		for (uint8_t j = 0; j < 20; j++) {
     f1c:	9f 5f       	subi	r25, 0xFF	; 255
     f1e:	01 c0       	rjmp	.+2      	; 0xf22 <main+0x10a>
     f20:	90 e0       	ldi	r25, 0x00	; 0
     f22:	94 31       	cpi	r25, 0x14	; 20
     f24:	90 f3       	brcs	.-28     	; 0xf0a <main+0xf2>
	
	ir_sensor[1].irType = SmallBox;
	ir_sensor[2].irType = MediumBox;
	ir_sensor[3].irType = LargeBox;
	
	for (uint8_t i = 0; i < 3; i++) {
     f26:	8f 5f       	subi	r24, 0xFF	; 255
     f28:	83 30       	cpi	r24, 0x03	; 3
     f2a:	d0 f3       	brcs	.-12     	; 0xf20 <main+0x108>
			CajitaArr[i][j] = 0;
		}
	}
	
	/* END User code Init --------------------------------------------------------*/
	sei();
     f2c:	78 94       	sei

	while (1){
		/* User Code loop ------------------------------------------------------------*/
		task_HCSR();
     f2e:	0e 94 af 00 	call	0x15e	; 0x15e <task_HCSR>
		serialTask(&dataRx,&dataTx);
     f32:	66 eb       	ldi	r22, 0xB6	; 182
     f34:	72 e0       	ldi	r23, 0x02	; 2
     f36:	8b ea       	ldi	r24, 0xAB	; 171
     f38:	92 e0       	ldi	r25, 0x02	; 2
     f3a:	0e 94 13 04 	call	0x826	; 0x826 <serialTask>
		if (IS10MS)
     f3e:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <flag0>
     f42:	80 ff       	sbrs	r24, 0
     f44:	f4 cf       	rjmp	.-24     	; 0xf2e <main+0x116>
			every10ms();
     f46:	0e 94 8e 06 	call	0xd1c	; 0xd1c <every10ms>
     f4a:	f1 cf       	rjmp	.-30     	; 0xf2e <main+0x116>

00000f4c <addServo>:
static uint8_t ServN = 0;
volatile static uint8_t is20ms=156;
 
void addServo(volatile uint8_t* PORT,uint8_t Pin){
	
	servoHandle[ServN].pin=Pin;
     f4c:	20 91 8a 01 	lds	r18, 0x018A	; 0x80018a <ServN>
     f50:	e2 2f       	mov	r30, r18
     f52:	f0 e0       	ldi	r31, 0x00	; 0
     f54:	af 01       	movw	r20, r30
     f56:	44 0f       	add	r20, r20
     f58:	55 1f       	adc	r21, r21
     f5a:	44 0f       	add	r20, r20
     f5c:	55 1f       	adc	r21, r21
     f5e:	e4 0f       	add	r30, r20
     f60:	f5 1f       	adc	r31, r21
     f62:	e5 57       	subi	r30, 0x75	; 117
     f64:	fe 4f       	sbci	r31, 0xFE	; 254
     f66:	62 83       	std	Z+2, r22	; 0x02
	servoHandle[ServN].port=PORT;
     f68:	91 83       	std	Z+1, r25	; 0x01
     f6a:	80 83       	st	Z, r24
	ServN++;
     f6c:	2f 5f       	subi	r18, 0xFF	; 255
     f6e:	20 93 8a 01 	sts	0x018A, r18	; 0x80018a <ServN>
     f72:	08 95       	ret

00000f74 <servo_Angle>:
}
void servo_Angle(uint8_t servo,uint8_t angulo){
     f74:	48 2f       	mov	r20, r24
	
	uint16_t riseValue;
	
	riseValue = (uint16_t)angulo * ANGLE_TO_PWM_SLOPE;
     f76:	85 e7       	ldi	r24, 0x75	; 117
     f78:	68 9f       	mul	r22, r24
     f7a:	90 01       	movw	r18, r0
     f7c:	11 24       	eor	r1, r1
	riseValue += ANGLE_TO_PWM_OFFSET;
     f7e:	2e 5c       	subi	r18, 0xCE	; 206
     f80:	36 4d       	sbci	r19, 0xD6	; 214
	riseValue /= 180;
     f82:	a3 e8       	ldi	r26, 0x83	; 131
     f84:	bd e2       	ldi	r27, 0x2D	; 45
     f86:	0e 94 4b 08 	call	0x1096	; 0x1096 <__umulhisi3>
     f8a:	96 95       	lsr	r25
     f8c:	87 95       	ror	r24
     f8e:	92 95       	swap	r25
     f90:	82 95       	swap	r24
     f92:	8f 70       	andi	r24, 0x0F	; 15
     f94:	89 27       	eor	r24, r25
     f96:	9f 70       	andi	r25, 0x0F	; 15
     f98:	89 27       	eor	r24, r25
	riseValue += ROUNDING_CORRECTION;
     f9a:	9c 01       	movw	r18, r24
     f9c:	2b 5f       	subi	r18, 0xFB	; 251
     f9e:	3f 4f       	sbci	r19, 0xFF	; 255
	riseValue /= 10;
     fa0:	ad ec       	ldi	r26, 0xCD	; 205
     fa2:	bc ec       	ldi	r27, 0xCC	; 204
     fa4:	0e 94 4b 08 	call	0x1096	; 0x1096 <__umulhisi3>
     fa8:	96 95       	lsr	r25
     faa:	87 95       	ror	r24
     fac:	96 95       	lsr	r25
     fae:	87 95       	ror	r24
     fb0:	96 95       	lsr	r25
     fb2:	87 95       	ror	r24
		
	servoHandle[servo].dutyCycle = (uint8_t)riseValue;
     fb4:	24 2f       	mov	r18, r20
     fb6:	30 e0       	ldi	r19, 0x00	; 0
     fb8:	f9 01       	movw	r30, r18
     fba:	ee 0f       	add	r30, r30
     fbc:	ff 1f       	adc	r31, r31
     fbe:	ee 0f       	add	r30, r30
     fc0:	ff 1f       	adc	r31, r31
     fc2:	2e 0f       	add	r18, r30
     fc4:	3f 1f       	adc	r19, r31
     fc6:	f9 01       	movw	r30, r18
     fc8:	e5 57       	subi	r30, 0x75	; 117
     fca:	fe 4f       	sbci	r31, 0xFE	; 254
     fcc:	84 83       	std	Z+4, r24	; 0x04
     fce:	08 95       	ret

00000fd0 <writeServo>:
}

void writeServo(){
	is20ms--;
     fd0:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <is20ms>
     fd4:	81 50       	subi	r24, 0x01	; 1
     fd6:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <is20ms>
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     fda:	20 e0       	ldi	r18, 0x00	; 0
     fdc:	2a c0       	rjmp	.+84     	; 0x1032 <writeServo+0x62>
		servoHandle[counter].cycle--;
     fde:	82 2f       	mov	r24, r18
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	fc 01       	movw	r30, r24
     fe4:	ee 0f       	add	r30, r30
     fe6:	ff 1f       	adc	r31, r31
     fe8:	ee 0f       	add	r30, r30
     fea:	ff 1f       	adc	r31, r31
     fec:	e8 0f       	add	r30, r24
     fee:	f9 1f       	adc	r31, r25
     ff0:	e5 57       	subi	r30, 0x75	; 117
     ff2:	fe 4f       	sbci	r31, 0xFE	; 254
     ff4:	33 81       	ldd	r19, Z+3	; 0x03
     ff6:	31 50       	subi	r19, 0x01	; 1
     ff8:	33 83       	std	Z+3, r19	; 0x03
		if(!servoHandle[counter].cycle)
     ffa:	33 81       	ldd	r19, Z+3	; 0x03
     ffc:	31 11       	cpse	r19, r1
     ffe:	18 c0       	rjmp	.+48     	; 0x1030 <writeServo+0x60>
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
    1000:	fc 01       	movw	r30, r24
    1002:	ee 0f       	add	r30, r30
    1004:	ff 1f       	adc	r31, r31
    1006:	ee 0f       	add	r30, r30
    1008:	ff 1f       	adc	r31, r31
    100a:	8e 0f       	add	r24, r30
    100c:	9f 1f       	adc	r25, r31
    100e:	fc 01       	movw	r30, r24
    1010:	e5 57       	subi	r30, 0x75	; 117
    1012:	fe 4f       	sbci	r31, 0xFE	; 254
    1014:	a0 81       	ld	r26, Z
    1016:	b1 81       	ldd	r27, Z+1	; 0x01
    1018:	3c 91       	ld	r19, X
    101a:	81 e0       	ldi	r24, 0x01	; 1
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	02 80       	ldd	r0, Z+2	; 0x02
    1020:	02 c0       	rjmp	.+4      	; 0x1026 <writeServo+0x56>
    1022:	88 0f       	add	r24, r24
    1024:	99 1f       	adc	r25, r25
    1026:	0a 94       	dec	r0
    1028:	e2 f7       	brpl	.-8      	; 0x1022 <writeServo+0x52>
    102a:	80 95       	com	r24
    102c:	83 23       	and	r24, r19
    102e:	8c 93       	st	X, r24
void writeServo(){
	is20ms--;
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
    1030:	2f 5f       	subi	r18, 0xFF	; 255
    1032:	80 91 8a 01 	lds	r24, 0x018A	; 0x80018a <ServN>
    1036:	28 17       	cp	r18, r24
    1038:	90 f2       	brcs	.-92     	; 0xfde <writeServo+0xe>
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
    103a:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <is20ms>
    103e:	99 23       	and	r25, r25
    1040:	e9 f0       	breq	.+58     	; 0x107c <writeServo+0xac>
    1042:	08 95       	ret
		for(counter = 0; counter < ServN; counter++){
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
    1044:	e9 2f       	mov	r30, r25
    1046:	f0 e0       	ldi	r31, 0x00	; 0
    1048:	9f 01       	movw	r18, r30
    104a:	22 0f       	add	r18, r18
    104c:	33 1f       	adc	r19, r19
    104e:	22 0f       	add	r18, r18
    1050:	33 1f       	adc	r19, r19
    1052:	e2 0f       	add	r30, r18
    1054:	f3 1f       	adc	r31, r19
    1056:	e5 57       	subi	r30, 0x75	; 117
    1058:	fe 4f       	sbci	r31, 0xFE	; 254
    105a:	24 81       	ldd	r18, Z+4	; 0x04
    105c:	23 83       	std	Z+3, r18	; 0x03
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
    105e:	a0 81       	ld	r26, Z
    1060:	b1 81       	ldd	r27, Z+1	; 0x01
    1062:	4c 91       	ld	r20, X
    1064:	21 e0       	ldi	r18, 0x01	; 1
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	02 80       	ldd	r0, Z+2	; 0x02
    106a:	02 c0       	rjmp	.+4      	; 0x1070 <writeServo+0xa0>
    106c:	22 0f       	add	r18, r18
    106e:	33 1f       	adc	r19, r19
    1070:	0a 94       	dec	r0
    1072:	e2 f7       	brpl	.-8      	; 0x106c <writeServo+0x9c>
    1074:	24 2b       	or	r18, r20
    1076:	2c 93       	st	X, r18
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
		for(counter = 0; counter < ServN; counter++){
    1078:	9f 5f       	subi	r25, 0xFF	; 255
    107a:	01 c0       	rjmp	.+2      	; 0x107e <writeServo+0xae>
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	98 17       	cp	r25, r24
    1080:	08 f3       	brcs	.-62     	; 0x1044 <writeServo+0x74>
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
		}
		is20ms = 156;
    1082:	8c e9       	ldi	r24, 0x9C	; 156
    1084:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <is20ms>
    1088:	08 95       	ret

0000108a <__tablejump2__>:
    108a:	ee 0f       	add	r30, r30
    108c:	ff 1f       	adc	r31, r31
    108e:	05 90       	lpm	r0, Z+
    1090:	f4 91       	lpm	r31, Z
    1092:	e0 2d       	mov	r30, r0
    1094:	09 94       	ijmp

00001096 <__umulhisi3>:
    1096:	a2 9f       	mul	r26, r18
    1098:	b0 01       	movw	r22, r0
    109a:	b3 9f       	mul	r27, r19
    109c:	c0 01       	movw	r24, r0
    109e:	a3 9f       	mul	r26, r19
    10a0:	70 0d       	add	r23, r0
    10a2:	81 1d       	adc	r24, r1
    10a4:	11 24       	eor	r1, r1
    10a6:	91 1d       	adc	r25, r1
    10a8:	b2 9f       	mul	r27, r18
    10aa:	70 0d       	add	r23, r0
    10ac:	81 1d       	adc	r24, r1
    10ae:	11 24       	eor	r1, r1
    10b0:	91 1d       	adc	r25, r1
    10b2:	08 95       	ret

000010b4 <malloc>:
    10b4:	0f 93       	push	r16
    10b6:	1f 93       	push	r17
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	82 30       	cpi	r24, 0x02	; 2
    10be:	91 05       	cpc	r25, r1
    10c0:	10 f4       	brcc	.+4      	; 0x10c6 <malloc+0x12>
    10c2:	82 e0       	ldi	r24, 0x02	; 2
    10c4:	90 e0       	ldi	r25, 0x00	; 0
    10c6:	e0 91 8c 04 	lds	r30, 0x048C	; 0x80048c <__flp>
    10ca:	f0 91 8d 04 	lds	r31, 0x048D	; 0x80048d <__flp+0x1>
    10ce:	20 e0       	ldi	r18, 0x00	; 0
    10d0:	30 e0       	ldi	r19, 0x00	; 0
    10d2:	a0 e0       	ldi	r26, 0x00	; 0
    10d4:	b0 e0       	ldi	r27, 0x00	; 0
    10d6:	30 97       	sbiw	r30, 0x00	; 0
    10d8:	19 f1       	breq	.+70     	; 0x1120 <malloc+0x6c>
    10da:	40 81       	ld	r20, Z
    10dc:	51 81       	ldd	r21, Z+1	; 0x01
    10de:	02 81       	ldd	r16, Z+2	; 0x02
    10e0:	13 81       	ldd	r17, Z+3	; 0x03
    10e2:	48 17       	cp	r20, r24
    10e4:	59 07       	cpc	r21, r25
    10e6:	c8 f0       	brcs	.+50     	; 0x111a <malloc+0x66>
    10e8:	84 17       	cp	r24, r20
    10ea:	95 07       	cpc	r25, r21
    10ec:	69 f4       	brne	.+26     	; 0x1108 <malloc+0x54>
    10ee:	10 97       	sbiw	r26, 0x00	; 0
    10f0:	31 f0       	breq	.+12     	; 0x10fe <malloc+0x4a>
    10f2:	12 96       	adiw	r26, 0x02	; 2
    10f4:	0c 93       	st	X, r16
    10f6:	12 97       	sbiw	r26, 0x02	; 2
    10f8:	13 96       	adiw	r26, 0x03	; 3
    10fa:	1c 93       	st	X, r17
    10fc:	27 c0       	rjmp	.+78     	; 0x114c <malloc+0x98>
    10fe:	00 93 8c 04 	sts	0x048C, r16	; 0x80048c <__flp>
    1102:	10 93 8d 04 	sts	0x048D, r17	; 0x80048d <__flp+0x1>
    1106:	22 c0       	rjmp	.+68     	; 0x114c <malloc+0x98>
    1108:	21 15       	cp	r18, r1
    110a:	31 05       	cpc	r19, r1
    110c:	19 f0       	breq	.+6      	; 0x1114 <malloc+0x60>
    110e:	42 17       	cp	r20, r18
    1110:	53 07       	cpc	r21, r19
    1112:	18 f4       	brcc	.+6      	; 0x111a <malloc+0x66>
    1114:	9a 01       	movw	r18, r20
    1116:	bd 01       	movw	r22, r26
    1118:	ef 01       	movw	r28, r30
    111a:	df 01       	movw	r26, r30
    111c:	f8 01       	movw	r30, r16
    111e:	db cf       	rjmp	.-74     	; 0x10d6 <malloc+0x22>
    1120:	21 15       	cp	r18, r1
    1122:	31 05       	cpc	r19, r1
    1124:	f9 f0       	breq	.+62     	; 0x1164 <malloc+0xb0>
    1126:	28 1b       	sub	r18, r24
    1128:	39 0b       	sbc	r19, r25
    112a:	24 30       	cpi	r18, 0x04	; 4
    112c:	31 05       	cpc	r19, r1
    112e:	80 f4       	brcc	.+32     	; 0x1150 <malloc+0x9c>
    1130:	8a 81       	ldd	r24, Y+2	; 0x02
    1132:	9b 81       	ldd	r25, Y+3	; 0x03
    1134:	61 15       	cp	r22, r1
    1136:	71 05       	cpc	r23, r1
    1138:	21 f0       	breq	.+8      	; 0x1142 <malloc+0x8e>
    113a:	fb 01       	movw	r30, r22
    113c:	93 83       	std	Z+3, r25	; 0x03
    113e:	82 83       	std	Z+2, r24	; 0x02
    1140:	04 c0       	rjmp	.+8      	; 0x114a <malloc+0x96>
    1142:	90 93 8d 04 	sts	0x048D, r25	; 0x80048d <__flp+0x1>
    1146:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <__flp>
    114a:	fe 01       	movw	r30, r28
    114c:	32 96       	adiw	r30, 0x02	; 2
    114e:	44 c0       	rjmp	.+136    	; 0x11d8 <malloc+0x124>
    1150:	fe 01       	movw	r30, r28
    1152:	e2 0f       	add	r30, r18
    1154:	f3 1f       	adc	r31, r19
    1156:	81 93       	st	Z+, r24
    1158:	91 93       	st	Z+, r25
    115a:	22 50       	subi	r18, 0x02	; 2
    115c:	31 09       	sbc	r19, r1
    115e:	39 83       	std	Y+1, r19	; 0x01
    1160:	28 83       	st	Y, r18
    1162:	3a c0       	rjmp	.+116    	; 0x11d8 <malloc+0x124>
    1164:	20 91 8a 04 	lds	r18, 0x048A	; 0x80048a <__brkval>
    1168:	30 91 8b 04 	lds	r19, 0x048B	; 0x80048b <__brkval+0x1>
    116c:	23 2b       	or	r18, r19
    116e:	41 f4       	brne	.+16     	; 0x1180 <malloc+0xcc>
    1170:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1174:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1178:	30 93 8b 04 	sts	0x048B, r19	; 0x80048b <__brkval+0x1>
    117c:	20 93 8a 04 	sts	0x048A, r18	; 0x80048a <__brkval>
    1180:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    1184:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    1188:	21 15       	cp	r18, r1
    118a:	31 05       	cpc	r19, r1
    118c:	41 f4       	brne	.+16     	; 0x119e <malloc+0xea>
    118e:	2d b7       	in	r18, 0x3d	; 61
    1190:	3e b7       	in	r19, 0x3e	; 62
    1192:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1196:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    119a:	24 1b       	sub	r18, r20
    119c:	35 0b       	sbc	r19, r21
    119e:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <__brkval>
    11a2:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <__brkval+0x1>
    11a6:	e2 17       	cp	r30, r18
    11a8:	f3 07       	cpc	r31, r19
    11aa:	a0 f4       	brcc	.+40     	; 0x11d4 <malloc+0x120>
    11ac:	2e 1b       	sub	r18, r30
    11ae:	3f 0b       	sbc	r19, r31
    11b0:	28 17       	cp	r18, r24
    11b2:	39 07       	cpc	r19, r25
    11b4:	78 f0       	brcs	.+30     	; 0x11d4 <malloc+0x120>
    11b6:	ac 01       	movw	r20, r24
    11b8:	4e 5f       	subi	r20, 0xFE	; 254
    11ba:	5f 4f       	sbci	r21, 0xFF	; 255
    11bc:	24 17       	cp	r18, r20
    11be:	35 07       	cpc	r19, r21
    11c0:	48 f0       	brcs	.+18     	; 0x11d4 <malloc+0x120>
    11c2:	4e 0f       	add	r20, r30
    11c4:	5f 1f       	adc	r21, r31
    11c6:	50 93 8b 04 	sts	0x048B, r21	; 0x80048b <__brkval+0x1>
    11ca:	40 93 8a 04 	sts	0x048A, r20	; 0x80048a <__brkval>
    11ce:	81 93       	st	Z+, r24
    11d0:	91 93       	st	Z+, r25
    11d2:	02 c0       	rjmp	.+4      	; 0x11d8 <malloc+0x124>
    11d4:	e0 e0       	ldi	r30, 0x00	; 0
    11d6:	f0 e0       	ldi	r31, 0x00	; 0
    11d8:	cf 01       	movw	r24, r30
    11da:	df 91       	pop	r29
    11dc:	cf 91       	pop	r28
    11de:	1f 91       	pop	r17
    11e0:	0f 91       	pop	r16
    11e2:	08 95       	ret

000011e4 <free>:
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	00 97       	sbiw	r24, 0x00	; 0
    11ea:	09 f4       	brne	.+2      	; 0x11ee <free+0xa>
    11ec:	81 c0       	rjmp	.+258    	; 0x12f0 <free+0x10c>
    11ee:	fc 01       	movw	r30, r24
    11f0:	32 97       	sbiw	r30, 0x02	; 2
    11f2:	13 82       	std	Z+3, r1	; 0x03
    11f4:	12 82       	std	Z+2, r1	; 0x02
    11f6:	a0 91 8c 04 	lds	r26, 0x048C	; 0x80048c <__flp>
    11fa:	b0 91 8d 04 	lds	r27, 0x048D	; 0x80048d <__flp+0x1>
    11fe:	10 97       	sbiw	r26, 0x00	; 0
    1200:	81 f4       	brne	.+32     	; 0x1222 <free+0x3e>
    1202:	20 81       	ld	r18, Z
    1204:	31 81       	ldd	r19, Z+1	; 0x01
    1206:	82 0f       	add	r24, r18
    1208:	93 1f       	adc	r25, r19
    120a:	20 91 8a 04 	lds	r18, 0x048A	; 0x80048a <__brkval>
    120e:	30 91 8b 04 	lds	r19, 0x048B	; 0x80048b <__brkval+0x1>
    1212:	28 17       	cp	r18, r24
    1214:	39 07       	cpc	r19, r25
    1216:	51 f5       	brne	.+84     	; 0x126c <free+0x88>
    1218:	f0 93 8b 04 	sts	0x048B, r31	; 0x80048b <__brkval+0x1>
    121c:	e0 93 8a 04 	sts	0x048A, r30	; 0x80048a <__brkval>
    1220:	67 c0       	rjmp	.+206    	; 0x12f0 <free+0x10c>
    1222:	ed 01       	movw	r28, r26
    1224:	20 e0       	ldi	r18, 0x00	; 0
    1226:	30 e0       	ldi	r19, 0x00	; 0
    1228:	ce 17       	cp	r28, r30
    122a:	df 07       	cpc	r29, r31
    122c:	40 f4       	brcc	.+16     	; 0x123e <free+0x5a>
    122e:	4a 81       	ldd	r20, Y+2	; 0x02
    1230:	5b 81       	ldd	r21, Y+3	; 0x03
    1232:	9e 01       	movw	r18, r28
    1234:	41 15       	cp	r20, r1
    1236:	51 05       	cpc	r21, r1
    1238:	f1 f0       	breq	.+60     	; 0x1276 <free+0x92>
    123a:	ea 01       	movw	r28, r20
    123c:	f5 cf       	rjmp	.-22     	; 0x1228 <free+0x44>
    123e:	d3 83       	std	Z+3, r29	; 0x03
    1240:	c2 83       	std	Z+2, r28	; 0x02
    1242:	40 81       	ld	r20, Z
    1244:	51 81       	ldd	r21, Z+1	; 0x01
    1246:	84 0f       	add	r24, r20
    1248:	95 1f       	adc	r25, r21
    124a:	c8 17       	cp	r28, r24
    124c:	d9 07       	cpc	r29, r25
    124e:	59 f4       	brne	.+22     	; 0x1266 <free+0x82>
    1250:	88 81       	ld	r24, Y
    1252:	99 81       	ldd	r25, Y+1	; 0x01
    1254:	84 0f       	add	r24, r20
    1256:	95 1f       	adc	r25, r21
    1258:	02 96       	adiw	r24, 0x02	; 2
    125a:	91 83       	std	Z+1, r25	; 0x01
    125c:	80 83       	st	Z, r24
    125e:	8a 81       	ldd	r24, Y+2	; 0x02
    1260:	9b 81       	ldd	r25, Y+3	; 0x03
    1262:	93 83       	std	Z+3, r25	; 0x03
    1264:	82 83       	std	Z+2, r24	; 0x02
    1266:	21 15       	cp	r18, r1
    1268:	31 05       	cpc	r19, r1
    126a:	29 f4       	brne	.+10     	; 0x1276 <free+0x92>
    126c:	f0 93 8d 04 	sts	0x048D, r31	; 0x80048d <__flp+0x1>
    1270:	e0 93 8c 04 	sts	0x048C, r30	; 0x80048c <__flp>
    1274:	3d c0       	rjmp	.+122    	; 0x12f0 <free+0x10c>
    1276:	e9 01       	movw	r28, r18
    1278:	fb 83       	std	Y+3, r31	; 0x03
    127a:	ea 83       	std	Y+2, r30	; 0x02
    127c:	49 91       	ld	r20, Y+
    127e:	59 91       	ld	r21, Y+
    1280:	c4 0f       	add	r28, r20
    1282:	d5 1f       	adc	r29, r21
    1284:	ec 17       	cp	r30, r28
    1286:	fd 07       	cpc	r31, r29
    1288:	61 f4       	brne	.+24     	; 0x12a2 <free+0xbe>
    128a:	80 81       	ld	r24, Z
    128c:	91 81       	ldd	r25, Z+1	; 0x01
    128e:	84 0f       	add	r24, r20
    1290:	95 1f       	adc	r25, r21
    1292:	02 96       	adiw	r24, 0x02	; 2
    1294:	e9 01       	movw	r28, r18
    1296:	99 83       	std	Y+1, r25	; 0x01
    1298:	88 83       	st	Y, r24
    129a:	82 81       	ldd	r24, Z+2	; 0x02
    129c:	93 81       	ldd	r25, Z+3	; 0x03
    129e:	9b 83       	std	Y+3, r25	; 0x03
    12a0:	8a 83       	std	Y+2, r24	; 0x02
    12a2:	e0 e0       	ldi	r30, 0x00	; 0
    12a4:	f0 e0       	ldi	r31, 0x00	; 0
    12a6:	12 96       	adiw	r26, 0x02	; 2
    12a8:	8d 91       	ld	r24, X+
    12aa:	9c 91       	ld	r25, X
    12ac:	13 97       	sbiw	r26, 0x03	; 3
    12ae:	00 97       	sbiw	r24, 0x00	; 0
    12b0:	19 f0       	breq	.+6      	; 0x12b8 <free+0xd4>
    12b2:	fd 01       	movw	r30, r26
    12b4:	dc 01       	movw	r26, r24
    12b6:	f7 cf       	rjmp	.-18     	; 0x12a6 <free+0xc2>
    12b8:	8d 91       	ld	r24, X+
    12ba:	9c 91       	ld	r25, X
    12bc:	11 97       	sbiw	r26, 0x01	; 1
    12be:	9d 01       	movw	r18, r26
    12c0:	2e 5f       	subi	r18, 0xFE	; 254
    12c2:	3f 4f       	sbci	r19, 0xFF	; 255
    12c4:	82 0f       	add	r24, r18
    12c6:	93 1f       	adc	r25, r19
    12c8:	20 91 8a 04 	lds	r18, 0x048A	; 0x80048a <__brkval>
    12cc:	30 91 8b 04 	lds	r19, 0x048B	; 0x80048b <__brkval+0x1>
    12d0:	28 17       	cp	r18, r24
    12d2:	39 07       	cpc	r19, r25
    12d4:	69 f4       	brne	.+26     	; 0x12f0 <free+0x10c>
    12d6:	30 97       	sbiw	r30, 0x00	; 0
    12d8:	29 f4       	brne	.+10     	; 0x12e4 <free+0x100>
    12da:	10 92 8d 04 	sts	0x048D, r1	; 0x80048d <__flp+0x1>
    12de:	10 92 8c 04 	sts	0x048C, r1	; 0x80048c <__flp>
    12e2:	02 c0       	rjmp	.+4      	; 0x12e8 <free+0x104>
    12e4:	13 82       	std	Z+3, r1	; 0x03
    12e6:	12 82       	std	Z+2, r1	; 0x02
    12e8:	b0 93 8b 04 	sts	0x048B, r27	; 0x80048b <__brkval+0x1>
    12ec:	a0 93 8a 04 	sts	0x048A, r26	; 0x80048a <__brkval>
    12f0:	df 91       	pop	r29
    12f2:	cf 91       	pop	r28
    12f4:	08 95       	ret

000012f6 <printf>:
    12f6:	a0 e0       	ldi	r26, 0x00	; 0
    12f8:	b0 e0       	ldi	r27, 0x00	; 0
    12fa:	e1 e8       	ldi	r30, 0x81	; 129
    12fc:	f9 e0       	ldi	r31, 0x09	; 9
    12fe:	0c 94 69 0c 	jmp	0x18d2	; 0x18d2 <__prologue_saves__+0x20>
    1302:	ae 01       	movw	r20, r28
    1304:	4b 5f       	subi	r20, 0xFB	; 251
    1306:	5f 4f       	sbci	r21, 0xFF	; 255
    1308:	fa 01       	movw	r30, r20
    130a:	61 91       	ld	r22, Z+
    130c:	71 91       	ld	r23, Z+
    130e:	af 01       	movw	r20, r30
    1310:	80 91 90 04 	lds	r24, 0x0490	; 0x800490 <__iob+0x2>
    1314:	90 91 91 04 	lds	r25, 0x0491	; 0x800491 <__iob+0x3>
    1318:	0e 94 c8 09 	call	0x1390	; 0x1390 <vfprintf>
    131c:	e2 e0       	ldi	r30, 0x02	; 2
    131e:	0c 94 85 0c 	jmp	0x190a	; 0x190a <__epilogue_restores__+0x20>

00001322 <putchar>:
    1322:	60 91 90 04 	lds	r22, 0x0490	; 0x800490 <__iob+0x2>
    1326:	70 91 91 04 	lds	r23, 0x0491	; 0x800491 <__iob+0x3>
    132a:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    132e:	08 95       	ret

00001330 <puts>:
    1330:	0f 93       	push	r16
    1332:	1f 93       	push	r17
    1334:	cf 93       	push	r28
    1336:	df 93       	push	r29
    1338:	e0 91 90 04 	lds	r30, 0x0490	; 0x800490 <__iob+0x2>
    133c:	f0 91 91 04 	lds	r31, 0x0491	; 0x800491 <__iob+0x3>
    1340:	23 81       	ldd	r18, Z+3	; 0x03
    1342:	21 ff       	sbrs	r18, 1
    1344:	1b c0       	rjmp	.+54     	; 0x137c <puts+0x4c>
    1346:	8c 01       	movw	r16, r24
    1348:	d0 e0       	ldi	r29, 0x00	; 0
    134a:	c0 e0       	ldi	r28, 0x00	; 0
    134c:	f8 01       	movw	r30, r16
    134e:	81 91       	ld	r24, Z+
    1350:	8f 01       	movw	r16, r30
    1352:	60 91 90 04 	lds	r22, 0x0490	; 0x800490 <__iob+0x2>
    1356:	70 91 91 04 	lds	r23, 0x0491	; 0x800491 <__iob+0x3>
    135a:	db 01       	movw	r26, r22
    135c:	18 96       	adiw	r26, 0x08	; 8
    135e:	ed 91       	ld	r30, X+
    1360:	fc 91       	ld	r31, X
    1362:	19 97       	sbiw	r26, 0x09	; 9
    1364:	88 23       	and	r24, r24
    1366:	31 f0       	breq	.+12     	; 0x1374 <puts+0x44>
    1368:	09 95       	icall
    136a:	89 2b       	or	r24, r25
    136c:	79 f3       	breq	.-34     	; 0x134c <puts+0x1c>
    136e:	df ef       	ldi	r29, 0xFF	; 255
    1370:	cf ef       	ldi	r28, 0xFF	; 255
    1372:	ec cf       	rjmp	.-40     	; 0x134c <puts+0x1c>
    1374:	8a e0       	ldi	r24, 0x0A	; 10
    1376:	09 95       	icall
    1378:	89 2b       	or	r24, r25
    137a:	19 f0       	breq	.+6      	; 0x1382 <puts+0x52>
    137c:	8f ef       	ldi	r24, 0xFF	; 255
    137e:	9f ef       	ldi	r25, 0xFF	; 255
    1380:	02 c0       	rjmp	.+4      	; 0x1386 <puts+0x56>
    1382:	8d 2f       	mov	r24, r29
    1384:	9c 2f       	mov	r25, r28
    1386:	df 91       	pop	r29
    1388:	cf 91       	pop	r28
    138a:	1f 91       	pop	r17
    138c:	0f 91       	pop	r16
    138e:	08 95       	ret

00001390 <vfprintf>:
    1390:	ab e0       	ldi	r26, 0x0B	; 11
    1392:	b0 e0       	ldi	r27, 0x00	; 0
    1394:	ee ec       	ldi	r30, 0xCE	; 206
    1396:	f9 e0       	ldi	r31, 0x09	; 9
    1398:	0c 94 59 0c 	jmp	0x18b2	; 0x18b2 <__prologue_saves__>
    139c:	6c 01       	movw	r12, r24
    139e:	7b 01       	movw	r14, r22
    13a0:	8a 01       	movw	r16, r20
    13a2:	fc 01       	movw	r30, r24
    13a4:	17 82       	std	Z+7, r1	; 0x07
    13a6:	16 82       	std	Z+6, r1	; 0x06
    13a8:	83 81       	ldd	r24, Z+3	; 0x03
    13aa:	81 ff       	sbrs	r24, 1
    13ac:	cc c1       	rjmp	.+920    	; 0x1746 <vfprintf+0x3b6>
    13ae:	ce 01       	movw	r24, r28
    13b0:	01 96       	adiw	r24, 0x01	; 1
    13b2:	3c 01       	movw	r6, r24
    13b4:	f6 01       	movw	r30, r12
    13b6:	93 81       	ldd	r25, Z+3	; 0x03
    13b8:	f7 01       	movw	r30, r14
    13ba:	93 fd       	sbrc	r25, 3
    13bc:	85 91       	lpm	r24, Z+
    13be:	93 ff       	sbrs	r25, 3
    13c0:	81 91       	ld	r24, Z+
    13c2:	7f 01       	movw	r14, r30
    13c4:	88 23       	and	r24, r24
    13c6:	09 f4       	brne	.+2      	; 0x13ca <vfprintf+0x3a>
    13c8:	ba c1       	rjmp	.+884    	; 0x173e <vfprintf+0x3ae>
    13ca:	85 32       	cpi	r24, 0x25	; 37
    13cc:	39 f4       	brne	.+14     	; 0x13dc <vfprintf+0x4c>
    13ce:	93 fd       	sbrc	r25, 3
    13d0:	85 91       	lpm	r24, Z+
    13d2:	93 ff       	sbrs	r25, 3
    13d4:	81 91       	ld	r24, Z+
    13d6:	7f 01       	movw	r14, r30
    13d8:	85 32       	cpi	r24, 0x25	; 37
    13da:	29 f4       	brne	.+10     	; 0x13e6 <vfprintf+0x56>
    13dc:	b6 01       	movw	r22, r12
    13de:	90 e0       	ldi	r25, 0x00	; 0
    13e0:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    13e4:	e7 cf       	rjmp	.-50     	; 0x13b4 <vfprintf+0x24>
    13e6:	91 2c       	mov	r9, r1
    13e8:	21 2c       	mov	r2, r1
    13ea:	31 2c       	mov	r3, r1
    13ec:	ff e1       	ldi	r31, 0x1F	; 31
    13ee:	f3 15       	cp	r31, r3
    13f0:	d8 f0       	brcs	.+54     	; 0x1428 <vfprintf+0x98>
    13f2:	8b 32       	cpi	r24, 0x2B	; 43
    13f4:	79 f0       	breq	.+30     	; 0x1414 <vfprintf+0x84>
    13f6:	38 f4       	brcc	.+14     	; 0x1406 <vfprintf+0x76>
    13f8:	80 32       	cpi	r24, 0x20	; 32
    13fa:	79 f0       	breq	.+30     	; 0x141a <vfprintf+0x8a>
    13fc:	83 32       	cpi	r24, 0x23	; 35
    13fe:	a1 f4       	brne	.+40     	; 0x1428 <vfprintf+0x98>
    1400:	23 2d       	mov	r18, r3
    1402:	20 61       	ori	r18, 0x10	; 16
    1404:	1d c0       	rjmp	.+58     	; 0x1440 <vfprintf+0xb0>
    1406:	8d 32       	cpi	r24, 0x2D	; 45
    1408:	61 f0       	breq	.+24     	; 0x1422 <vfprintf+0x92>
    140a:	80 33       	cpi	r24, 0x30	; 48
    140c:	69 f4       	brne	.+26     	; 0x1428 <vfprintf+0x98>
    140e:	23 2d       	mov	r18, r3
    1410:	21 60       	ori	r18, 0x01	; 1
    1412:	16 c0       	rjmp	.+44     	; 0x1440 <vfprintf+0xb0>
    1414:	83 2d       	mov	r24, r3
    1416:	82 60       	ori	r24, 0x02	; 2
    1418:	38 2e       	mov	r3, r24
    141a:	e3 2d       	mov	r30, r3
    141c:	e4 60       	ori	r30, 0x04	; 4
    141e:	3e 2e       	mov	r3, r30
    1420:	2a c0       	rjmp	.+84     	; 0x1476 <vfprintf+0xe6>
    1422:	f3 2d       	mov	r31, r3
    1424:	f8 60       	ori	r31, 0x08	; 8
    1426:	1d c0       	rjmp	.+58     	; 0x1462 <vfprintf+0xd2>
    1428:	37 fc       	sbrc	r3, 7
    142a:	2d c0       	rjmp	.+90     	; 0x1486 <vfprintf+0xf6>
    142c:	20 ed       	ldi	r18, 0xD0	; 208
    142e:	28 0f       	add	r18, r24
    1430:	2a 30       	cpi	r18, 0x0A	; 10
    1432:	40 f0       	brcs	.+16     	; 0x1444 <vfprintf+0xb4>
    1434:	8e 32       	cpi	r24, 0x2E	; 46
    1436:	b9 f4       	brne	.+46     	; 0x1466 <vfprintf+0xd6>
    1438:	36 fc       	sbrc	r3, 6
    143a:	81 c1       	rjmp	.+770    	; 0x173e <vfprintf+0x3ae>
    143c:	23 2d       	mov	r18, r3
    143e:	20 64       	ori	r18, 0x40	; 64
    1440:	32 2e       	mov	r3, r18
    1442:	19 c0       	rjmp	.+50     	; 0x1476 <vfprintf+0xe6>
    1444:	36 fe       	sbrs	r3, 6
    1446:	06 c0       	rjmp	.+12     	; 0x1454 <vfprintf+0xc4>
    1448:	8a e0       	ldi	r24, 0x0A	; 10
    144a:	98 9e       	mul	r9, r24
    144c:	20 0d       	add	r18, r0
    144e:	11 24       	eor	r1, r1
    1450:	92 2e       	mov	r9, r18
    1452:	11 c0       	rjmp	.+34     	; 0x1476 <vfprintf+0xe6>
    1454:	ea e0       	ldi	r30, 0x0A	; 10
    1456:	2e 9e       	mul	r2, r30
    1458:	20 0d       	add	r18, r0
    145a:	11 24       	eor	r1, r1
    145c:	22 2e       	mov	r2, r18
    145e:	f3 2d       	mov	r31, r3
    1460:	f0 62       	ori	r31, 0x20	; 32
    1462:	3f 2e       	mov	r3, r31
    1464:	08 c0       	rjmp	.+16     	; 0x1476 <vfprintf+0xe6>
    1466:	8c 36       	cpi	r24, 0x6C	; 108
    1468:	21 f4       	brne	.+8      	; 0x1472 <vfprintf+0xe2>
    146a:	83 2d       	mov	r24, r3
    146c:	80 68       	ori	r24, 0x80	; 128
    146e:	38 2e       	mov	r3, r24
    1470:	02 c0       	rjmp	.+4      	; 0x1476 <vfprintf+0xe6>
    1472:	88 36       	cpi	r24, 0x68	; 104
    1474:	41 f4       	brne	.+16     	; 0x1486 <vfprintf+0xf6>
    1476:	f7 01       	movw	r30, r14
    1478:	93 fd       	sbrc	r25, 3
    147a:	85 91       	lpm	r24, Z+
    147c:	93 ff       	sbrs	r25, 3
    147e:	81 91       	ld	r24, Z+
    1480:	7f 01       	movw	r14, r30
    1482:	81 11       	cpse	r24, r1
    1484:	b3 cf       	rjmp	.-154    	; 0x13ec <vfprintf+0x5c>
    1486:	98 2f       	mov	r25, r24
    1488:	9f 7d       	andi	r25, 0xDF	; 223
    148a:	95 54       	subi	r25, 0x45	; 69
    148c:	93 30       	cpi	r25, 0x03	; 3
    148e:	28 f4       	brcc	.+10     	; 0x149a <vfprintf+0x10a>
    1490:	0c 5f       	subi	r16, 0xFC	; 252
    1492:	1f 4f       	sbci	r17, 0xFF	; 255
    1494:	9f e3       	ldi	r25, 0x3F	; 63
    1496:	99 83       	std	Y+1, r25	; 0x01
    1498:	0d c0       	rjmp	.+26     	; 0x14b4 <vfprintf+0x124>
    149a:	83 36       	cpi	r24, 0x63	; 99
    149c:	31 f0       	breq	.+12     	; 0x14aa <vfprintf+0x11a>
    149e:	83 37       	cpi	r24, 0x73	; 115
    14a0:	71 f0       	breq	.+28     	; 0x14be <vfprintf+0x12e>
    14a2:	83 35       	cpi	r24, 0x53	; 83
    14a4:	09 f0       	breq	.+2      	; 0x14a8 <vfprintf+0x118>
    14a6:	59 c0       	rjmp	.+178    	; 0x155a <vfprintf+0x1ca>
    14a8:	21 c0       	rjmp	.+66     	; 0x14ec <vfprintf+0x15c>
    14aa:	f8 01       	movw	r30, r16
    14ac:	80 81       	ld	r24, Z
    14ae:	89 83       	std	Y+1, r24	; 0x01
    14b0:	0e 5f       	subi	r16, 0xFE	; 254
    14b2:	1f 4f       	sbci	r17, 0xFF	; 255
    14b4:	88 24       	eor	r8, r8
    14b6:	83 94       	inc	r8
    14b8:	91 2c       	mov	r9, r1
    14ba:	53 01       	movw	r10, r6
    14bc:	13 c0       	rjmp	.+38     	; 0x14e4 <vfprintf+0x154>
    14be:	28 01       	movw	r4, r16
    14c0:	f2 e0       	ldi	r31, 0x02	; 2
    14c2:	4f 0e       	add	r4, r31
    14c4:	51 1c       	adc	r5, r1
    14c6:	f8 01       	movw	r30, r16
    14c8:	a0 80       	ld	r10, Z
    14ca:	b1 80       	ldd	r11, Z+1	; 0x01
    14cc:	36 fe       	sbrs	r3, 6
    14ce:	03 c0       	rjmp	.+6      	; 0x14d6 <vfprintf+0x146>
    14d0:	69 2d       	mov	r22, r9
    14d2:	70 e0       	ldi	r23, 0x00	; 0
    14d4:	02 c0       	rjmp	.+4      	; 0x14da <vfprintf+0x14a>
    14d6:	6f ef       	ldi	r22, 0xFF	; 255
    14d8:	7f ef       	ldi	r23, 0xFF	; 255
    14da:	c5 01       	movw	r24, r10
    14dc:	0e 94 b4 0b 	call	0x1768	; 0x1768 <strnlen>
    14e0:	4c 01       	movw	r8, r24
    14e2:	82 01       	movw	r16, r4
    14e4:	f3 2d       	mov	r31, r3
    14e6:	ff 77       	andi	r31, 0x7F	; 127
    14e8:	3f 2e       	mov	r3, r31
    14ea:	16 c0       	rjmp	.+44     	; 0x1518 <vfprintf+0x188>
    14ec:	28 01       	movw	r4, r16
    14ee:	22 e0       	ldi	r18, 0x02	; 2
    14f0:	42 0e       	add	r4, r18
    14f2:	51 1c       	adc	r5, r1
    14f4:	f8 01       	movw	r30, r16
    14f6:	a0 80       	ld	r10, Z
    14f8:	b1 80       	ldd	r11, Z+1	; 0x01
    14fa:	36 fe       	sbrs	r3, 6
    14fc:	03 c0       	rjmp	.+6      	; 0x1504 <vfprintf+0x174>
    14fe:	69 2d       	mov	r22, r9
    1500:	70 e0       	ldi	r23, 0x00	; 0
    1502:	02 c0       	rjmp	.+4      	; 0x1508 <vfprintf+0x178>
    1504:	6f ef       	ldi	r22, 0xFF	; 255
    1506:	7f ef       	ldi	r23, 0xFF	; 255
    1508:	c5 01       	movw	r24, r10
    150a:	0e 94 a9 0b 	call	0x1752	; 0x1752 <strnlen_P>
    150e:	4c 01       	movw	r8, r24
    1510:	f3 2d       	mov	r31, r3
    1512:	f0 68       	ori	r31, 0x80	; 128
    1514:	3f 2e       	mov	r3, r31
    1516:	82 01       	movw	r16, r4
    1518:	33 fc       	sbrc	r3, 3
    151a:	1b c0       	rjmp	.+54     	; 0x1552 <vfprintf+0x1c2>
    151c:	82 2d       	mov	r24, r2
    151e:	90 e0       	ldi	r25, 0x00	; 0
    1520:	88 16       	cp	r8, r24
    1522:	99 06       	cpc	r9, r25
    1524:	b0 f4       	brcc	.+44     	; 0x1552 <vfprintf+0x1c2>
    1526:	b6 01       	movw	r22, r12
    1528:	80 e2       	ldi	r24, 0x20	; 32
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    1530:	2a 94       	dec	r2
    1532:	f4 cf       	rjmp	.-24     	; 0x151c <vfprintf+0x18c>
    1534:	f5 01       	movw	r30, r10
    1536:	37 fc       	sbrc	r3, 7
    1538:	85 91       	lpm	r24, Z+
    153a:	37 fe       	sbrs	r3, 7
    153c:	81 91       	ld	r24, Z+
    153e:	5f 01       	movw	r10, r30
    1540:	b6 01       	movw	r22, r12
    1542:	90 e0       	ldi	r25, 0x00	; 0
    1544:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    1548:	21 10       	cpse	r2, r1
    154a:	2a 94       	dec	r2
    154c:	21 e0       	ldi	r18, 0x01	; 1
    154e:	82 1a       	sub	r8, r18
    1550:	91 08       	sbc	r9, r1
    1552:	81 14       	cp	r8, r1
    1554:	91 04       	cpc	r9, r1
    1556:	71 f7       	brne	.-36     	; 0x1534 <vfprintf+0x1a4>
    1558:	e8 c0       	rjmp	.+464    	; 0x172a <vfprintf+0x39a>
    155a:	84 36       	cpi	r24, 0x64	; 100
    155c:	11 f0       	breq	.+4      	; 0x1562 <vfprintf+0x1d2>
    155e:	89 36       	cpi	r24, 0x69	; 105
    1560:	41 f5       	brne	.+80     	; 0x15b2 <vfprintf+0x222>
    1562:	f8 01       	movw	r30, r16
    1564:	37 fe       	sbrs	r3, 7
    1566:	07 c0       	rjmp	.+14     	; 0x1576 <vfprintf+0x1e6>
    1568:	60 81       	ld	r22, Z
    156a:	71 81       	ldd	r23, Z+1	; 0x01
    156c:	82 81       	ldd	r24, Z+2	; 0x02
    156e:	93 81       	ldd	r25, Z+3	; 0x03
    1570:	0c 5f       	subi	r16, 0xFC	; 252
    1572:	1f 4f       	sbci	r17, 0xFF	; 255
    1574:	08 c0       	rjmp	.+16     	; 0x1586 <vfprintf+0x1f6>
    1576:	60 81       	ld	r22, Z
    1578:	71 81       	ldd	r23, Z+1	; 0x01
    157a:	07 2e       	mov	r0, r23
    157c:	00 0c       	add	r0, r0
    157e:	88 0b       	sbc	r24, r24
    1580:	99 0b       	sbc	r25, r25
    1582:	0e 5f       	subi	r16, 0xFE	; 254
    1584:	1f 4f       	sbci	r17, 0xFF	; 255
    1586:	f3 2d       	mov	r31, r3
    1588:	ff 76       	andi	r31, 0x6F	; 111
    158a:	3f 2e       	mov	r3, r31
    158c:	97 ff       	sbrs	r25, 7
    158e:	09 c0       	rjmp	.+18     	; 0x15a2 <vfprintf+0x212>
    1590:	90 95       	com	r25
    1592:	80 95       	com	r24
    1594:	70 95       	com	r23
    1596:	61 95       	neg	r22
    1598:	7f 4f       	sbci	r23, 0xFF	; 255
    159a:	8f 4f       	sbci	r24, 0xFF	; 255
    159c:	9f 4f       	sbci	r25, 0xFF	; 255
    159e:	f0 68       	ori	r31, 0x80	; 128
    15a0:	3f 2e       	mov	r3, r31
    15a2:	2a e0       	ldi	r18, 0x0A	; 10
    15a4:	30 e0       	ldi	r19, 0x00	; 0
    15a6:	a3 01       	movw	r20, r6
    15a8:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <__ultoa_invert>
    15ac:	88 2e       	mov	r8, r24
    15ae:	86 18       	sub	r8, r6
    15b0:	45 c0       	rjmp	.+138    	; 0x163c <vfprintf+0x2ac>
    15b2:	85 37       	cpi	r24, 0x75	; 117
    15b4:	31 f4       	brne	.+12     	; 0x15c2 <vfprintf+0x232>
    15b6:	23 2d       	mov	r18, r3
    15b8:	2f 7e       	andi	r18, 0xEF	; 239
    15ba:	b2 2e       	mov	r11, r18
    15bc:	2a e0       	ldi	r18, 0x0A	; 10
    15be:	30 e0       	ldi	r19, 0x00	; 0
    15c0:	25 c0       	rjmp	.+74     	; 0x160c <vfprintf+0x27c>
    15c2:	93 2d       	mov	r25, r3
    15c4:	99 7f       	andi	r25, 0xF9	; 249
    15c6:	b9 2e       	mov	r11, r25
    15c8:	8f 36       	cpi	r24, 0x6F	; 111
    15ca:	c1 f0       	breq	.+48     	; 0x15fc <vfprintf+0x26c>
    15cc:	18 f4       	brcc	.+6      	; 0x15d4 <vfprintf+0x244>
    15ce:	88 35       	cpi	r24, 0x58	; 88
    15d0:	79 f0       	breq	.+30     	; 0x15f0 <vfprintf+0x260>
    15d2:	b5 c0       	rjmp	.+362    	; 0x173e <vfprintf+0x3ae>
    15d4:	80 37       	cpi	r24, 0x70	; 112
    15d6:	19 f0       	breq	.+6      	; 0x15de <vfprintf+0x24e>
    15d8:	88 37       	cpi	r24, 0x78	; 120
    15da:	21 f0       	breq	.+8      	; 0x15e4 <vfprintf+0x254>
    15dc:	b0 c0       	rjmp	.+352    	; 0x173e <vfprintf+0x3ae>
    15de:	e9 2f       	mov	r30, r25
    15e0:	e0 61       	ori	r30, 0x10	; 16
    15e2:	be 2e       	mov	r11, r30
    15e4:	b4 fe       	sbrs	r11, 4
    15e6:	0d c0       	rjmp	.+26     	; 0x1602 <vfprintf+0x272>
    15e8:	fb 2d       	mov	r31, r11
    15ea:	f4 60       	ori	r31, 0x04	; 4
    15ec:	bf 2e       	mov	r11, r31
    15ee:	09 c0       	rjmp	.+18     	; 0x1602 <vfprintf+0x272>
    15f0:	34 fe       	sbrs	r3, 4
    15f2:	0a c0       	rjmp	.+20     	; 0x1608 <vfprintf+0x278>
    15f4:	29 2f       	mov	r18, r25
    15f6:	26 60       	ori	r18, 0x06	; 6
    15f8:	b2 2e       	mov	r11, r18
    15fa:	06 c0       	rjmp	.+12     	; 0x1608 <vfprintf+0x278>
    15fc:	28 e0       	ldi	r18, 0x08	; 8
    15fe:	30 e0       	ldi	r19, 0x00	; 0
    1600:	05 c0       	rjmp	.+10     	; 0x160c <vfprintf+0x27c>
    1602:	20 e1       	ldi	r18, 0x10	; 16
    1604:	30 e0       	ldi	r19, 0x00	; 0
    1606:	02 c0       	rjmp	.+4      	; 0x160c <vfprintf+0x27c>
    1608:	20 e1       	ldi	r18, 0x10	; 16
    160a:	32 e0       	ldi	r19, 0x02	; 2
    160c:	f8 01       	movw	r30, r16
    160e:	b7 fe       	sbrs	r11, 7
    1610:	07 c0       	rjmp	.+14     	; 0x1620 <vfprintf+0x290>
    1612:	60 81       	ld	r22, Z
    1614:	71 81       	ldd	r23, Z+1	; 0x01
    1616:	82 81       	ldd	r24, Z+2	; 0x02
    1618:	93 81       	ldd	r25, Z+3	; 0x03
    161a:	0c 5f       	subi	r16, 0xFC	; 252
    161c:	1f 4f       	sbci	r17, 0xFF	; 255
    161e:	06 c0       	rjmp	.+12     	; 0x162c <vfprintf+0x29c>
    1620:	60 81       	ld	r22, Z
    1622:	71 81       	ldd	r23, Z+1	; 0x01
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	0e 5f       	subi	r16, 0xFE	; 254
    162a:	1f 4f       	sbci	r17, 0xFF	; 255
    162c:	a3 01       	movw	r20, r6
    162e:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <__ultoa_invert>
    1632:	88 2e       	mov	r8, r24
    1634:	86 18       	sub	r8, r6
    1636:	fb 2d       	mov	r31, r11
    1638:	ff 77       	andi	r31, 0x7F	; 127
    163a:	3f 2e       	mov	r3, r31
    163c:	36 fe       	sbrs	r3, 6
    163e:	0d c0       	rjmp	.+26     	; 0x165a <vfprintf+0x2ca>
    1640:	23 2d       	mov	r18, r3
    1642:	2e 7f       	andi	r18, 0xFE	; 254
    1644:	a2 2e       	mov	r10, r18
    1646:	89 14       	cp	r8, r9
    1648:	58 f4       	brcc	.+22     	; 0x1660 <vfprintf+0x2d0>
    164a:	34 fe       	sbrs	r3, 4
    164c:	0b c0       	rjmp	.+22     	; 0x1664 <vfprintf+0x2d4>
    164e:	32 fc       	sbrc	r3, 2
    1650:	09 c0       	rjmp	.+18     	; 0x1664 <vfprintf+0x2d4>
    1652:	83 2d       	mov	r24, r3
    1654:	8e 7e       	andi	r24, 0xEE	; 238
    1656:	a8 2e       	mov	r10, r24
    1658:	05 c0       	rjmp	.+10     	; 0x1664 <vfprintf+0x2d4>
    165a:	b8 2c       	mov	r11, r8
    165c:	a3 2c       	mov	r10, r3
    165e:	03 c0       	rjmp	.+6      	; 0x1666 <vfprintf+0x2d6>
    1660:	b8 2c       	mov	r11, r8
    1662:	01 c0       	rjmp	.+2      	; 0x1666 <vfprintf+0x2d6>
    1664:	b9 2c       	mov	r11, r9
    1666:	a4 fe       	sbrs	r10, 4
    1668:	0f c0       	rjmp	.+30     	; 0x1688 <vfprintf+0x2f8>
    166a:	fe 01       	movw	r30, r28
    166c:	e8 0d       	add	r30, r8
    166e:	f1 1d       	adc	r31, r1
    1670:	80 81       	ld	r24, Z
    1672:	80 33       	cpi	r24, 0x30	; 48
    1674:	21 f4       	brne	.+8      	; 0x167e <vfprintf+0x2ee>
    1676:	9a 2d       	mov	r25, r10
    1678:	99 7e       	andi	r25, 0xE9	; 233
    167a:	a9 2e       	mov	r10, r25
    167c:	09 c0       	rjmp	.+18     	; 0x1690 <vfprintf+0x300>
    167e:	a2 fe       	sbrs	r10, 2
    1680:	06 c0       	rjmp	.+12     	; 0x168e <vfprintf+0x2fe>
    1682:	b3 94       	inc	r11
    1684:	b3 94       	inc	r11
    1686:	04 c0       	rjmp	.+8      	; 0x1690 <vfprintf+0x300>
    1688:	8a 2d       	mov	r24, r10
    168a:	86 78       	andi	r24, 0x86	; 134
    168c:	09 f0       	breq	.+2      	; 0x1690 <vfprintf+0x300>
    168e:	b3 94       	inc	r11
    1690:	a3 fc       	sbrc	r10, 3
    1692:	11 c0       	rjmp	.+34     	; 0x16b6 <vfprintf+0x326>
    1694:	a0 fe       	sbrs	r10, 0
    1696:	06 c0       	rjmp	.+12     	; 0x16a4 <vfprintf+0x314>
    1698:	b2 14       	cp	r11, r2
    169a:	88 f4       	brcc	.+34     	; 0x16be <vfprintf+0x32e>
    169c:	28 0c       	add	r2, r8
    169e:	92 2c       	mov	r9, r2
    16a0:	9b 18       	sub	r9, r11
    16a2:	0e c0       	rjmp	.+28     	; 0x16c0 <vfprintf+0x330>
    16a4:	b2 14       	cp	r11, r2
    16a6:	60 f4       	brcc	.+24     	; 0x16c0 <vfprintf+0x330>
    16a8:	b6 01       	movw	r22, r12
    16aa:	80 e2       	ldi	r24, 0x20	; 32
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    16b2:	b3 94       	inc	r11
    16b4:	f7 cf       	rjmp	.-18     	; 0x16a4 <vfprintf+0x314>
    16b6:	b2 14       	cp	r11, r2
    16b8:	18 f4       	brcc	.+6      	; 0x16c0 <vfprintf+0x330>
    16ba:	2b 18       	sub	r2, r11
    16bc:	02 c0       	rjmp	.+4      	; 0x16c2 <vfprintf+0x332>
    16be:	98 2c       	mov	r9, r8
    16c0:	21 2c       	mov	r2, r1
    16c2:	a4 fe       	sbrs	r10, 4
    16c4:	10 c0       	rjmp	.+32     	; 0x16e6 <vfprintf+0x356>
    16c6:	b6 01       	movw	r22, r12
    16c8:	80 e3       	ldi	r24, 0x30	; 48
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    16d0:	a2 fe       	sbrs	r10, 2
    16d2:	17 c0       	rjmp	.+46     	; 0x1702 <vfprintf+0x372>
    16d4:	a1 fc       	sbrc	r10, 1
    16d6:	03 c0       	rjmp	.+6      	; 0x16de <vfprintf+0x34e>
    16d8:	88 e7       	ldi	r24, 0x78	; 120
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	02 c0       	rjmp	.+4      	; 0x16e2 <vfprintf+0x352>
    16de:	88 e5       	ldi	r24, 0x58	; 88
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    16e2:	b6 01       	movw	r22, r12
    16e4:	0c c0       	rjmp	.+24     	; 0x16fe <vfprintf+0x36e>
    16e6:	8a 2d       	mov	r24, r10
    16e8:	86 78       	andi	r24, 0x86	; 134
    16ea:	59 f0       	breq	.+22     	; 0x1702 <vfprintf+0x372>
    16ec:	a1 fe       	sbrs	r10, 1
    16ee:	02 c0       	rjmp	.+4      	; 0x16f4 <vfprintf+0x364>
    16f0:	8b e2       	ldi	r24, 0x2B	; 43
    16f2:	01 c0       	rjmp	.+2      	; 0x16f6 <vfprintf+0x366>
    16f4:	80 e2       	ldi	r24, 0x20	; 32
    16f6:	a7 fc       	sbrc	r10, 7
    16f8:	8d e2       	ldi	r24, 0x2D	; 45
    16fa:	b6 01       	movw	r22, r12
    16fc:	90 e0       	ldi	r25, 0x00	; 0
    16fe:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    1702:	89 14       	cp	r8, r9
    1704:	38 f4       	brcc	.+14     	; 0x1714 <vfprintf+0x384>
    1706:	b6 01       	movw	r22, r12
    1708:	80 e3       	ldi	r24, 0x30	; 48
    170a:	90 e0       	ldi	r25, 0x00	; 0
    170c:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    1710:	9a 94       	dec	r9
    1712:	f7 cf       	rjmp	.-18     	; 0x1702 <vfprintf+0x372>
    1714:	8a 94       	dec	r8
    1716:	f3 01       	movw	r30, r6
    1718:	e8 0d       	add	r30, r8
    171a:	f1 1d       	adc	r31, r1
    171c:	80 81       	ld	r24, Z
    171e:	b6 01       	movw	r22, r12
    1720:	90 e0       	ldi	r25, 0x00	; 0
    1722:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    1726:	81 10       	cpse	r8, r1
    1728:	f5 cf       	rjmp	.-22     	; 0x1714 <vfprintf+0x384>
    172a:	22 20       	and	r2, r2
    172c:	09 f4       	brne	.+2      	; 0x1730 <vfprintf+0x3a0>
    172e:	42 ce       	rjmp	.-892    	; 0x13b4 <vfprintf+0x24>
    1730:	b6 01       	movw	r22, r12
    1732:	80 e2       	ldi	r24, 0x20	; 32
    1734:	90 e0       	ldi	r25, 0x00	; 0
    1736:	0e 94 bf 0b 	call	0x177e	; 0x177e <fputc>
    173a:	2a 94       	dec	r2
    173c:	f6 cf       	rjmp	.-20     	; 0x172a <vfprintf+0x39a>
    173e:	f6 01       	movw	r30, r12
    1740:	86 81       	ldd	r24, Z+6	; 0x06
    1742:	97 81       	ldd	r25, Z+7	; 0x07
    1744:	02 c0       	rjmp	.+4      	; 0x174a <vfprintf+0x3ba>
    1746:	8f ef       	ldi	r24, 0xFF	; 255
    1748:	9f ef       	ldi	r25, 0xFF	; 255
    174a:	2b 96       	adiw	r28, 0x0b	; 11
    174c:	e2 e1       	ldi	r30, 0x12	; 18
    174e:	0c 94 75 0c 	jmp	0x18ea	; 0x18ea <__epilogue_restores__>

00001752 <strnlen_P>:
    1752:	fc 01       	movw	r30, r24
    1754:	05 90       	lpm	r0, Z+
    1756:	61 50       	subi	r22, 0x01	; 1
    1758:	70 40       	sbci	r23, 0x00	; 0
    175a:	01 10       	cpse	r0, r1
    175c:	d8 f7       	brcc	.-10     	; 0x1754 <strnlen_P+0x2>
    175e:	80 95       	com	r24
    1760:	90 95       	com	r25
    1762:	8e 0f       	add	r24, r30
    1764:	9f 1f       	adc	r25, r31
    1766:	08 95       	ret

00001768 <strnlen>:
    1768:	fc 01       	movw	r30, r24
    176a:	61 50       	subi	r22, 0x01	; 1
    176c:	70 40       	sbci	r23, 0x00	; 0
    176e:	01 90       	ld	r0, Z+
    1770:	01 10       	cpse	r0, r1
    1772:	d8 f7       	brcc	.-10     	; 0x176a <strnlen+0x2>
    1774:	80 95       	com	r24
    1776:	90 95       	com	r25
    1778:	8e 0f       	add	r24, r30
    177a:	9f 1f       	adc	r25, r31
    177c:	08 95       	ret

0000177e <fputc>:
    177e:	0f 93       	push	r16
    1780:	1f 93       	push	r17
    1782:	cf 93       	push	r28
    1784:	df 93       	push	r29
    1786:	fb 01       	movw	r30, r22
    1788:	23 81       	ldd	r18, Z+3	; 0x03
    178a:	21 fd       	sbrc	r18, 1
    178c:	03 c0       	rjmp	.+6      	; 0x1794 <fputc+0x16>
    178e:	8f ef       	ldi	r24, 0xFF	; 255
    1790:	9f ef       	ldi	r25, 0xFF	; 255
    1792:	2c c0       	rjmp	.+88     	; 0x17ec <fputc+0x6e>
    1794:	22 ff       	sbrs	r18, 2
    1796:	16 c0       	rjmp	.+44     	; 0x17c4 <fputc+0x46>
    1798:	46 81       	ldd	r20, Z+6	; 0x06
    179a:	57 81       	ldd	r21, Z+7	; 0x07
    179c:	24 81       	ldd	r18, Z+4	; 0x04
    179e:	35 81       	ldd	r19, Z+5	; 0x05
    17a0:	42 17       	cp	r20, r18
    17a2:	53 07       	cpc	r21, r19
    17a4:	44 f4       	brge	.+16     	; 0x17b6 <fputc+0x38>
    17a6:	a0 81       	ld	r26, Z
    17a8:	b1 81       	ldd	r27, Z+1	; 0x01
    17aa:	9d 01       	movw	r18, r26
    17ac:	2f 5f       	subi	r18, 0xFF	; 255
    17ae:	3f 4f       	sbci	r19, 0xFF	; 255
    17b0:	31 83       	std	Z+1, r19	; 0x01
    17b2:	20 83       	st	Z, r18
    17b4:	8c 93       	st	X, r24
    17b6:	26 81       	ldd	r18, Z+6	; 0x06
    17b8:	37 81       	ldd	r19, Z+7	; 0x07
    17ba:	2f 5f       	subi	r18, 0xFF	; 255
    17bc:	3f 4f       	sbci	r19, 0xFF	; 255
    17be:	37 83       	std	Z+7, r19	; 0x07
    17c0:	26 83       	std	Z+6, r18	; 0x06
    17c2:	14 c0       	rjmp	.+40     	; 0x17ec <fputc+0x6e>
    17c4:	8b 01       	movw	r16, r22
    17c6:	ec 01       	movw	r28, r24
    17c8:	fb 01       	movw	r30, r22
    17ca:	00 84       	ldd	r0, Z+8	; 0x08
    17cc:	f1 85       	ldd	r31, Z+9	; 0x09
    17ce:	e0 2d       	mov	r30, r0
    17d0:	09 95       	icall
    17d2:	89 2b       	or	r24, r25
    17d4:	e1 f6       	brne	.-72     	; 0x178e <fputc+0x10>
    17d6:	d8 01       	movw	r26, r16
    17d8:	16 96       	adiw	r26, 0x06	; 6
    17da:	8d 91       	ld	r24, X+
    17dc:	9c 91       	ld	r25, X
    17de:	17 97       	sbiw	r26, 0x07	; 7
    17e0:	01 96       	adiw	r24, 0x01	; 1
    17e2:	17 96       	adiw	r26, 0x07	; 7
    17e4:	9c 93       	st	X, r25
    17e6:	8e 93       	st	-X, r24
    17e8:	16 97       	sbiw	r26, 0x06	; 6
    17ea:	ce 01       	movw	r24, r28
    17ec:	df 91       	pop	r29
    17ee:	cf 91       	pop	r28
    17f0:	1f 91       	pop	r17
    17f2:	0f 91       	pop	r16
    17f4:	08 95       	ret

000017f6 <__ultoa_invert>:
    17f6:	fa 01       	movw	r30, r20
    17f8:	aa 27       	eor	r26, r26
    17fa:	28 30       	cpi	r18, 0x08	; 8
    17fc:	51 f1       	breq	.+84     	; 0x1852 <__ultoa_invert+0x5c>
    17fe:	20 31       	cpi	r18, 0x10	; 16
    1800:	81 f1       	breq	.+96     	; 0x1862 <__ultoa_invert+0x6c>
    1802:	e8 94       	clt
    1804:	6f 93       	push	r22
    1806:	6e 7f       	andi	r22, 0xFE	; 254
    1808:	6e 5f       	subi	r22, 0xFE	; 254
    180a:	7f 4f       	sbci	r23, 0xFF	; 255
    180c:	8f 4f       	sbci	r24, 0xFF	; 255
    180e:	9f 4f       	sbci	r25, 0xFF	; 255
    1810:	af 4f       	sbci	r26, 0xFF	; 255
    1812:	b1 e0       	ldi	r27, 0x01	; 1
    1814:	3e d0       	rcall	.+124    	; 0x1892 <__ultoa_invert+0x9c>
    1816:	b4 e0       	ldi	r27, 0x04	; 4
    1818:	3c d0       	rcall	.+120    	; 0x1892 <__ultoa_invert+0x9c>
    181a:	67 0f       	add	r22, r23
    181c:	78 1f       	adc	r23, r24
    181e:	89 1f       	adc	r24, r25
    1820:	9a 1f       	adc	r25, r26
    1822:	a1 1d       	adc	r26, r1
    1824:	68 0f       	add	r22, r24
    1826:	79 1f       	adc	r23, r25
    1828:	8a 1f       	adc	r24, r26
    182a:	91 1d       	adc	r25, r1
    182c:	a1 1d       	adc	r26, r1
    182e:	6a 0f       	add	r22, r26
    1830:	71 1d       	adc	r23, r1
    1832:	81 1d       	adc	r24, r1
    1834:	91 1d       	adc	r25, r1
    1836:	a1 1d       	adc	r26, r1
    1838:	20 d0       	rcall	.+64     	; 0x187a <__ultoa_invert+0x84>
    183a:	09 f4       	brne	.+2      	; 0x183e <__ultoa_invert+0x48>
    183c:	68 94       	set
    183e:	3f 91       	pop	r19
    1840:	2a e0       	ldi	r18, 0x0A	; 10
    1842:	26 9f       	mul	r18, r22
    1844:	11 24       	eor	r1, r1
    1846:	30 19       	sub	r19, r0
    1848:	30 5d       	subi	r19, 0xD0	; 208
    184a:	31 93       	st	Z+, r19
    184c:	de f6       	brtc	.-74     	; 0x1804 <__ultoa_invert+0xe>
    184e:	cf 01       	movw	r24, r30
    1850:	08 95       	ret
    1852:	46 2f       	mov	r20, r22
    1854:	47 70       	andi	r20, 0x07	; 7
    1856:	40 5d       	subi	r20, 0xD0	; 208
    1858:	41 93       	st	Z+, r20
    185a:	b3 e0       	ldi	r27, 0x03	; 3
    185c:	0f d0       	rcall	.+30     	; 0x187c <__ultoa_invert+0x86>
    185e:	c9 f7       	brne	.-14     	; 0x1852 <__ultoa_invert+0x5c>
    1860:	f6 cf       	rjmp	.-20     	; 0x184e <__ultoa_invert+0x58>
    1862:	46 2f       	mov	r20, r22
    1864:	4f 70       	andi	r20, 0x0F	; 15
    1866:	40 5d       	subi	r20, 0xD0	; 208
    1868:	4a 33       	cpi	r20, 0x3A	; 58
    186a:	18 f0       	brcs	.+6      	; 0x1872 <__ultoa_invert+0x7c>
    186c:	49 5d       	subi	r20, 0xD9	; 217
    186e:	31 fd       	sbrc	r19, 1
    1870:	40 52       	subi	r20, 0x20	; 32
    1872:	41 93       	st	Z+, r20
    1874:	02 d0       	rcall	.+4      	; 0x187a <__ultoa_invert+0x84>
    1876:	a9 f7       	brne	.-22     	; 0x1862 <__ultoa_invert+0x6c>
    1878:	ea cf       	rjmp	.-44     	; 0x184e <__ultoa_invert+0x58>
    187a:	b4 e0       	ldi	r27, 0x04	; 4
    187c:	a6 95       	lsr	r26
    187e:	97 95       	ror	r25
    1880:	87 95       	ror	r24
    1882:	77 95       	ror	r23
    1884:	67 95       	ror	r22
    1886:	ba 95       	dec	r27
    1888:	c9 f7       	brne	.-14     	; 0x187c <__ultoa_invert+0x86>
    188a:	00 97       	sbiw	r24, 0x00	; 0
    188c:	61 05       	cpc	r22, r1
    188e:	71 05       	cpc	r23, r1
    1890:	08 95       	ret
    1892:	9b 01       	movw	r18, r22
    1894:	ac 01       	movw	r20, r24
    1896:	0a 2e       	mov	r0, r26
    1898:	06 94       	lsr	r0
    189a:	57 95       	ror	r21
    189c:	47 95       	ror	r20
    189e:	37 95       	ror	r19
    18a0:	27 95       	ror	r18
    18a2:	ba 95       	dec	r27
    18a4:	c9 f7       	brne	.-14     	; 0x1898 <__ultoa_invert+0xa2>
    18a6:	62 0f       	add	r22, r18
    18a8:	73 1f       	adc	r23, r19
    18aa:	84 1f       	adc	r24, r20
    18ac:	95 1f       	adc	r25, r21
    18ae:	a0 1d       	adc	r26, r0
    18b0:	08 95       	ret

000018b2 <__prologue_saves__>:
    18b2:	2f 92       	push	r2
    18b4:	3f 92       	push	r3
    18b6:	4f 92       	push	r4
    18b8:	5f 92       	push	r5
    18ba:	6f 92       	push	r6
    18bc:	7f 92       	push	r7
    18be:	8f 92       	push	r8
    18c0:	9f 92       	push	r9
    18c2:	af 92       	push	r10
    18c4:	bf 92       	push	r11
    18c6:	cf 92       	push	r12
    18c8:	df 92       	push	r13
    18ca:	ef 92       	push	r14
    18cc:	ff 92       	push	r15
    18ce:	0f 93       	push	r16
    18d0:	1f 93       	push	r17
    18d2:	cf 93       	push	r28
    18d4:	df 93       	push	r29
    18d6:	cd b7       	in	r28, 0x3d	; 61
    18d8:	de b7       	in	r29, 0x3e	; 62
    18da:	ca 1b       	sub	r28, r26
    18dc:	db 0b       	sbc	r29, r27
    18de:	0f b6       	in	r0, 0x3f	; 63
    18e0:	f8 94       	cli
    18e2:	de bf       	out	0x3e, r29	; 62
    18e4:	0f be       	out	0x3f, r0	; 63
    18e6:	cd bf       	out	0x3d, r28	; 61
    18e8:	09 94       	ijmp

000018ea <__epilogue_restores__>:
    18ea:	2a 88       	ldd	r2, Y+18	; 0x12
    18ec:	39 88       	ldd	r3, Y+17	; 0x11
    18ee:	48 88       	ldd	r4, Y+16	; 0x10
    18f0:	5f 84       	ldd	r5, Y+15	; 0x0f
    18f2:	6e 84       	ldd	r6, Y+14	; 0x0e
    18f4:	7d 84       	ldd	r7, Y+13	; 0x0d
    18f6:	8c 84       	ldd	r8, Y+12	; 0x0c
    18f8:	9b 84       	ldd	r9, Y+11	; 0x0b
    18fa:	aa 84       	ldd	r10, Y+10	; 0x0a
    18fc:	b9 84       	ldd	r11, Y+9	; 0x09
    18fe:	c8 84       	ldd	r12, Y+8	; 0x08
    1900:	df 80       	ldd	r13, Y+7	; 0x07
    1902:	ee 80       	ldd	r14, Y+6	; 0x06
    1904:	fd 80       	ldd	r15, Y+5	; 0x05
    1906:	0c 81       	ldd	r16, Y+4	; 0x04
    1908:	1b 81       	ldd	r17, Y+3	; 0x03
    190a:	aa 81       	ldd	r26, Y+2	; 0x02
    190c:	b9 81       	ldd	r27, Y+1	; 0x01
    190e:	ce 0f       	add	r28, r30
    1910:	d1 1d       	adc	r29, r1
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	f8 94       	cli
    1916:	de bf       	out	0x3e, r29	; 62
    1918:	0f be       	out	0x3f, r0	; 63
    191a:	cd bf       	out	0x3d, r28	; 61
    191c:	ed 01       	movw	r28, r26
    191e:	08 95       	ret

00001920 <_exit>:
    1920:	f8 94       	cli

00001922 <__stop_program>:
    1922:	ff cf       	rjmp	.-2      	; 0x1922 <__stop_program>
