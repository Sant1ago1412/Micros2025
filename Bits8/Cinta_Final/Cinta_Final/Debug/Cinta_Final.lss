
Cinta_Final.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005a  00800100  000017a4  00001838  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000017a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002ba  0080015a  0080015a  00001892  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001892  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000018f0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000160  00000000  00000000  00001930  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001e76  00000000  00000000  00001a90  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c31  00000000  00000000  00003906  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f36  00000000  00000000  00004537  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000048c  00000000  00000000  00005470  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009f2  00000000  00000000  000058fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000dd2  00000000  00000000  000062ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000160  00000000  00000000  000070c0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
       4:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       8:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      28:	0c 94 47 01 	jmp	0x28e	; 0x28e <__vector_10>
      2c:	0c 94 f3 00 	jmp	0x1e6	; 0x1e6 <__vector_11>
      30:	0c 94 12 01 	jmp	0x224	; 0x224 <__vector_12>
      34:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      40:	0c 94 8e 01 	jmp	0x31c	; 0x31c <__vector_16>
      44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      48:	0c 94 b2 01 	jmp	0x364	; 0x364 <__vector_18>
      4c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      54:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      58:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      5c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      60:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      64:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      68:	52 03       	mulsu	r21, r18
      6a:	60 03       	mulsu	r22, r16
      6c:	78 03       	fmul	r23, r16
      6e:	8d 03       	fmulsu	r16, r21
      70:	a2 03       	fmuls	r18, r18
      72:	b0 03       	fmuls	r19, r16
      74:	d5 03       	fmuls	r21, r21

00000076 <__ctors_end>:
      76:	11 24       	eor	r1, r1
      78:	1f be       	out	0x3f, r1	; 63
      7a:	cf ef       	ldi	r28, 0xFF	; 255
      7c:	d8 e0       	ldi	r29, 0x08	; 8
      7e:	de bf       	out	0x3e, r29	; 62
      80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
      82:	11 e0       	ldi	r17, 0x01	; 1
      84:	a0 e0       	ldi	r26, 0x00	; 0
      86:	b1 e0       	ldi	r27, 0x01	; 1
      88:	e4 ea       	ldi	r30, 0xA4	; 164
      8a:	f7 e1       	ldi	r31, 0x17	; 23
      8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
      8e:	05 90       	lpm	r0, Z+
      90:	0d 92       	st	X+, r0
      92:	aa 35       	cpi	r26, 0x5A	; 90
      94:	b1 07       	cpc	r27, r17
      96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
      98:	24 e0       	ldi	r18, 0x04	; 4
      9a:	aa e5       	ldi	r26, 0x5A	; 90
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
      a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
      a2:	a4 31       	cpi	r26, 0x14	; 20
      a4:	b2 07       	cpc	r27, r18
      a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
      a8:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <main>
      ac:	0c 94 d0 0b 	jmp	0x17a0	; 0x17a0 <_exit>

000000b0 <__bad_interrupt>:
      b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <HCSR04_AddNew>:

//variable interna estatica
static _sHCSR04Handle *mySensor;		//puntero a la estructura _sHCSR04Handle. Se usa como variable auxiliar para manipular los datos de los sensores ultrasónicos HCSR04.

unsigned int HCSR04_AddNew(void (*WritePin_HCSR04)(uint8_t value), uint32_t ticks)
{
      b4:	cf 92       	push	r12
      b6:	df 92       	push	r13
      b8:	ef 92       	push	r14
      ba:	ff 92       	push	r15
      bc:	cf 93       	push	r28
      be:	df 93       	push	r29
      c0:	ec 01       	movw	r28, r24
      c2:	6a 01       	movw	r12, r20
      c4:	7b 01       	movw	r14, r22
	mySensor = (_sHCSR04Handle *)malloc(sizeof(_sHCSR04Handle));	//myHandleAux almacena un nuevo sensor dinámicamente, por lo que myHandleAux apunta a la nueva estructura creada.
      c6:	8f e0       	ldi	r24, 0x0F	; 15
      c8:	90 e0       	ldi	r25, 0x00	; 0
      ca:	0e 94 ca 07 	call	0xf94	; 0xf94 <malloc>
      ce:	fc 01       	movw	r30, r24
      d0:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
      d4:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>

	mySensor->WritePin = WritePin_HCSR04;
      d8:	d1 83       	std	Z+1, r29	; 0x01
      da:	c0 83       	st	Z, r28
	mySensor->ticks = ticks;
      dc:	c2 86       	std	Z+10, r12	; 0x0a
      de:	d3 86       	std	Z+11, r13	; 0x0b
      e0:	e4 86       	std	Z+12, r14	; 0x0c
      e2:	f5 86       	std	Z+13, r15	; 0x0d
	mySensor->flags.byte = 0;								
      e4:	16 86       	std	Z+14, r1	; 0x0e
	mySensor->lastDistanceUs = 0;
      e6:	11 86       	std	Z+9, r1	; 0x09
      e8:	10 86       	std	Z+8, r1	; 0x08
	mySensor->usTimeRise = 0;
      ea:	15 82       	std	Z+5, r1	; 0x05
      ec:	14 82       	std	Z+4, r1	; 0x04
	mySensor->usTimeFall = 0;
      ee:	17 82       	std	Z+7, r1	; 0x07
      f0:	16 82       	std	Z+6, r1	; 0x06
	mySensor->WritePin(0);		
      f2:	80 e0       	ldi	r24, 0x00	; 0
      f4:	fe 01       	movw	r30, r28
      f6:	09 95       	icall
	
	return (unsigned int)mySensor;
}
      f8:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <__data_end>
      fc:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <__data_end+0x1>
     100:	df 91       	pop	r29
     102:	cf 91       	pop	r28
     104:	ff 90       	pop	r15
     106:	ef 90       	pop	r14
     108:	df 90       	pop	r13
     10a:	cf 90       	pop	r12
     10c:	08 95       	ret

0000010e <HCSR04_Start>:
//}


void HCSR04_Start(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     10e:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
     112:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>
	
	mySensor->WritePin(1);					
     116:	dc 01       	movw	r26, r24
     118:	ed 91       	ld	r30, X+
     11a:	fc 91       	ld	r31, X
     11c:	81 e0       	ldi	r24, 0x01	; 1
     11e:	09 95       	icall
     120:	08 95       	ret

00000122 <HCSR04_TriggerReady>:
	
}

void HCSR04_TriggerReady(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     122:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
     126:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>
	
	mySensor->WritePin(0);
     12a:	dc 01       	movw	r26, r24
     12c:	ed 91       	ld	r30, X+
     12e:	fc 91       	ld	r31, X
     130:	80 e0       	ldi	r24, 0x00	; 0
     132:	09 95       	icall
     134:	08 95       	ret

00000136 <HCSR04_RiseEdgeTime>:
}

void HCSR04_RiseEdgeTime(unsigned int handleHCSR04, uint16_t usTimeRise)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     136:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
     13a:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>

	mySensor->usTimeRise = usTimeRise;	//Cargo cuando se pone en RISE
     13e:	fc 01       	movw	r30, r24
     140:	75 83       	std	Z+5, r23	; 0x05
     142:	64 83       	std	Z+4, r22	; 0x04
	mySensor->flags.byte = 0;
     144:	16 86       	std	Z+14, r1	; 0x0e
     146:	08 95       	ret

00000148 <HCSR04_FallEdgeTime>:

}

void HCSR04_FallEdgeTime(unsigned int handleHCSR04, uint16_t usTimeFall)
{
     148:	fc 01       	movw	r30, r24
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     14a:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
     14e:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>

	mySensor->usTimeFall = usTimeFall;	//Cargo cuando se pone en Fall 
     152:	77 83       	std	Z+7, r23	; 0x07
     154:	66 83       	std	Z+6, r22	; 0x06
	mySensor->flags.bit.EDGEREADY = 1;
     156:	86 85       	ldd	r24, Z+14	; 0x0e
     158:	81 60       	ori	r24, 0x01	; 1
     15a:	86 87       	std	Z+14, r24	; 0x0e
     15c:	08 95       	ret

0000015e <task_HCSR>:
	
}

void task_HCSR()
{
	if (mySensor != NULL)
     15e:	e0 91 5a 01 	lds	r30, 0x015A	; 0x80015a <__data_end>
     162:	f0 91 5b 01 	lds	r31, 0x015B	; 0x80015b <__data_end+0x1>
     166:	30 97       	sbiw	r30, 0x00	; 0
     168:	11 f1       	breq	.+68     	; 0x1ae <task_HCSR+0x50>
	{
		if (mySensor->flags.bit.EDGEREADY) //¿el sensor midió? Esto indica que ya se recibieron los dos flancos (rising y falling) y se puede calcular el tiempo que tardó el eco en volver = la distancia.
     16a:	86 85       	ldd	r24, Z+14	; 0x0e
     16c:	80 ff       	sbrs	r24, 0
     16e:	1f c0       	rjmp	.+62     	; 0x1ae <task_HCSR+0x50>
		{
			mySensor->flags.byte = 0;
     170:	16 86       	std	Z+14, r1	; 0x0e
			
			if(mySensor->usTimeRise < mySensor->usTimeFall){ //si no hubo overflow
     172:	24 81       	ldd	r18, Z+4	; 0x04
     174:	35 81       	ldd	r19, Z+5	; 0x05
     176:	86 81       	ldd	r24, Z+6	; 0x06
     178:	97 81       	ldd	r25, Z+7	; 0x07
     17a:	28 17       	cp	r18, r24
     17c:	39 07       	cpc	r19, r25
     17e:	28 f4       	brcc	.+10     	; 0x18a <task_HCSR+0x2c>
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise; //distancia medida
     180:	82 1b       	sub	r24, r18
     182:	93 0b       	sbc	r25, r19
     184:	91 87       	std	Z+9, r25	; 0x09
     186:	80 87       	std	Z+8, r24	; 0x08
     188:	05 c0       	rjmp	.+10     	; 0x194 <task_HCSR+0x36>
				}else{ //hubo overflow
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise + 0xFFFF; //para corregir
     18a:	82 1b       	sub	r24, r18
     18c:	93 0b       	sbc	r25, r19
     18e:	01 97       	sbiw	r24, 0x01	; 1
     190:	91 87       	std	Z+9, r25	; 0x09
     192:	80 87       	std	Z+8, r24	; 0x08
			}
			
			if(mySensor->lastDistanceUs > 11764) //2 metros
     194:	80 85       	ldd	r24, Z+8	; 0x08
     196:	91 85       	ldd	r25, Z+9	; 0x09
     198:	85 3f       	cpi	r24, 0xF5	; 245
     19a:	9d 42       	sbci	r25, 0x2D	; 45
     19c:	20 f0       	brcs	.+8      	; 0x1a6 <task_HCSR+0x48>
				mySensor->lastDistanceUs = 0xFFFF;
     19e:	8f ef       	ldi	r24, 0xFF	; 255
     1a0:	9f ef       	ldi	r25, 0xFF	; 255
     1a2:	91 87       	std	Z+9, r25	; 0x09
     1a4:	80 87       	std	Z+8, r24	; 0x08
			
			sensorMeasure(mySensor->lastDistanceUs);
     1a6:	80 85       	ldd	r24, Z+8	; 0x08
     1a8:	91 85       	ldd	r25, Z+9	; 0x09
     1aa:	0e 94 44 04 	call	0x888	; 0x888 <sensorMeasure>
     1ae:	08 95       	ret

000001b0 <WritePin_HCSR>:
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
	}
}

void WritePin_HCSR(uint8_t value){
	if (value)
     1b0:	88 23       	and	r24, r24
     1b2:	21 f0       	breq	.+8      	; 0x1bc <WritePin_HCSR+0xc>
	PORTB |= (1<<TRIGGER);				// Sets a HIGH state (1) in the TRIGGER pin
     1b4:	85 b1       	in	r24, 0x05	; 5
     1b6:	82 60       	ori	r24, 0x02	; 2
     1b8:	85 b9       	out	0x05, r24	; 5
     1ba:	08 95       	ret
	else
	PORTB &= ~(1<<TRIGGER);				// Sets a LOW state (0) in the TRIGGER pin
     1bc:	85 b1       	in	r24, 0x05	; 5
     1be:	8d 7f       	andi	r24, 0xFD	; 253
     1c0:	85 b9       	out	0x05, r24	; 5
     1c2:	08 95       	ret

000001c4 <USART_putchar>:
#include "HCSR04.h"
#include "util.h"

#include <stdio.h>

int USART_putchar(char c, FILE *stream) {
     1c4:	cf 93       	push	r28
     1c6:	c8 2f       	mov	r28, r24
	if (c == '\n') USART_putchar('\r', stream);  // salto de línea para terminal
     1c8:	8a 30       	cpi	r24, 0x0A	; 10
     1ca:	19 f4       	brne	.+6      	; 0x1d2 <USART_putchar+0xe>
     1cc:	8d e0       	ldi	r24, 0x0D	; 13
     1ce:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <USART_putchar>
	while (!(UCSR0A & (1 << UDRE0)));  // Espera a que el buffer esté vacío
     1d2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     1d6:	85 ff       	sbrs	r24, 5
     1d8:	fc cf       	rjmp	.-8      	; 0x1d2 <USART_putchar+0xe>
	UDR0 = c;
     1da:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	return 0;
}
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <__vector_11>:

/* END Constant in Flash -----------------------------------------------------*/


/* Function ISR --------------------------------------------------------------*/
ISR(TIMER1_COMPA_vect){
     1e6:	1f 92       	push	r1
     1e8:	0f 92       	push	r0
     1ea:	0f b6       	in	r0, 0x3f	; 63
     1ec:	0f 92       	push	r0
     1ee:	11 24       	eor	r1, r1
     1f0:	8f 93       	push	r24
     1f2:	9f 93       	push	r25
     1f4:	ef 93       	push	r30
     1f6:	ff 93       	push	r31
	
	/*		Con el OCR1B en 20000 , cuento cada 10ms		*/
	IS10MS=TRUE;
     1f8:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     1fc:	81 60       	ori	r24, 0x01	; 1
     1fe:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
	OCR1A += 19999;
     202:	e8 e8       	ldi	r30, 0x88	; 136
     204:	f0 e0       	ldi	r31, 0x00	; 0
     206:	80 81       	ld	r24, Z
     208:	91 81       	ldd	r25, Z+1	; 0x01
     20a:	81 5e       	subi	r24, 0xE1	; 225
     20c:	91 4b       	sbci	r25, 0xB1	; 177
     20e:	91 83       	std	Z+1, r25	; 0x01
     210:	80 83       	st	Z, r24
	
}
     212:	ff 91       	pop	r31
     214:	ef 91       	pop	r30
     216:	9f 91       	pop	r25
     218:	8f 91       	pop	r24
     21a:	0f 90       	pop	r0
     21c:	0f be       	out	0x3f, r0	; 63
     21e:	0f 90       	pop	r0
     220:	1f 90       	pop	r1
     222:	18 95       	reti

00000224 <__vector_12>:

ISR(TIMER1_COMPB_vect){
     224:	1f 92       	push	r1
     226:	0f 92       	push	r0
     228:	0f b6       	in	r0, 0x3f	; 63
     22a:	0f 92       	push	r0
     22c:	11 24       	eor	r1, r1
     22e:	2f 93       	push	r18
     230:	3f 93       	push	r19
     232:	4f 93       	push	r20
     234:	5f 93       	push	r21
     236:	6f 93       	push	r22
     238:	7f 93       	push	r23
     23a:	8f 93       	push	r24
     23c:	9f 93       	push	r25
     23e:	af 93       	push	r26
     240:	bf 93       	push	r27
     242:	ef 93       	push	r30
     244:	ff 93       	push	r31
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
}

static inline void on_timer1_compb_hcsr(){
	HCSR04_TriggerReady(HCSR_1);					//Pongo en LOW el Trigger
     246:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <HCSR_1>
     24a:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <HCSR_1+0x1>
     24e:	0e 94 91 00 	call	0x122	; 0x122 <HCSR04_TriggerReady>
	TIFR1 |= (1<<ICF1);								// Timer/Counter1 Output Compare A Match Flag enabled
     252:	86 b3       	in	r24, 0x16	; 22
     254:	80 62       	ori	r24, 0x20	; 32
     256:	86 bb       	out	0x16, r24	; 22
	TCCR1B = (1 << ICNC1) | (1 << ICES1);			// Input Capture Noise Canceler and Input Capture Edge Select activated
     258:	e1 e8       	ldi	r30, 0x81	; 129
     25a:	f0 e0       	ldi	r31, 0x00	; 0
     25c:	80 ec       	ldi	r24, 0xC0	; 192
     25e:	80 83       	st	Z, r24
	TCCR1B |= (1 << CS11);							// Prescaler definition (x8): CS12 = 0 and CS10 = 0
     260:	80 81       	ld	r24, Z
     262:	82 60       	ori	r24, 0x02	; 2
     264:	80 83       	st	Z, r24
	TIMSK1 = (1<<ICIE1) | (1<<OCIE1A);				// Input Capture Interrupt and Output Compare A Match Interrupt enabled <---
     266:	82 e2       	ldi	r24, 0x22	; 34
     268:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	
	on_timer1_compb_hcsr();
	
}
     26c:	ff 91       	pop	r31
     26e:	ef 91       	pop	r30
     270:	bf 91       	pop	r27
     272:	af 91       	pop	r26
     274:	9f 91       	pop	r25
     276:	8f 91       	pop	r24
     278:	7f 91       	pop	r23
     27a:	6f 91       	pop	r22
     27c:	5f 91       	pop	r21
     27e:	4f 91       	pop	r20
     280:	3f 91       	pop	r19
     282:	2f 91       	pop	r18
     284:	0f 90       	pop	r0
     286:	0f be       	out	0x3f, r0	; 63
     288:	0f 90       	pop	r0
     28a:	1f 90       	pop	r1
     28c:	18 95       	reti

0000028e <__vector_10>:

ISR(TIMER1_CAPT_vect){
     28e:	1f 92       	push	r1
     290:	0f 92       	push	r0
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	0f 92       	push	r0
     296:	11 24       	eor	r1, r1
     298:	2f 93       	push	r18
     29a:	3f 93       	push	r19
     29c:	4f 93       	push	r20
     29e:	5f 93       	push	r21
     2a0:	6f 93       	push	r22
     2a2:	7f 93       	push	r23
     2a4:	8f 93       	push	r24
     2a6:	9f 93       	push	r25
     2a8:	af 93       	push	r26
     2aa:	bf 93       	push	r27
     2ac:	ef 93       	push	r30
     2ae:	ff 93       	push	r31
}

static inline void on_timer1_capt_hcsr(){
	if (TCCR1B & (1<<ICES1)){						// Si ICES1 = 1  el Timer va a capturar en el flanco de subida (rising edge).
     2b0:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
     2b4:	86 ff       	sbrs	r24, 6
     2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <__vector_10+0x4a>
		
		TCCR1B = (1 << ICNC1) | (1 << CS11);		//preparo para capturar el flanco de bajada
     2b8:	82 e8       	ldi	r24, 0x82	; 130
     2ba:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
		HCSR04_RiseEdgeTime(HCSR_1, ICR1 >> 1);		//[[ ICR1 >> 1  ==  ICR1 / 2 ]] -> En ICR1 almacena el valor de TCNT1, Es decir, guardo el momento en que llego el RISE. Como ICR1 obtiene un tick cada 500ns, si contó 3000 ticks, se hace la cuenta 3000 * 0,5us = 1500us. (500ns = 0,5us = 1/2).
     2be:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2c2:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2c6:	76 95       	lsr	r23
     2c8:	67 95       	ror	r22
     2ca:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <HCSR_1>
     2ce:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <HCSR_1+0x1>
     2d2:	0e 94 9b 00 	call	0x136	; 0x136 <HCSR04_RiseEdgeTime>
     2d6:	11 c0       	rjmp	.+34     	; 0x2fa <__vector_10+0x6c>
		}else{										// Falling edge is used as trigger

		TIMSK1 &= ~_BV(ICIE1);						//desactivo la interrupcion por input capture
     2d8:	ef e6       	ldi	r30, 0x6F	; 111
     2da:	f0 e0       	ldi	r31, 0x00	; 0
     2dc:	80 81       	ld	r24, Z
     2de:	8f 7d       	andi	r24, 0xDF	; 223
     2e0:	80 83       	st	Z, r24
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
     2e2:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2e6:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2ea:	76 95       	lsr	r23
     2ec:	67 95       	ror	r22
     2ee:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <HCSR_1>
     2f2:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <HCSR_1+0x1>
     2f6:	0e 94 a4 00 	call	0x148	; 0x148 <HCSR04_FallEdgeTime>
	
	on_timer1_capt_hcsr();
	
}
     2fa:	ff 91       	pop	r31
     2fc:	ef 91       	pop	r30
     2fe:	bf 91       	pop	r27
     300:	af 91       	pop	r26
     302:	9f 91       	pop	r25
     304:	8f 91       	pop	r24
     306:	7f 91       	pop	r23
     308:	6f 91       	pop	r22
     30a:	5f 91       	pop	r21
     30c:	4f 91       	pop	r20
     30e:	3f 91       	pop	r19
     310:	2f 91       	pop	r18
     312:	0f 90       	pop	r0
     314:	0f be       	out	0x3f, r0	; 63
     316:	0f 90       	pop	r0
     318:	1f 90       	pop	r1
     31a:	18 95       	reti

0000031c <__vector_16>:

ISR(TIMER0_OVF_vect){
     31c:	1f 92       	push	r1
     31e:	0f 92       	push	r0
     320:	0f b6       	in	r0, 0x3f	; 63
     322:	0f 92       	push	r0
     324:	11 24       	eor	r1, r1
     326:	2f 93       	push	r18
     328:	3f 93       	push	r19
     32a:	4f 93       	push	r20
     32c:	5f 93       	push	r21
     32e:	6f 93       	push	r22
     330:	7f 93       	push	r23
     332:	8f 93       	push	r24
     334:	9f 93       	push	r25
     336:	af 93       	push	r26
     338:	bf 93       	push	r27
     33a:	ef 93       	push	r30
     33c:	ff 93       	push	r31
	
	writeServo();
     33e:	0e 94 58 07 	call	0xeb0	; 0xeb0 <writeServo>
	
}
     342:	ff 91       	pop	r31
     344:	ef 91       	pop	r30
     346:	bf 91       	pop	r27
     348:	af 91       	pop	r26
     34a:	9f 91       	pop	r25
     34c:	8f 91       	pop	r24
     34e:	7f 91       	pop	r23
     350:	6f 91       	pop	r22
     352:	5f 91       	pop	r21
     354:	4f 91       	pop	r20
     356:	3f 91       	pop	r19
     358:	2f 91       	pop	r18
     35a:	0f 90       	pop	r0
     35c:	0f be       	out	0x3f, r0	; 63
     35e:	0f 90       	pop	r0
     360:	1f 90       	pop	r1
     362:	18 95       	reti

00000364 <__vector_18>:

ISR(USART_RX_vect){
     364:	1f 92       	push	r1
     366:	0f 92       	push	r0
     368:	0f b6       	in	r0, 0x3f	; 63
     36a:	0f 92       	push	r0
     36c:	11 24       	eor	r1, r1
     36e:	8f 93       	push	r24
     370:	9f 93       	push	r25
     372:	af 93       	push	r26
     374:	bf 93       	push	r27
     376:	ef 93       	push	r30
     378:	ff 93       	push	r31
	dataRx.buff[dataRx.indexW++] = UDR0;
     37a:	e5 e8       	ldi	r30, 0x85	; 133
     37c:	f2 e0       	ldi	r31, 0x02	; 2
     37e:	a0 81       	ld	r26, Z
     380:	b1 81       	ldd	r27, Z+1	; 0x01
     382:	83 81       	ldd	r24, Z+3	; 0x03
     384:	91 e0       	ldi	r25, 0x01	; 1
     386:	98 0f       	add	r25, r24
     388:	93 83       	std	Z+3, r25	; 0x03
     38a:	a8 0f       	add	r26, r24
     38c:	b1 1d       	adc	r27, r1
     38e:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     392:	8c 93       	st	X, r24
	dataRx.indexW &= dataRx.mask;
     394:	85 81       	ldd	r24, Z+5	; 0x05
     396:	93 81       	ldd	r25, Z+3	; 0x03
     398:	89 23       	and	r24, r25
     39a:	83 83       	std	Z+3, r24	; 0x03
}
     39c:	ff 91       	pop	r31
     39e:	ef 91       	pop	r30
     3a0:	bf 91       	pop	r27
     3a2:	af 91       	pop	r26
     3a4:	9f 91       	pop	r25
     3a6:	8f 91       	pop	r24
     3a8:	0f 90       	pop	r0
     3aa:	0f be       	out	0x3f, r0	; 63
     3ac:	0f 90       	pop	r0
     3ae:	1f 90       	pop	r1
     3b0:	18 95       	reti

000003b2 <ini_ports>:
void ini_ports(){
	
	/************************************************************************/
	/*								OUTPUTS                                 */
	/************************************************************************/
	DDRB = ((1 << LED_BI)| (1 << SV1) | (1 << SV2) | (1<<TRIGGER));
     3b2:	8a e3       	ldi	r24, 0x3A	; 58
     3b4:	84 b9       	out	0x04, r24	; 4
	DDRD = (1 << SV0);
     3b6:	80 e8       	ldi	r24, 0x80	; 128
     3b8:	8a b9       	out	0x0a, r24	; 10
	
	/************************************************************************/
	/*								INPUTS                                  */
	/************************************************************************/
	DDRB &= ~(1<<ECHO);
     3ba:	84 b1       	in	r24, 0x04	; 4
     3bc:	8e 7f       	andi	r24, 0xFE	; 254
     3be:	84 b9       	out	0x04, r24	; 4
	DDRD &= ~((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3c0:	8a b1       	in	r24, 0x0a	; 10
     3c2:	83 7c       	andi	r24, 0xC3	; 195
     3c4:	8a b9       	out	0x0a, r24	; 10
	
	/*						Activo Pull ups internos						*/
	PORTB = (1<<ECHO);
     3c6:	81 e0       	ldi	r24, 0x01	; 1
     3c8:	85 b9       	out	0x05, r24	; 5
	PORTD = ((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3ca:	8c e3       	ldi	r24, 0x3C	; 60
     3cc:	8b b9       	out	0x0b, r24	; 11
     3ce:	08 95       	ret

000003d0 <ini_timer1>:
/************************************************************************/
/*		Timer 1 es funcional al HCSR y a la accion cada 10ms            */
/************************************************************************/
void ini_timer1(){
	
	TCCR1A = 0x00;
     3d0:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
	/* Configuro noise canceler del input capture, el flanco del input capture y prescaler en 8 (f = 16MHz / 8 = 2MHz ? 1 tick = 0.5 µs) */
	TCCR1B = 0xC2;
     3d4:	82 ec       	ldi	r24, 0xC2	; 194
     3d6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
	TCNT1 = 0x00;
     3da:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     3de:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
	/*	Activo la interrupcion por comparador b	*/
	TIMSK1 = (1<<OCIE1A);
     3e2:	82 e0       	ldi	r24, 0x02	; 2
     3e4:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	/* Le doy un valor al comparador B	*/
	OCR1A = 19999;
     3e8:	8f e1       	ldi	r24, 0x1F	; 31
     3ea:	9e e4       	ldi	r25, 0x4E	; 78
     3ec:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     3f0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
	TIFR1 = TIFR1;
     3f4:	86 b3       	in	r24, 0x16	; 22
     3f6:	86 bb       	out	0x16, r24	; 22
     3f8:	08 95       	ret

000003fa <ini_timer0>:
/************************************************************************/
/*			Timer 0 funcional a generar el pwm de los servos			*/
/************************************************************************/
void ini_timer0(){
	
	TCCR0A = 0;
     3fa:	14 bc       	out	0x24, r1	; 36
	TCNT0 = 0;
     3fc:	16 bc       	out	0x26, r1	; 38
	/*	Pongo las banderas en 0 con TIFR	*/
	TIFR0 = 0x07;
     3fe:	87 e0       	ldi	r24, 0x07	; 7
     400:	85 bb       	out	0x15, r24	; 21
	/*	Habilito la interrupcion por TOV	*/
	TIMSK0 = (1<<TOIE0);
     402:	81 e0       	ldi	r24, 0x01	; 1
     404:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
	/*	Prescaler en 8 , obtengo el cuentas de 500ns, tov a 500*256 = 128us		*/
	TCCR0B = (1<<CS01);
     408:	82 e0       	ldi	r24, 0x02	; 2
     40a:	85 bd       	out	0x25, r24	; 37
     40c:	08 95       	ret

0000040e <ini_USART>:
	
}

void ini_USART(uint8_t ubrr){
	UBRR0H = 0;
     40e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = ubrr;
     412:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	UCSR0A = 0xFE; //inicializo todas las banderas excepto el multiprocesor
     416:	8e ef       	ldi	r24, 0xFE	; 254
     418:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	UCSR0B =   0x98; // (1<<RXCIE0) | (1<<RXEN0)|(1<<TXEN0); //Activo las banderas de interrupcion de recepcion y la habilitacion del rx y tx
     41c:	88 e9       	ldi	r24, 0x98	; 152
     41e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
     422:	86 e0       	ldi	r24, 0x06	; 6
     424:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     428:	08 95       	ret

0000042a <IR_Init>:
	
}

void IR_Init(IRDebounce *ir) {
     42a:	ac 01       	movw	r20, r24
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     42c:	20 e0       	ldi	r18, 0x00	; 0
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	0d c0       	rjmp	.+26     	; 0x44c <IR_Init+0x22>
		ir[globalIndex].state = IR_DOWN;
     432:	f9 01       	movw	r30, r18
     434:	ee 0f       	add	r30, r30
     436:	ff 1f       	adc	r31, r31
     438:	ee 0f       	add	r30, r30
     43a:	ff 1f       	adc	r31, r31
     43c:	e4 0f       	add	r30, r20
     43e:	f5 1f       	adc	r31, r21
     440:	93 e0       	ldi	r25, 0x03	; 3
     442:	90 83       	st	Z, r25
		ir[globalIndex].last_sample = 0;
     444:	12 82       	std	Z+2, r1	; 0x02
		ir[globalIndex].stateConfirmed = 0;
     446:	11 82       	std	Z+1, r1	; 0x01
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
	
}

void IR_Init(IRDebounce *ir) {
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     448:	2f 5f       	subi	r18, 0xFF	; 255
     44a:	3f 4f       	sbci	r19, 0xFF	; 255
     44c:	24 30       	cpi	r18, 0x04	; 4
     44e:	31 05       	cpc	r19, r1
     450:	84 f3       	brlt	.-32     	; 0x432 <IR_Init+0x8>
		ir[globalIndex].state = IR_DOWN;
		ir[globalIndex].last_sample = 0;
		ir[globalIndex].stateConfirmed = 0;
	}
}
     452:	08 95       	ret

00000454 <IR_Update>:

void IR_Update(IRDebounce *ir, uint8_t sample) {
     454:	fc 01       	movw	r30, r24
	switch (ir->state) {
     456:	80 81       	ld	r24, Z
     458:	81 30       	cpi	r24, 0x01	; 1
     45a:	89 f0       	breq	.+34     	; 0x47e <IR_Update+0x2a>
     45c:	28 f0       	brcs	.+10     	; 0x468 <IR_Update+0x14>
     45e:	82 30       	cpi	r24, 0x02	; 2
     460:	b1 f0       	breq	.+44     	; 0x48e <IR_Update+0x3a>
     462:	83 30       	cpi	r24, 0x03	; 3
     464:	01 f1       	breq	.+64     	; 0x4a6 <IR_Update+0x52>
     466:	26 c0       	rjmp	.+76     	; 0x4b4 <IR_Update+0x60>
		case IR_RISING:
		if (sample == 1 && ir->last_sample == 1){
     468:	61 30       	cpi	r22, 0x01	; 1
     46a:	31 f4       	brne	.+12     	; 0x478 <IR_Update+0x24>
     46c:	82 81       	ldd	r24, Z+2	; 0x02
     46e:	81 30       	cpi	r24, 0x01	; 1
     470:	19 f4       	brne	.+6      	; 0x478 <IR_Update+0x24>
			ir->state = IR_UP;
     472:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x01;
     474:	81 83       	std	Z+1, r24	; 0x01
     476:	20 c0       	rjmp	.+64     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     478:	83 e0       	ldi	r24, 0x03	; 3
     47a:	80 83       	st	Z, r24
     47c:	1d c0       	rjmp	.+58     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_UP:
		if (sample == 0){
     47e:	61 11       	cpse	r22, r1
     480:	03 c0       	rjmp	.+6      	; 0x488 <IR_Update+0x34>
			ir->state = IR_FALLING;
     482:	82 e0       	ldi	r24, 0x02	; 2
     484:	80 83       	st	Z, r24
     486:	18 c0       	rjmp	.+48     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	80 83       	st	Z, r24
     48c:	15 c0       	rjmp	.+42     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_FALLING:
		if (sample == 0 && ir->last_sample == 0){
     48e:	61 11       	cpse	r22, r1
     490:	07 c0       	rjmp	.+14     	; 0x4a0 <IR_Update+0x4c>
     492:	82 81       	ldd	r24, Z+2	; 0x02
     494:	81 11       	cpse	r24, r1
     496:	04 c0       	rjmp	.+8      	; 0x4a0 <IR_Update+0x4c>
			ir->state = IR_DOWN;
     498:	83 e0       	ldi	r24, 0x03	; 3
     49a:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x00;
     49c:	11 82       	std	Z+1, r1	; 0x01
     49e:	0c c0       	rjmp	.+24     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     4a0:	81 e0       	ldi	r24, 0x01	; 1
     4a2:	80 83       	st	Z, r24
     4a4:	09 c0       	rjmp	.+18     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_DOWN:
		if (sample == 1){
     4a6:	61 30       	cpi	r22, 0x01	; 1
     4a8:	11 f4       	brne	.+4      	; 0x4ae <IR_Update+0x5a>
			ir->state = IR_RISING;
     4aa:	10 82       	st	Z, r1
     4ac:	05 c0       	rjmp	.+10     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     4ae:	83 e0       	ldi	r24, 0x03	; 3
     4b0:	80 83       	st	Z, r24
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <IR_Update+0x64>
		}
		break;
		default:
		ir->state = IR_UP;
     4b4:	81 e0       	ldi	r24, 0x01	; 1
     4b6:	80 83       	st	Z, r24
		break;
	}

	ir->last_sample = sample;
     4b8:	62 83       	std	Z+2, r22	; 0x02
     4ba:	08 95       	ret

000004bc <IR_GetState>:
}

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}
     4bc:	fc 01       	movw	r30, r24
     4be:	81 81       	ldd	r24, Z+1	; 0x01
     4c0:	08 95       	ret

000004c2 <putHeaderOnTx>:
			dataTx->indexR &= dataTx->mask;
		}
	}
}

uint8_t putHeaderOnTx(_sTx  *dataTx, _eCmd ID, uint8_t frameLength){
     4c2:	fc 01       	movw	r30, r24
	dataTx->chk = 0;
     4c4:	15 82       	std	Z+5, r1	; 0x05
	dataTx->buff[dataTx->indexW++]='U';
     4c6:	a0 81       	ld	r26, Z
     4c8:	b1 81       	ldd	r27, Z+1	; 0x01
     4ca:	83 81       	ldd	r24, Z+3	; 0x03
     4cc:	91 e0       	ldi	r25, 0x01	; 1
     4ce:	98 0f       	add	r25, r24
     4d0:	93 83       	std	Z+3, r25	; 0x03
     4d2:	a8 0f       	add	r26, r24
     4d4:	b1 1d       	adc	r27, r1
     4d6:	85 e5       	ldi	r24, 0x55	; 85
     4d8:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4da:	84 81       	ldd	r24, Z+4	; 0x04
     4dc:	93 81       	ldd	r25, Z+3	; 0x03
     4de:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='N';
     4e0:	a0 81       	ld	r26, Z
     4e2:	b1 81       	ldd	r27, Z+1	; 0x01
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	89 0f       	add	r24, r25
     4e8:	83 83       	std	Z+3, r24	; 0x03
     4ea:	a9 0f       	add	r26, r25
     4ec:	b1 1d       	adc	r27, r1
     4ee:	8e e4       	ldi	r24, 0x4E	; 78
     4f0:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4f2:	84 81       	ldd	r24, Z+4	; 0x04
     4f4:	93 81       	ldd	r25, Z+3	; 0x03
     4f6:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='E';
     4f8:	a0 81       	ld	r26, Z
     4fa:	b1 81       	ldd	r27, Z+1	; 0x01
     4fc:	81 e0       	ldi	r24, 0x01	; 1
     4fe:	89 0f       	add	r24, r25
     500:	83 83       	std	Z+3, r24	; 0x03
     502:	a9 0f       	add	r26, r25
     504:	b1 1d       	adc	r27, r1
     506:	85 e4       	ldi	r24, 0x45	; 69
     508:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     50a:	84 81       	ldd	r24, Z+4	; 0x04
     50c:	93 81       	ldd	r25, Z+3	; 0x03
     50e:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='R';
     510:	a0 81       	ld	r26, Z
     512:	b1 81       	ldd	r27, Z+1	; 0x01
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	89 0f       	add	r24, r25
     518:	83 83       	std	Z+3, r24	; 0x03
     51a:	a9 0f       	add	r26, r25
     51c:	b1 1d       	adc	r27, r1
     51e:	82 e5       	ldi	r24, 0x52	; 82
     520:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     522:	84 81       	ldd	r24, Z+4	; 0x04
     524:	93 81       	ldd	r25, Z+3	; 0x03
     526:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=frameLength+1;
     528:	a0 81       	ld	r26, Z
     52a:	b1 81       	ldd	r27, Z+1	; 0x01
     52c:	81 e0       	ldi	r24, 0x01	; 1
     52e:	89 0f       	add	r24, r25
     530:	83 83       	std	Z+3, r24	; 0x03
     532:	a9 0f       	add	r26, r25
     534:	b1 1d       	adc	r27, r1
     536:	4f 5f       	subi	r20, 0xFF	; 255
     538:	4c 93       	st	X, r20
	dataTx->indexW &= dataTx->mask;
     53a:	84 81       	ldd	r24, Z+4	; 0x04
     53c:	93 81       	ldd	r25, Z+3	; 0x03
     53e:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=':';
     540:	a0 81       	ld	r26, Z
     542:	b1 81       	ldd	r27, Z+1	; 0x01
     544:	81 e0       	ldi	r24, 0x01	; 1
     546:	89 0f       	add	r24, r25
     548:	83 83       	std	Z+3, r24	; 0x03
     54a:	a9 0f       	add	r26, r25
     54c:	b1 1d       	adc	r27, r1
     54e:	8a e3       	ldi	r24, 0x3A	; 58
     550:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     552:	84 81       	ldd	r24, Z+4	; 0x04
     554:	93 81       	ldd	r25, Z+3	; 0x03
     556:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=ID;
     558:	a0 81       	ld	r26, Z
     55a:	b1 81       	ldd	r27, Z+1	; 0x01
     55c:	81 e0       	ldi	r24, 0x01	; 1
     55e:	89 0f       	add	r24, r25
     560:	83 83       	std	Z+3, r24	; 0x03
     562:	a9 0f       	add	r26, r25
     564:	b1 1d       	adc	r27, r1
     566:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     568:	94 81       	ldd	r25, Z+4	; 0x04
     56a:	83 81       	ldd	r24, Z+3	; 0x03
     56c:	98 23       	and	r25, r24
     56e:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= (frameLength+1);
     570:	95 81       	ldd	r25, Z+5	; 0x05
     572:	49 27       	eor	r20, r25
	dataTx->chk ^= ('U' ^'N' ^'E' ^'R' ^ID ^':') ;
     574:	64 27       	eor	r22, r20
     576:	86 e3       	ldi	r24, 0x36	; 54
     578:	86 27       	eor	r24, r22
     57a:	85 83       	std	Z+5, r24	; 0x05
	return  dataTx->chk;
}
     57c:	08 95       	ret

0000057e <putByteOnTx>:
uint8_t putByteOnTx(_sTx *dataTx, uint8_t byte)
{
     57e:	fc 01       	movw	r30, r24
	dataTx->buff[dataTx->indexW++]=byte;
     580:	a0 81       	ld	r26, Z
     582:	b1 81       	ldd	r27, Z+1	; 0x01
     584:	83 81       	ldd	r24, Z+3	; 0x03
     586:	91 e0       	ldi	r25, 0x01	; 1
     588:	98 0f       	add	r25, r24
     58a:	93 83       	std	Z+3, r25	; 0x03
     58c:	a8 0f       	add	r26, r24
     58e:	b1 1d       	adc	r27, r1
     590:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     592:	94 81       	ldd	r25, Z+4	; 0x04
     594:	83 81       	ldd	r24, Z+3	; 0x03
     596:	98 23       	and	r25, r24
     598:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= byte;
     59a:	85 81       	ldd	r24, Z+5	; 0x05
     59c:	86 27       	eor	r24, r22
     59e:	85 83       	std	Z+5, r24	; 0x05
	return dataTx->chk;
}
     5a0:	08 95       	ret

000005a2 <decodeCommand>:
void decodeCommand(_sRx *dataRx, _sTx *dataTx){
     5a2:	0f 93       	push	r16
     5a4:	1f 93       	push	r17
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	eb 01       	movw	r28, r22
	switch(dataRx->buff[dataRx->indexData]){
     5ac:	dc 01       	movw	r26, r24
     5ae:	ed 91       	ld	r30, X+
     5b0:	fc 91       	ld	r31, X
     5b2:	11 97       	sbiw	r26, 0x01	; 1
     5b4:	14 96       	adiw	r26, 0x04	; 4
     5b6:	8c 91       	ld	r24, X
     5b8:	e8 0f       	add	r30, r24
     5ba:	f1 1d       	adc	r31, r1
     5bc:	60 81       	ld	r22, Z
     5be:	60 3f       	cpi	r22, 0xF0	; 240
     5c0:	39 f0       	breq	.+14     	; 0x5d0 <decodeCommand+0x2e>
     5c2:	61 3f       	cpi	r22, 0xF1	; 241
     5c4:	09 f4       	brne	.+2      	; 0x5c8 <decodeCommand+0x26>
     5c6:	56 c0       	rjmp	.+172    	; 0x674 <decodeCommand+0xd2>
     5c8:	65 3a       	cpi	r22, 0xA5	; 165
     5ca:	09 f0       	breq	.+2      	; 0x5ce <decodeCommand+0x2c>
     5cc:	47 c0       	rjmp	.+142    	; 0x65c <decodeCommand+0xba>
     5ce:	0e c0       	rjmp	.+28     	; 0x5ec <decodeCommand+0x4a>
		
		case ALIVE:
		
			putHeaderOnTx(dataTx, ALIVE, 2);
     5d0:	42 e0       	ldi	r20, 0x02	; 2
     5d2:	60 ef       	ldi	r22, 0xF0	; 240
     5d4:	ce 01       	movw	r24, r28
     5d6:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx, ACK );
     5da:	6d e0       	ldi	r22, 0x0D	; 13
     5dc:	ce 01       	movw	r24, r28
     5de:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     5e2:	6d 81       	ldd	r22, Y+5	; 0x05
     5e4:	ce 01       	movw	r24, r28
     5e6:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		
		break;
     5ea:	44 c0       	rjmp	.+136    	; 0x674 <decodeCommand+0xd2>
		case FIRMWARE:
		break;

		case DATA:
			myWord.ui16[0]	= globalDistance;
     5ec:	0c e9       	ldi	r16, 0x9C	; 156
     5ee:	12 e0       	ldi	r17, 0x02	; 2
     5f0:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <globalDistance>
     5f4:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <globalDistance+0x1>
     5f8:	f8 01       	movw	r30, r16
     5fa:	91 83       	std	Z+1, r25	; 0x01
     5fc:	80 83       	st	Z, r24
			putHeaderOnTx(dataTx, DATA, 7);
     5fe:	47 e0       	ldi	r20, 0x07	; 7
     600:	65 ea       	ldi	r22, 0xA5	; 165
     602:	ce 01       	movw	r24, r28
     604:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx, myWord.ui8[0]);
     608:	d8 01       	movw	r26, r16
     60a:	6c 91       	ld	r22, X
     60c:	ce 01       	movw	r24, r28
     60e:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     612:	f8 01       	movw	r30, r16
     614:	61 81       	ldd	r22, Z+1	; 0x01
     616:	ce 01       	movw	r24, r28
     618:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, boxToTx);
     61c:	60 91 78 01 	lds	r22, 0x0178	; 0x800178 <boxToTx>
     620:	ce 01       	movw	r24, r28
     622:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			myWord.ui16[0] = IR_GetState(&ir_sensor[0]);
     626:	80 ea       	ldi	r24, 0xA0	; 160
     628:	92 e0       	ldi	r25, 0x02	; 2
     62a:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	68 2f       	mov	r22, r24
     632:	d8 01       	movw	r26, r16
     634:	8d 93       	st	X+, r24
     636:	9c 93       	st	X, r25
			putByteOnTx(dataTx, myWord.ui8[0]);
     638:	ce 01       	movw	r24, r28
     63a:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     63e:	f8 01       	movw	r30, r16
     640:	61 81       	ldd	r22, Z+1	; 0x01
     642:	ce 01       	movw	r24, r28
     644:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, Numbox);
     648:	60 91 61 01 	lds	r22, 0x0161	; 0x800161 <Numbox>
     64c:	ce 01       	movw	r24, r28
     64e:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     652:	6d 81       	ldd	r22, Y+5	; 0x05
     654:	ce 01       	movw	r24, r28
     656:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		break;
     65a:	0c c0       	rjmp	.+24     	; 0x674 <decodeCommand+0xd2>
		//putByteOnTx(dataTx, dataTx->chk);
		//
		//break;

		default:
			putHeaderOnTx(dataTx, (_eCmd)dataRx->buff[dataRx->indexData], 2);
     65c:	42 e0       	ldi	r20, 0x02	; 2
     65e:	ce 01       	movw	r24, r28
     660:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx,UNKNOWN );
     664:	6f ef       	ldi	r22, 0xFF	; 255
     666:	ce 01       	movw	r24, r28
     668:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     66c:	6d 81       	ldd	r22, Y+5	; 0x05
     66e:	ce 01       	movw	r24, r28
     670:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		break;
		
	}
}
     674:	df 91       	pop	r29
     676:	cf 91       	pop	r28
     678:	1f 91       	pop	r17
     67a:	0f 91       	pop	r16
     67c:	08 95       	ret

0000067e <decodeHeader>:
void decodeHeader(_sRx *dataRx){
     67e:	dc 01       	movw	r26, r24
	uint8_t auxIndex=dataRx->indexW;
     680:	13 96       	adiw	r26, 0x03	; 3
     682:	2c 91       	ld	r18, X
     684:	13 97       	sbiw	r26, 0x03	; 3
	while(dataRx->indexR != auxIndex){
     686:	c9 c0       	rjmp	.+402    	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
		switch(dataRx->header)
     688:	18 96       	adiw	r26, 0x08	; 8
     68a:	ec 91       	ld	r30, X
     68c:	18 97       	sbiw	r26, 0x08	; 8
     68e:	4e 2f       	mov	r20, r30
     690:	50 e0       	ldi	r21, 0x00	; 0
     692:	47 30       	cpi	r20, 0x07	; 7
     694:	51 05       	cpc	r21, r1
     696:	08 f0       	brcs	.+2      	; 0x69a <decodeHeader+0x1c>
     698:	b2 c0       	rjmp	.+356    	; 0x7fe <decodeHeader+0x180>
     69a:	fa 01       	movw	r30, r20
     69c:	ec 5c       	subi	r30, 0xCC	; 204
     69e:	ff 4f       	sbci	r31, 0xFF	; 255
     6a0:	0c 94 b5 07 	jmp	0xf6a	; 0xf6a <__tablejump2__>
		{
			case HEADER_U:
			if(dataRx->buff[dataRx->indexR] == 'U'){
     6a4:	ed 91       	ld	r30, X+
     6a6:	fc 91       	ld	r31, X
     6a8:	11 97       	sbiw	r26, 0x01	; 1
     6aa:	e8 0f       	add	r30, r24
     6ac:	f1 1d       	adc	r31, r1
     6ae:	80 81       	ld	r24, Z
     6b0:	85 35       	cpi	r24, 0x55	; 85
     6b2:	09 f0       	breq	.+2      	; 0x6b6 <decodeHeader+0x38>
     6b4:	a7 c0       	rjmp	.+334    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				dataRx->header = HEADER_N;
     6b6:	81 e0       	ldi	r24, 0x01	; 1
     6b8:	18 96       	adiw	r26, 0x08	; 8
     6ba:	8c 93       	st	X, r24
     6bc:	18 97       	sbiw	r26, 0x08	; 8
     6be:	a2 c0       	rjmp	.+324    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case HEADER_N:
			if(dataRx->buff[dataRx->indexR] == 'N'){
     6c0:	ed 91       	ld	r30, X+
     6c2:	fc 91       	ld	r31, X
     6c4:	11 97       	sbiw	r26, 0x01	; 1
     6c6:	e8 0f       	add	r30, r24
     6c8:	f1 1d       	adc	r31, r1
     6ca:	90 81       	ld	r25, Z
     6cc:	9e 34       	cpi	r25, 0x4E	; 78
     6ce:	29 f4       	brne	.+10     	; 0x6da <decodeHeader+0x5c>
				dataRx->header = HEADER_E;
     6d0:	82 e0       	ldi	r24, 0x02	; 2
     6d2:	18 96       	adiw	r26, 0x08	; 8
     6d4:	8c 93       	st	X, r24
     6d6:	18 97       	sbiw	r26, 0x08	; 8
     6d8:	95 c0       	rjmp	.+298    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				if(dataRx->buff[dataRx->indexR] != 'U'){
     6da:	95 35       	cpi	r25, 0x55	; 85
     6dc:	09 f4       	brne	.+2      	; 0x6e0 <decodeHeader+0x62>
     6de:	92 c0       	rjmp	.+292    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
					dataRx->header = HEADER_U;
     6e0:	18 96       	adiw	r26, 0x08	; 8
     6e2:	1c 92       	st	X, r1
     6e4:	18 97       	sbiw	r26, 0x08	; 8
					dataRx->indexR--;
     6e6:	81 50       	subi	r24, 0x01	; 1
     6e8:	12 96       	adiw	r26, 0x02	; 2
     6ea:	8c 93       	st	X, r24
     6ec:	12 97       	sbiw	r26, 0x02	; 2
     6ee:	8a c0       	rjmp	.+276    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}
			}
			break;
			case HEADER_E:
			if(dataRx->buff[dataRx->indexR] == 'E'){
     6f0:	ed 91       	ld	r30, X+
     6f2:	fc 91       	ld	r31, X
     6f4:	11 97       	sbiw	r26, 0x01	; 1
     6f6:	e8 0f       	add	r30, r24
     6f8:	f1 1d       	adc	r31, r1
     6fa:	90 81       	ld	r25, Z
     6fc:	95 34       	cpi	r25, 0x45	; 69
     6fe:	29 f4       	brne	.+10     	; 0x70a <decodeHeader+0x8c>
				dataRx->header = HEADER_R;
     700:	83 e0       	ldi	r24, 0x03	; 3
     702:	18 96       	adiw	r26, 0x08	; 8
     704:	8c 93       	st	X, r24
     706:	18 97       	sbiw	r26, 0x08	; 8
     708:	7d c0       	rjmp	.+250    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     70a:	18 96       	adiw	r26, 0x08	; 8
     70c:	1c 92       	st	X, r1
     70e:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     710:	81 50       	subi	r24, 0x01	; 1
     712:	12 96       	adiw	r26, 0x02	; 2
     714:	8c 93       	st	X, r24
     716:	12 97       	sbiw	r26, 0x02	; 2
     718:	75 c0       	rjmp	.+234    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case HEADER_R:
			if(dataRx->buff[dataRx->indexR] == 'R'){
     71a:	ed 91       	ld	r30, X+
     71c:	fc 91       	ld	r31, X
     71e:	11 97       	sbiw	r26, 0x01	; 1
     720:	e8 0f       	add	r30, r24
     722:	f1 1d       	adc	r31, r1
     724:	90 81       	ld	r25, Z
     726:	92 35       	cpi	r25, 0x52	; 82
     728:	29 f4       	brne	.+10     	; 0x734 <decodeHeader+0xb6>
				dataRx->header = NBYTES;
     72a:	84 e0       	ldi	r24, 0x04	; 4
     72c:	18 96       	adiw	r26, 0x08	; 8
     72e:	8c 93       	st	X, r24
     730:	18 97       	sbiw	r26, 0x08	; 8
     732:	68 c0       	rjmp	.+208    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     734:	18 96       	adiw	r26, 0x08	; 8
     736:	1c 92       	st	X, r1
     738:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     73a:	81 50       	subi	r24, 0x01	; 1
     73c:	12 96       	adiw	r26, 0x02	; 2
     73e:	8c 93       	st	X, r24
     740:	12 97       	sbiw	r26, 0x02	; 2
     742:	60 c0       	rjmp	.+192    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case NBYTES:
			dataRx->nBytes=dataRx->buff[dataRx->indexR];
     744:	ed 91       	ld	r30, X+
     746:	fc 91       	ld	r31, X
     748:	11 97       	sbiw	r26, 0x01	; 1
     74a:	e8 0f       	add	r30, r24
     74c:	f1 1d       	adc	r31, r1
     74e:	80 81       	ld	r24, Z
     750:	17 96       	adiw	r26, 0x07	; 7
     752:	8c 93       	st	X, r24
     754:	17 97       	sbiw	r26, 0x07	; 7
			dataRx->header = TOKEN;
     756:	85 e0       	ldi	r24, 0x05	; 5
     758:	18 96       	adiw	r26, 0x08	; 8
     75a:	8c 93       	st	X, r24
     75c:	18 97       	sbiw	r26, 0x08	; 8
			break;
     75e:	52 c0       	rjmp	.+164    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			case TOKEN:
			if(dataRx->buff[dataRx->indexR] == ':'){
     760:	ed 91       	ld	r30, X+
     762:	fc 91       	ld	r31, X
     764:	11 97       	sbiw	r26, 0x01	; 1
     766:	e8 0f       	add	r30, r24
     768:	f1 1d       	adc	r31, r1
     76a:	90 81       	ld	r25, Z
     76c:	9a 33       	cpi	r25, 0x3A	; 58
     76e:	a9 f4       	brne	.+42     	; 0x79a <decodeHeader+0x11c>
				dataRx->header = PAYLOAD;
     770:	96 e0       	ldi	r25, 0x06	; 6
     772:	18 96       	adiw	r26, 0x08	; 8
     774:	9c 93       	st	X, r25
     776:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexData = dataRx->indexR+1;
     778:	8f 5f       	subi	r24, 0xFF	; 255
				dataRx->indexData &= dataRx->mask;
     77a:	15 96       	adiw	r26, 0x05	; 5
     77c:	9c 91       	ld	r25, X
     77e:	15 97       	sbiw	r26, 0x05	; 5
     780:	89 23       	and	r24, r25
     782:	14 96       	adiw	r26, 0x04	; 4
     784:	8c 93       	st	X, r24
     786:	14 97       	sbiw	r26, 0x04	; 4
				dataRx->chk = 0;
				dataRx->chk ^= ('U' ^'N' ^'E' ^'R' ^dataRx->nBytes ^':') ;
     788:	17 96       	adiw	r26, 0x07	; 7
     78a:	9c 91       	ld	r25, X
     78c:	17 97       	sbiw	r26, 0x07	; 7
     78e:	86 e3       	ldi	r24, 0x36	; 54
     790:	89 27       	eor	r24, r25
     792:	16 96       	adiw	r26, 0x06	; 6
     794:	8c 93       	st	X, r24
     796:	16 97       	sbiw	r26, 0x06	; 6
     798:	35 c0       	rjmp	.+106    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     79a:	18 96       	adiw	r26, 0x08	; 8
     79c:	1c 92       	st	X, r1
     79e:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     7a0:	81 50       	subi	r24, 0x01	; 1
     7a2:	12 96       	adiw	r26, 0x02	; 2
     7a4:	8c 93       	st	X, r24
     7a6:	12 97       	sbiw	r26, 0x02	; 2
     7a8:	2d c0       	rjmp	.+90     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case PAYLOAD:
			dataRx->nBytes--;
     7aa:	17 96       	adiw	r26, 0x07	; 7
     7ac:	9c 91       	ld	r25, X
     7ae:	17 97       	sbiw	r26, 0x07	; 7
     7b0:	91 50       	subi	r25, 0x01	; 1
     7b2:	17 96       	adiw	r26, 0x07	; 7
     7b4:	9c 93       	st	X, r25
     7b6:	17 97       	sbiw	r26, 0x07	; 7
			if(dataRx->nBytes>0){
     7b8:	99 23       	and	r25, r25
     7ba:	71 f0       	breq	.+28     	; 0x7d8 <decodeHeader+0x15a>
				dataRx->chk ^= dataRx->buff[dataRx->indexR];
     7bc:	ed 91       	ld	r30, X+
     7be:	fc 91       	ld	r31, X
     7c0:	11 97       	sbiw	r26, 0x01	; 1
     7c2:	e8 0f       	add	r30, r24
     7c4:	f1 1d       	adc	r31, r1
     7c6:	80 81       	ld	r24, Z
     7c8:	16 96       	adiw	r26, 0x06	; 6
     7ca:	9c 91       	ld	r25, X
     7cc:	16 97       	sbiw	r26, 0x06	; 6
     7ce:	89 27       	eor	r24, r25
     7d0:	16 96       	adiw	r26, 0x06	; 6
     7d2:	8c 93       	st	X, r24
     7d4:	16 97       	sbiw	r26, 0x06	; 6
     7d6:	16 c0       	rjmp	.+44     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     7d8:	18 96       	adiw	r26, 0x08	; 8
     7da:	1c 92       	st	X, r1
     7dc:	18 97       	sbiw	r26, 0x08	; 8
				if(dataRx->buff[dataRx->indexR] == dataRx->chk)
     7de:	ed 91       	ld	r30, X+
     7e0:	fc 91       	ld	r31, X
     7e2:	11 97       	sbiw	r26, 0x01	; 1
     7e4:	e8 0f       	add	r30, r24
     7e6:	f1 1d       	adc	r31, r1
     7e8:	90 81       	ld	r25, Z
     7ea:	16 96       	adiw	r26, 0x06	; 6
     7ec:	8c 91       	ld	r24, X
     7ee:	16 97       	sbiw	r26, 0x06	; 6
     7f0:	98 13       	cpse	r25, r24
     7f2:	08 c0       	rjmp	.+16     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				dataRx->isComannd = TRUE;
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	1a 96       	adiw	r26, 0x0a	; 10
     7f8:	8c 93       	st	X, r24
     7fa:	1a 97       	sbiw	r26, 0x0a	; 10
     7fc:	03 c0       	rjmp	.+6      	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			default:
			dataRx->header = HEADER_U;
     7fe:	18 96       	adiw	r26, 0x08	; 8
     800:	1c 92       	st	X, r1
     802:	18 97       	sbiw	r26, 0x08	; 8
			break;
		}
		dataRx->indexR++;
     804:	12 96       	adiw	r26, 0x02	; 2
     806:	8c 91       	ld	r24, X
     808:	12 97       	sbiw	r26, 0x02	; 2
     80a:	8f 5f       	subi	r24, 0xFF	; 255
		dataRx->indexR &= dataRx->mask;
     80c:	15 96       	adiw	r26, 0x05	; 5
     80e:	9c 91       	ld	r25, X
     810:	15 97       	sbiw	r26, 0x05	; 5
     812:	89 23       	and	r24, r25
     814:	12 96       	adiw	r26, 0x02	; 2
     816:	8c 93       	st	X, r24
     818:	12 97       	sbiw	r26, 0x02	; 2
		
	}
}
void decodeHeader(_sRx *dataRx){
	uint8_t auxIndex=dataRx->indexW;
	while(dataRx->indexR != auxIndex){
     81a:	12 96       	adiw	r26, 0x02	; 2
     81c:	8c 91       	ld	r24, X
     81e:	12 97       	sbiw	r26, 0x02	; 2
     820:	28 13       	cpse	r18, r24
     822:	32 cf       	rjmp	.-412    	; 0x688 <decodeHeader+0xa>
			break;
		}
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}
     824:	08 95       	ret

00000826 <serialTask>:

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}

void serialTask(_sRx* dataRx, _sTx* dataTx){
     826:	0f 93       	push	r16
     828:	1f 93       	push	r17
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	8c 01       	movw	r16, r24
     830:	eb 01       	movw	r28, r22
	if(dataRx->isComannd){
     832:	fc 01       	movw	r30, r24
     834:	82 85       	ldd	r24, Z+10	; 0x0a
     836:	88 23       	and	r24, r24
     838:	21 f0       	breq	.+8      	; 0x842 <serialTask+0x1c>
		dataRx->isComannd=FALSE;
     83a:	12 86       	std	Z+10, r1	; 0x0a
		decodeCommand(dataRx,dataTx);
     83c:	c8 01       	movw	r24, r16
     83e:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <decodeCommand>
	}
	if(dataRx->indexR!=dataRx->indexW){
     842:	f8 01       	movw	r30, r16
     844:	92 81       	ldd	r25, Z+2	; 0x02
     846:	83 81       	ldd	r24, Z+3	; 0x03
     848:	98 17       	cp	r25, r24
     84a:	19 f0       	breq	.+6      	; 0x852 <serialTask+0x2c>
		
		decodeHeader(dataRx);
     84c:	c8 01       	movw	r24, r16
     84e:	0e 94 3f 03 	call	0x67e	; 0x67e <decodeHeader>
	}
	if (dataTx->indexR!= dataTx->indexW) {
     852:	8a 81       	ldd	r24, Y+2	; 0x02
     854:	9b 81       	ldd	r25, Y+3	; 0x03
     856:	89 17       	cp	r24, r25
     858:	91 f0       	breq	.+36     	; 0x87e <serialTask+0x58>
		if (UCSR0A & (1 << UDRE0)) { // Si el buffer de transmisión está vacío
     85a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     85e:	95 ff       	sbrs	r25, 5
     860:	0e c0       	rjmp	.+28     	; 0x87e <serialTask+0x58>
			UDR0 = dataTx->buff[dataTx->indexR++]; // Enviar el dato
     862:	e8 81       	ld	r30, Y
     864:	f9 81       	ldd	r31, Y+1	; 0x01
     866:	91 e0       	ldi	r25, 0x01	; 1
     868:	98 0f       	add	r25, r24
     86a:	9a 83       	std	Y+2, r25	; 0x02
     86c:	e8 0f       	add	r30, r24
     86e:	f1 1d       	adc	r31, r1
     870:	80 81       	ld	r24, Z
     872:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
			dataTx->indexR &= dataTx->mask;
     876:	8c 81       	ldd	r24, Y+4	; 0x04
     878:	9a 81       	ldd	r25, Y+2	; 0x02
     87a:	89 23       	and	r24, r25
     87c:	8a 83       	std	Y+2, r24	; 0x02
		}
	}
}
     87e:	df 91       	pop	r29
     880:	cf 91       	pop	r28
     882:	1f 91       	pop	r17
     884:	0f 91       	pop	r16
     886:	08 95       	ret

00000888 <sensorMeasure>:
	count200ms--;
}

void sensorMeasure(uint16_t distance){
	
	globalDistance = distance;
     888:	90 93 60 01 	sts	0x0160, r25	; 0x800160 <globalDistance+0x1>
     88c:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <globalDistance>
     890:	08 95       	ret

00000892 <addBox>:
	
}

void addBox(uint16_t distance){
     892:	cf 93       	push	r28
	static uint8_t i = 1, j = 1, k = 1;
	
	if ((distance >= Cm13) && (distance < Cm15)) { //si la distancia se encuentra entre 15 y 13 cm es caja chica
     894:	9c 01       	movw	r18, r24
     896:	22 5f       	subi	r18, 0xF2	; 242
     898:	32 40       	sbci	r19, 0x02	; 2
     89a:	24 37       	cpi	r18, 0x74	; 116
     89c:	31 05       	cpc	r19, r1
     89e:	d0 f5       	brcc	.+116    	; 0x914 <__stack+0x15>
		Cajita[Numbox].boxState=isOn;
     8a0:	e0 91 61 01 	lds	r30, 0x0161	; 0x800161 <Numbox>
     8a4:	f0 e0       	ldi	r31, 0x00	; 0
     8a6:	ee 0f       	add	r30, r30
     8a8:	ff 1f       	adc	r31, r31
     8aa:	e4 51       	subi	r30, 0x14	; 20
     8ac:	fc 4f       	sbci	r31, 0xFC	; 252
     8ae:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=SmallBox;
     8b0:	91 e0       	ldi	r25, 0x01	; 1
     8b2:	90 83       	st	Z, r25
		boxToTx = 0x4;
     8b4:	84 e0       	ldi	r24, 0x04	; 4
     8b6:	80 93 78 01 	sts	0x0178, r24	; 0x800178 <boxToTx>
		CajitaArr[0][i] = 1;
     8ba:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <i.2284>
     8be:	e8 2f       	mov	r30, r24
     8c0:	f0 e0       	ldi	r31, 0x00	; 0
     8c2:	e0 55       	subi	r30, 0x50	; 80
     8c4:	fd 4f       	sbci	r31, 0xFD	; 253
     8c6:	90 83       	st	Z, r25
		i++;
     8c8:	8f 5f       	subi	r24, 0xFF	; 255
     8ca:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <i.2284>
			
		printf("Fila SmallBox: ");
     8ce:	8c e1       	ldi	r24, 0x1C	; 28
     8d0:	91 e0       	ldi	r25, 0x01	; 1
     8d2:	9f 93       	push	r25
     8d4:	8f 93       	push	r24
     8d6:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
		for (uint8_t n = 0; n < 20; n++) {
     8da:	0f 90       	pop	r0
     8dc:	0f 90       	pop	r0
     8de:	c0 e0       	ldi	r28, 0x00	; 0
     8e0:	12 c0       	rjmp	.+36     	; 0x906 <__stack+0x7>
			printf("%u ", CajitaArr[0][n]);
     8e2:	ec 2f       	mov	r30, r28
     8e4:	f0 e0       	ldi	r31, 0x00	; 0
     8e6:	e0 55       	subi	r30, 0x50	; 80
     8e8:	fd 4f       	sbci	r31, 0xFD	; 253
     8ea:	80 81       	ld	r24, Z
     8ec:	1f 92       	push	r1
     8ee:	8f 93       	push	r24
     8f0:	8c e2       	ldi	r24, 0x2C	; 44
     8f2:	91 e0       	ldi	r25, 0x01	; 1
     8f4:	9f 93       	push	r25
     8f6:	8f 93       	push	r24
     8f8:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
		boxToTx = 0x4;
		CajitaArr[0][i] = 1;
		i++;
			
		printf("Fila SmallBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     8fc:	cf 5f       	subi	r28, 0xFF	; 255
     8fe:	0f 90       	pop	r0
     900:	0f 90       	pop	r0
     902:	0f 90       	pop	r0
     904:	0f 90       	pop	r0
     906:	c4 31       	cpi	r28, 0x14	; 20
     908:	60 f3       	brcs	.-40     	; 0x8e2 <addBox+0x50>
			printf("%u ", CajitaArr[0][n]);
		}
		printf("\n");
     90a:	8a e0       	ldi	r24, 0x0A	; 10
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	0e 94 01 09 	call	0x1202	; 0x1202 <putchar>
     912:	a5 c0       	rjmp	.+330    	; 0xa5e <__stack+0x15f>
	}
	else if ((distance >= Cm11) && (distance < Cm13)){
     914:	9c 01       	movw	r18, r24
     916:	2e 57       	subi	r18, 0x7E	; 126
     918:	32 40       	sbci	r19, 0x02	; 2
     91a:	24 37       	cpi	r18, 0x74	; 116
     91c:	31 05       	cpc	r19, r1
     91e:	08 f0       	brcs	.+2      	; 0x922 <__stack+0x23>
     920:	44 c0       	rjmp	.+136    	; 0x9aa <__stack+0xab>
		Cajita[Numbox].boxState=isOn;
     922:	e0 91 61 01 	lds	r30, 0x0161	; 0x800161 <Numbox>
     926:	f0 e0       	ldi	r31, 0x00	; 0
     928:	ee 0f       	add	r30, r30
     92a:	ff 1f       	adc	r31, r31
     92c:	e4 51       	subi	r30, 0x14	; 20
     92e:	fc 4f       	sbci	r31, 0xFC	; 252
     930:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=MediumBox;
     932:	82 e0       	ldi	r24, 0x02	; 2
     934:	80 83       	st	Z, r24
		boxToTx = 0x2;
     936:	80 93 78 01 	sts	0x0178, r24	; 0x800178 <boxToTx>
		CajitaArr[1][j] = 1;
     93a:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <j.2285>
     93e:	e9 2f       	mov	r30, r25
     940:	f0 e0       	ldi	r31, 0x00	; 0
     942:	e0 55       	subi	r30, 0x50	; 80
     944:	fd 4f       	sbci	r31, 0xFD	; 253
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	84 8b       	std	Z+20, r24	; 0x14
		CajitaArr[0][i] = 0;
     94a:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <i.2284>
     94e:	e8 2f       	mov	r30, r24
     950:	f0 e0       	ldi	r31, 0x00	; 0
     952:	e0 55       	subi	r30, 0x50	; 80
     954:	fd 4f       	sbci	r31, 0xFD	; 253
     956:	10 82       	st	Z, r1
		j++;
     958:	9f 5f       	subi	r25, 0xFF	; 255
     95a:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <j.2285>
		i++;
     95e:	8f 5f       	subi	r24, 0xFF	; 255
     960:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <i.2284>
			
		printf("Fila MediumBox: ");
     964:	80 e3       	ldi	r24, 0x30	; 48
     966:	91 e0       	ldi	r25, 0x01	; 1
     968:	9f 93       	push	r25
     96a:	8f 93       	push	r24
     96c:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
		for (uint8_t n = 0; n < 20; n++) {
     970:	0f 90       	pop	r0
     972:	0f 90       	pop	r0
     974:	c0 e0       	ldi	r28, 0x00	; 0
     976:	12 c0       	rjmp	.+36     	; 0x99c <__stack+0x9d>
			printf("%u ", CajitaArr[1][n]);
     978:	ec 2f       	mov	r30, r28
     97a:	f0 e0       	ldi	r31, 0x00	; 0
     97c:	e0 55       	subi	r30, 0x50	; 80
     97e:	fd 4f       	sbci	r31, 0xFD	; 253
     980:	84 89       	ldd	r24, Z+20	; 0x14
     982:	1f 92       	push	r1
     984:	8f 93       	push	r24
     986:	8c e2       	ldi	r24, 0x2C	; 44
     988:	91 e0       	ldi	r25, 0x01	; 1
     98a:	9f 93       	push	r25
     98c:	8f 93       	push	r24
     98e:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
		CajitaArr[0][i] = 0;
		j++;
		i++;
			
		printf("Fila MediumBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     992:	cf 5f       	subi	r28, 0xFF	; 255
     994:	0f 90       	pop	r0
     996:	0f 90       	pop	r0
     998:	0f 90       	pop	r0
     99a:	0f 90       	pop	r0
     99c:	c4 31       	cpi	r28, 0x14	; 20
     99e:	60 f3       	brcs	.-40     	; 0x978 <__stack+0x79>
			printf("%u ", CajitaArr[1][n]);
		}
		printf("\n");
     9a0:	8a e0       	ldi	r24, 0x0A	; 10
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	0e 94 01 09 	call	0x1202	; 0x1202 <putchar>
     9a8:	5a c0       	rjmp	.+180    	; 0xa5e <__stack+0x15f>
	}
	else if ((distance >= Cm9) && (distance < Cm11)){
     9aa:	8a 50       	subi	r24, 0x0A	; 10
     9ac:	92 40       	sbci	r25, 0x02	; 2
     9ae:	84 37       	cpi	r24, 0x74	; 116
     9b0:	91 05       	cpc	r25, r1
     9b2:	08 f0       	brcs	.+2      	; 0x9b6 <__stack+0xb7>
     9b4:	4e c0       	rjmp	.+156    	; 0xa52 <__stack+0x153>
		Cajita[Numbox].boxState=isOn;
     9b6:	e0 91 61 01 	lds	r30, 0x0161	; 0x800161 <Numbox>
     9ba:	f0 e0       	ldi	r31, 0x00	; 0
     9bc:	ee 0f       	add	r30, r30
     9be:	ff 1f       	adc	r31, r31
     9c0:	e4 51       	subi	r30, 0x14	; 20
     9c2:	fc 4f       	sbci	r31, 0xFC	; 252
     9c4:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=LargeBox;
     9c6:	83 e0       	ldi	r24, 0x03	; 3
     9c8:	80 83       	st	Z, r24
		boxToTx = 0x1;
     9ca:	31 e0       	ldi	r19, 0x01	; 1
     9cc:	30 93 78 01 	sts	0x0178, r19	; 0x800178 <boxToTx>
		CajitaArr[0][i] = 0;
     9d0:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <i.2284>
     9d4:	e9 2f       	mov	r30, r25
     9d6:	f0 e0       	ldi	r31, 0x00	; 0
     9d8:	e0 55       	subi	r30, 0x50	; 80
     9da:	fd 4f       	sbci	r31, 0xFD	; 253
     9dc:	10 82       	st	Z, r1
		CajitaArr[1][j] = 0;
     9de:	20 91 07 01 	lds	r18, 0x0107	; 0x800107 <j.2285>
     9e2:	e2 2f       	mov	r30, r18
     9e4:	f0 e0       	ldi	r31, 0x00	; 0
     9e6:	e0 55       	subi	r30, 0x50	; 80
     9e8:	fd 4f       	sbci	r31, 0xFD	; 253
     9ea:	14 8a       	std	Z+20, r1	; 0x14
		CajitaArr[2][k] = 1;
     9ec:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <k.2286>
     9f0:	e8 2f       	mov	r30, r24
     9f2:	f0 e0       	ldi	r31, 0x00	; 0
     9f4:	e0 55       	subi	r30, 0x50	; 80
     9f6:	fd 4f       	sbci	r31, 0xFD	; 253
     9f8:	30 a7       	std	Z+40, r19	; 0x28
		j++;
     9fa:	2f 5f       	subi	r18, 0xFF	; 255
     9fc:	20 93 07 01 	sts	0x0107, r18	; 0x800107 <j.2285>
		i++;
     a00:	9f 5f       	subi	r25, 0xFF	; 255
     a02:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <i.2284>
		k++;
     a06:	8f 5f       	subi	r24, 0xFF	; 255
     a08:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <k.2286>
					
		printf("Fila LargeBox: ");
     a0c:	81 e4       	ldi	r24, 0x41	; 65
     a0e:	91 e0       	ldi	r25, 0x01	; 1
     a10:	9f 93       	push	r25
     a12:	8f 93       	push	r24
     a14:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
		for (uint8_t n = 0; n < 20; n++) {
     a18:	0f 90       	pop	r0
     a1a:	0f 90       	pop	r0
     a1c:	c0 e0       	ldi	r28, 0x00	; 0
     a1e:	12 c0       	rjmp	.+36     	; 0xa44 <__stack+0x145>
			printf("%u ", CajitaArr[2][n]);
     a20:	ec 2f       	mov	r30, r28
     a22:	f0 e0       	ldi	r31, 0x00	; 0
     a24:	e0 55       	subi	r30, 0x50	; 80
     a26:	fd 4f       	sbci	r31, 0xFD	; 253
     a28:	80 a5       	ldd	r24, Z+40	; 0x28
     a2a:	1f 92       	push	r1
     a2c:	8f 93       	push	r24
     a2e:	8c e2       	ldi	r24, 0x2C	; 44
     a30:	91 e0       	ldi	r25, 0x01	; 1
     a32:	9f 93       	push	r25
     a34:	8f 93       	push	r24
     a36:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
		j++;
		i++;
		k++;
					
		printf("Fila LargeBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     a3a:	cf 5f       	subi	r28, 0xFF	; 255
     a3c:	0f 90       	pop	r0
     a3e:	0f 90       	pop	r0
     a40:	0f 90       	pop	r0
     a42:	0f 90       	pop	r0
     a44:	c4 31       	cpi	r28, 0x14	; 20
     a46:	60 f3       	brcs	.-40     	; 0xa20 <__stack+0x121>
			printf("%u ", CajitaArr[2][n]);
		}
		printf("\n");
     a48:	8a e0       	ldi	r24, 0x0A	; 10
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	0e 94 01 09 	call	0x1202	; 0x1202 <putchar>
     a50:	06 c0       	rjmp	.+12     	; 0xa5e <__stack+0x15f>
		
	}
	else if ((distance < Cm9) || (distance >= Cm15)){
     a52:	8c 35       	cpi	r24, 0x5C	; 92
     a54:	91 40       	sbci	r25, 0x01	; 1
     a56:	18 f0       	brcs	.+6      	; 0xa5e <__stack+0x15f>
		Cajita->boxSize=NotSelected;
     a58:	84 e0       	ldi	r24, 0x04	; 4
     a5a:	80 93 ec 03 	sts	0x03EC, r24	; 0x8003ec <Cajita>
	}
	
	Numbox++;
     a5e:	80 91 61 01 	lds	r24, 0x0161	; 0x800161 <Numbox>
     a62:	8f 5f       	subi	r24, 0xFF	; 255
     a64:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <Numbox>
	
	if(Numbox>=bufferBox) //reinicio el buffer
     a68:	8f 30       	cpi	r24, 0x0F	; 15
     a6a:	10 f0       	brcs	.+4      	; 0xa70 <__stack+0x171>
	Numbox=0;
     a6c:	10 92 61 01 	sts	0x0161, r1	; 0x800161 <Numbox>
}
     a70:	cf 91       	pop	r28
     a72:	08 95       	ret

00000a74 <newBox>:

void newBox(uint16_t distance){
     a74:	cf 93       	push	r28
     a76:	df 93       	push	r29
	if(distance<Cm18){
     a78:	8c 34       	cpi	r24, 0x4C	; 76
     a7a:	24 e0       	ldi	r18, 0x04	; 4
     a7c:	92 07       	cpc	r25, r18
     a7e:	00 f5       	brcc	.+64     	; 0xac0 <newBox+0x4c>
     a80:	ec 01       	movw	r28, r24
		if((IR_GetState(&ir_sensor[0]) == 0) && !MEASURINGBOX){
     a82:	80 ea       	ldi	r24, 0xA0	; 160
     a84:	92 e0       	ldi	r25, 0x02	; 2
     a86:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     a8a:	81 11       	cpse	r24, r1
     a8c:	0e c0       	rjmp	.+28     	; 0xaaa <newBox+0x36>
     a8e:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     a92:	81 fd       	sbrc	r24, 1
     a94:	0a c0       	rjmp	.+20     	; 0xaaa <newBox+0x36>
			MEASURINGBOX=TRUE;
     a96:	82 60       	ori	r24, 0x02	; 2
     a98:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
			addBox(distance);
     a9c:	ce 01       	movw	r24, r28
     a9e:	0e 94 49 04 	call	0x892	; 0x892 <addBox>
			PORTB ^=(1<<LED_BI);
     aa2:	95 b1       	in	r25, 0x05	; 5
     aa4:	80 e2       	ldi	r24, 0x20	; 32
     aa6:	89 27       	eor	r24, r25
     aa8:	85 b9       	out	0x05, r24	; 5
		}
		if ((IR_GetState(&ir_sensor[0]) == 1)) //si IR no mide
     aaa:	80 ea       	ldi	r24, 0xA0	; 160
     aac:	92 e0       	ldi	r25, 0x02	; 2
     aae:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     ab2:	81 30       	cpi	r24, 0x01	; 1
     ab4:	29 f4       	brne	.+10     	; 0xac0 <newBox+0x4c>
				MEASURINGBOX=FALSE;
     ab6:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     aba:	8d 7f       	andi	r24, 0xFD	; 253
     abc:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
	}
}
     ac0:	df 91       	pop	r29
     ac2:	cf 91       	pop	r28
     ac4:	08 95       	ret

00000ac6 <kickBox>:

void kickBox(){
	
	//if (waittt != 0){
		//if (IR_GetState(&ir_sensor[1])==0){
			if (ir_sensor[1].state== IR_FALLING){
     ac6:	80 91 a4 02 	lds	r24, 0x02A4	; 0x8002a4 <ir_sensor+0x4>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	59 f5       	brne	.+86     	; 0xb24 <kickBox+0x5e>
			sIR1++;
     ace:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <sIR1>
     ad2:	8f 5f       	subi	r24, 0xFF	; 255
     ad4:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <sIR1>
			printf("%u ", sIR1);
     ad8:	1f 92       	push	r1
     ada:	8f 93       	push	r24
     adc:	8c e2       	ldi	r24, 0x2C	; 44
     ade:	91 e0       	ldi	r25, 0x01	; 1
     ae0:	9f 93       	push	r25
     ae2:	8f 93       	push	r24
     ae4:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
			waittt = 0;
     ae8:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <waittt>
			if(CajitaArr[0][sIR1] == 1){
     aec:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <sIR1>
     af0:	f0 e0       	ldi	r31, 0x00	; 0
     af2:	e0 55       	subi	r30, 0x50	; 80
     af4:	fd 4f       	sbci	r31, 0xFD	; 253
     af6:	80 81       	ld	r24, Z
     af8:	0f 90       	pop	r0
     afa:	0f 90       	pop	r0
     afc:	0f 90       	pop	r0
     afe:	0f 90       	pop	r0
     b00:	81 30       	cpi	r24, 0x01	; 1
     b02:	81 f4       	brne	.+32     	; 0xb24 <kickBox+0x5e>
				printf("ENTRE: ");
     b04:	81 e5       	ldi	r24, 0x51	; 81
     b06:	91 e0       	ldi	r25, 0x01	; 1
     b08:	9f 93       	push	r25
     b0a:	8f 93       	push	r24
     b0c:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
				printf("\n");
     b10:	8a e0       	ldi	r24, 0x0A	; 10
     b12:	90 e0       	ldi	r25, 0x00	; 0
     b14:	0e 94 01 09 	call	0x1202	; 0x1202 <putchar>
				servo_Angle(0,0);
     b18:	60 e0       	ldi	r22, 0x00	; 0
     b1a:	80 e0       	ldi	r24, 0x00	; 0
     b1c:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
     b20:	0f 90       	pop	r0
     b22:	0f 90       	pop	r0
				//CajitaArr[0][i] = 0;
			}
		}
		
		//if (IR_GetState(&ir_sensor[2])==0){
			if (ir_sensor[2].state== IR_FALLING){
     b24:	80 91 a8 02 	lds	r24, 0x02A8	; 0x8002a8 <ir_sensor+0x8>
     b28:	82 30       	cpi	r24, 0x02	; 2
     b2a:	59 f5       	brne	.+86     	; 0xb82 <kickBox+0xbc>
			sIR2++;
     b2c:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <sIR2>
     b30:	8f 5f       	subi	r24, 0xFF	; 255
     b32:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <sIR2>
			printf("%u ", sIR2);
     b36:	1f 92       	push	r1
     b38:	8f 93       	push	r24
     b3a:	8c e2       	ldi	r24, 0x2C	; 44
     b3c:	91 e0       	ldi	r25, 0x01	; 1
     b3e:	9f 93       	push	r25
     b40:	8f 93       	push	r24
     b42:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
			waittt = 0;
     b46:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <waittt>
			if(CajitaArr[1][sIR2] == 1){
     b4a:	e0 91 5d 01 	lds	r30, 0x015D	; 0x80015d <sIR2>
     b4e:	f0 e0       	ldi	r31, 0x00	; 0
     b50:	e0 55       	subi	r30, 0x50	; 80
     b52:	fd 4f       	sbci	r31, 0xFD	; 253
     b54:	84 89       	ldd	r24, Z+20	; 0x14
     b56:	0f 90       	pop	r0
     b58:	0f 90       	pop	r0
     b5a:	0f 90       	pop	r0
     b5c:	0f 90       	pop	r0
     b5e:	81 30       	cpi	r24, 0x01	; 1
     b60:	81 f4       	brne	.+32     	; 0xb82 <kickBox+0xbc>
				printf("ENTRE: ");
     b62:	81 e5       	ldi	r24, 0x51	; 81
     b64:	91 e0       	ldi	r25, 0x01	; 1
     b66:	9f 93       	push	r25
     b68:	8f 93       	push	r24
     b6a:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
				printf("\n");
     b6e:	8a e0       	ldi	r24, 0x0A	; 10
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	0e 94 01 09 	call	0x1202	; 0x1202 <putchar>
				servo_Angle(1,0);
     b76:	60 e0       	ldi	r22, 0x00	; 0
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
     b7e:	0f 90       	pop	r0
     b80:	0f 90       	pop	r0
			}
		}
			
		//if (IR_GetState(&ir_sensor[3])==0){
			if (ir_sensor[3].state== IR_FALLING){
     b82:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <ir_sensor+0xc>
     b86:	82 30       	cpi	r24, 0x02	; 2
     b88:	59 f5       	brne	.+86     	; 0xbe0 <kickBox+0x11a>
			sIR3++;
     b8a:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <sIR3>
     b8e:	8f 5f       	subi	r24, 0xFF	; 255
     b90:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <sIR3>
			printf("%u ", sIR3);
     b94:	1f 92       	push	r1
     b96:	8f 93       	push	r24
     b98:	8c e2       	ldi	r24, 0x2C	; 44
     b9a:	91 e0       	ldi	r25, 0x01	; 1
     b9c:	9f 93       	push	r25
     b9e:	8f 93       	push	r24
     ba0:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
			waittt = 0;
     ba4:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <waittt>
			if(CajitaArr[2][sIR3] == 1){
     ba8:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <sIR3>
     bac:	f0 e0       	ldi	r31, 0x00	; 0
     bae:	e0 55       	subi	r30, 0x50	; 80
     bb0:	fd 4f       	sbci	r31, 0xFD	; 253
     bb2:	80 a5       	ldd	r24, Z+40	; 0x28
     bb4:	0f 90       	pop	r0
     bb6:	0f 90       	pop	r0
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	81 30       	cpi	r24, 0x01	; 1
     bbe:	81 f4       	brne	.+32     	; 0xbe0 <kickBox+0x11a>
				printf("ENTRE: ");
     bc0:	81 e5       	ldi	r24, 0x51	; 81
     bc2:	91 e0       	ldi	r25, 0x01	; 1
     bc4:	9f 93       	push	r25
     bc6:	8f 93       	push	r24
     bc8:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <printf>
				printf("\n");
     bcc:	8a e0       	ldi	r24, 0x0A	; 10
     bce:	90 e0       	ldi	r25, 0x00	; 0
     bd0:	0e 94 01 09 	call	0x1202	; 0x1202 <putchar>
				servo_Angle(2,0);
     bd4:	60 e0       	ldi	r22, 0x00	; 0
     bd6:	82 e0       	ldi	r24, 0x02	; 2
     bd8:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	08 95       	ret

00000be2 <servoreset>:
	//	}
	}
}

void servoreset(){
	servo_Angle(0,120);
     be2:	68 e7       	ldi	r22, 0x78	; 120
     be4:	80 e0       	ldi	r24, 0x00	; 0
     be6:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
	servo_Angle(1,120);
     bea:	68 e7       	ldi	r22, 0x78	; 120
     bec:	81 e0       	ldi	r24, 0x01	; 1
     bee:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
	servo_Angle(2,120);
     bf2:	68 e7       	ldi	r22, 0x78	; 120
     bf4:	82 e0       	ldi	r24, 0x02	; 2
     bf6:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
     bfa:	08 95       	ret

00000bfc <every10ms>:
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}

void every10ms(){
     bfc:	cf 93       	push	r28
     bfe:	df 93       	push	r29
	
	if (!count100ms){		//Si pasaron 100ms
     c00:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <count100ms>
     c04:	81 11       	cpse	r24, r1
     c06:	1f c0       	rjmp	.+62     	; 0xc46 <every10ms+0x4a>

uint32_t	HCSR_1;
uint16_t	aux16 = 0;

static inline void on_reset_hcsr(){
	aux16 = TCNT1;								// Loads actual time in TCNT1 into aux16
     c08:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
     c0c:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
	aux16 += 20;								// 20*500ns = 10us (tiempo del trigger), Adds 10 (us) to the previously saved time at TCNT1
     c10:	44 96       	adiw	r24, 0x14	; 20
     c12:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <aux16+0x1>
     c16:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <aux16>
	OCR1B = aux16;								// Then loads the value into OCR1B, generating an Output Compare Interrupt
     c1a:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7f808b>
     c1e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7f808a>
	TIFR1 = (1<<OCF1B) | (1<<OCF1A);			// Flag set after the counter value in TCNT1 equals OCR1A and OCR1B
     c22:	86 e0       	ldi	r24, 0x06	; 6
     c24:	86 bb       	out	0x16, r24	; 22
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
     c26:	84 e0       	ldi	r24, 0x04	; 4
     c28:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
     c2c:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <HCSR_1>
     c30:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <HCSR_1+0x1>
     c34:	0e 94 87 00 	call	0x10e	; 0x10e <HCSR04_Start>
		on_reset_hcsr();
		count100ms = 10;
     c38:	8a e0       	ldi	r24, 0x0A	; 10
     c3a:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <count100ms>
		PORTB ^= (1<<LED_BI);
     c3e:	95 b1       	in	r25, 0x05	; 5
     c40:	80 e2       	ldi	r24, 0x20	; 32
     c42:	89 27       	eor	r24, r25
     c44:	85 b9       	out	0x05, r24	; 5
	}
	
	if (!count40ms){
     c46:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <count40ms>
     c4a:	88 23       	and	r24, r24
     c4c:	81 f0       	breq	.+32     	; 0xc6e <every10ms+0x72>
     c4e:	1f c0       	rjmp	.+62     	; 0xc8e <every10ms+0x92>
		for(int i=0;i<4;i++){
			IR_Update(&ir_sensor[i], raw_input[i]);
     c50:	fe 01       	movw	r30, r28
     c52:	e9 56       	subi	r30, 0x69	; 105
     c54:	fd 4f       	sbci	r31, 0xFD	; 253
     c56:	ce 01       	movw	r24, r28
     c58:	88 0f       	add	r24, r24
     c5a:	99 1f       	adc	r25, r25
     c5c:	88 0f       	add	r24, r24
     c5e:	99 1f       	adc	r25, r25
     c60:	60 81       	ld	r22, Z
     c62:	80 56       	subi	r24, 0x60	; 96
     c64:	9d 4f       	sbci	r25, 0xFD	; 253
     c66:	0e 94 2a 02 	call	0x454	; 0x454 <IR_Update>
		count100ms = 10;
		PORTB ^= (1<<LED_BI);
	}
	
	if (!count40ms){
		for(int i=0;i<4;i++){
     c6a:	21 96       	adiw	r28, 0x01	; 1
     c6c:	02 c0       	rjmp	.+4      	; 0xc72 <every10ms+0x76>
     c6e:	c0 e0       	ldi	r28, 0x00	; 0
     c70:	d0 e0       	ldi	r29, 0x00	; 0
     c72:	c4 30       	cpi	r28, 0x04	; 4
     c74:	d1 05       	cpc	r29, r1
     c76:	64 f3       	brlt	.-40     	; 0xc50 <every10ms+0x54>
			IR_Update(&ir_sensor[i], raw_input[i]);
		}
		count40ms = 4;
     c78:	84 e0       	ldi	r24, 0x04	; 4
     c7a:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <count40ms>
		newBox(globalDistance);
     c7e:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <globalDistance>
     c82:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <globalDistance+0x1>
     c86:	0e 94 3a 05 	call	0xa74	; 0xa74 <newBox>
		kickBox();
     c8a:	0e 94 63 05 	call	0xac6	; 0xac6 <kickBox>
	}
	if (!count200ms){
     c8e:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count200ms>
     c92:	81 11       	cpse	r24, r1
     c94:	05 c0       	rjmp	.+10     	; 0xca0 <every10ms+0xa4>
		servoreset();
     c96:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <servoreset>
		count200ms = 100;
     c9a:	84 e6       	ldi	r24, 0x64	; 100
     c9c:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <count200ms>
		//waittt = 1;
	}
	raw_input[0] = (PIND & (1<<IR0)) ? 1 : 0;
     ca0:	89 b1       	in	r24, 0x09	; 9
     ca2:	82 fb       	bst	r24, 2
     ca4:	88 27       	eor	r24, r24
     ca6:	80 f9       	bld	r24, 0
     ca8:	e7 e9       	ldi	r30, 0x97	; 151
     caa:	f2 e0       	ldi	r31, 0x02	; 2
     cac:	80 83       	st	Z, r24
	raw_input[1] = (PIND & (1<<IR1)) ? 1 : 0;
     cae:	89 b1       	in	r24, 0x09	; 9
     cb0:	83 fb       	bst	r24, 3
     cb2:	88 27       	eor	r24, r24
     cb4:	80 f9       	bld	r24, 0
     cb6:	81 83       	std	Z+1, r24	; 0x01
	raw_input[2] = (PIND & (1<<IR2)) ? 1 : 0;
     cb8:	89 b1       	in	r24, 0x09	; 9
     cba:	82 95       	swap	r24
     cbc:	81 70       	andi	r24, 0x01	; 1
     cbe:	82 83       	std	Z+2, r24	; 0x02
	raw_input[3] = (PIND & (1<<IR3)) ? 1 : 0;
     cc0:	89 b1       	in	r24, 0x09	; 9
     cc2:	85 fb       	bst	r24, 5
     cc4:	88 27       	eor	r24, r24
     cc6:	80 f9       	bld	r24, 0
     cc8:	83 83       	std	Z+3, r24	; 0x03
	
	IS10MS = FALSE;
     cca:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     cce:	8e 7f       	andi	r24, 0xFE	; 254
     cd0:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
	count100ms--;
     cd4:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <count100ms>
     cd8:	81 50       	subi	r24, 0x01	; 1
     cda:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <count100ms>
	count40ms--;
     cde:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <count40ms>
     ce2:	81 50       	subi	r24, 0x01	; 1
     ce4:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <count40ms>
	count200ms--;
     ce8:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count200ms>
     cec:	81 50       	subi	r24, 0x01	; 1
     cee:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <count200ms>
}
     cf2:	df 91       	pop	r29
     cf4:	cf 91       	pop	r28
     cf6:	08 95       	ret

00000cf8 <main>:
}
/* END Function prototypes user code ------------------------------------------*/

int main(){
	
	cli();
     cf8:	f8 94       	cli

	/* END Local variables -------------------------------------------------------*/


	/* User code Init ------------------------------------------------------------*/
	flag0.byte = 0;
     cfa:	10 92 96 02 	sts	0x0296, r1	; 0x800296 <flag0>
	
	ini_ports();
     cfe:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <ini_ports>
	ini_timer1();
     d02:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <ini_timer1>
	ini_timer0();
     d06:	0e 94 fd 01 	call	0x3fa	; 0x3fa <ini_timer0>
	ini_USART(16);
     d0a:	80 e1       	ldi	r24, 0x10	; 16
     d0c:	0e 94 07 02 	call	0x40e	; 0x40e <ini_USART>
	
	IR_Init(&ir_sensor[0]);
     d10:	80 ea       	ldi	r24, 0xA0	; 160
     d12:	92 e0       	ldi	r25, 0x02	; 2
     d14:	0e 94 15 02 	call	0x42a	; 0x42a <IR_Init>
	stdout = &usart_output;
     d18:	8d e0       	ldi	r24, 0x0D	; 13
     d1a:	91 e0       	ldi	r25, 0x01	; 1
     d1c:	90 93 11 04 	sts	0x0411, r25	; 0x800411 <__iob+0x3>
     d20:	80 93 10 04 	sts	0x0410, r24	; 0x800410 <__iob+0x2>
	
	addServo(&PORTD,SV0);
     d24:	67 e0       	ldi	r22, 0x07	; 7
     d26:	8b e2       	ldi	r24, 0x2B	; 43
     d28:	90 e0       	ldi	r25, 0x00	; 0
     d2a:	0e 94 16 07 	call	0xe2c	; 0xe2c <addServo>
	addServo(&PORTB,SV1);
     d2e:	64 e0       	ldi	r22, 0x04	; 4
     d30:	85 e2       	ldi	r24, 0x25	; 37
     d32:	90 e0       	ldi	r25, 0x00	; 0
     d34:	0e 94 16 07 	call	0xe2c	; 0xe2c <addServo>
	addServo(&PORTB,SV2);
     d38:	63 e0       	ldi	r22, 0x03	; 3
     d3a:	85 e2       	ldi	r24, 0x25	; 37
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	0e 94 16 07 	call	0xe2c	; 0xe2c <addServo>
	servo_Angle(0,90);
     d42:	6a e5       	ldi	r22, 0x5A	; 90
     d44:	80 e0       	ldi	r24, 0x00	; 0
     d46:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
	servo_Angle(1,90);
     d4a:	6a e5       	ldi	r22, 0x5A	; 90
     d4c:	81 e0       	ldi	r24, 0x01	; 1
     d4e:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
	servo_Angle(2,90);
     d52:	6a e5       	ldi	r22, 0x5A	; 90
     d54:	82 e0       	ldi	r24, 0x02	; 2
     d56:	0e 94 2a 07 	call	0xe54	; 0xe54 <servo_Angle>
	HCSR_1 = HCSR04_AddNew(&WritePin_HCSR, 16);
     d5a:	40 e1       	ldi	r20, 0x10	; 16
     d5c:	50 e0       	ldi	r21, 0x00	; 0
     d5e:	60 e0       	ldi	r22, 0x00	; 0
     d60:	70 e0       	ldi	r23, 0x00	; 0
     d62:	88 ed       	ldi	r24, 0xD8	; 216
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	0e 94 5a 00 	call	0xb4	; 0xb4 <HCSR04_AddNew>
     d6a:	a0 e0       	ldi	r26, 0x00	; 0
     d6c:	b0 e0       	ldi	r27, 0x00	; 0
     d6e:	80 93 74 01 	sts	0x0174, r24	; 0x800174 <HCSR_1>
     d72:	90 93 75 01 	sts	0x0175, r25	; 0x800175 <HCSR_1+0x1>
     d76:	a0 93 76 01 	sts	0x0176, r26	; 0x800176 <HCSR_1+0x2>
     d7a:	b0 93 77 01 	sts	0x0177, r27	; 0x800177 <HCSR_1+0x3>
	
	Numbox = 255;
     d7e:	8f ef       	ldi	r24, 0xFF	; 255
     d80:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <Numbox>
	
	dataRx.buff = (uint8_t *)buffRx;
     d84:	e5 e8       	ldi	r30, 0x85	; 133
     d86:	f2 e0       	ldi	r31, 0x02	; 2
     d88:	29 e7       	ldi	r18, 0x79	; 121
     d8a:	31 e0       	ldi	r19, 0x01	; 1
     d8c:	31 83       	std	Z+1, r19	; 0x01
     d8e:	20 83       	st	Z, r18
	dataRx.indexR = 0;
     d90:	12 82       	std	Z+2, r1	; 0x02
	dataRx.indexW = 0;
     d92:	13 82       	std	Z+3, r1	; 0x03
	dataRx.header = HEADER_U;
     d94:	10 86       	std	Z+8, r1	; 0x08
	dataRx.mask = RXBUFSIZE - 1;
     d96:	85 83       	std	Z+5, r24	; 0x05
	
	dataTx.buff = buffTx;
     d98:	e0 e9       	ldi	r30, 0x90	; 144
     d9a:	f2 e0       	ldi	r31, 0x02	; 2
     d9c:	2c ee       	ldi	r18, 0xEC	; 236
     d9e:	32 e0       	ldi	r19, 0x02	; 2
     da0:	31 83       	std	Z+1, r19	; 0x01
     da2:	20 83       	st	Z, r18
	dataTx.indexR = 0;
     da4:	12 82       	std	Z+2, r1	; 0x02
	dataTx.indexW = 0;
     da6:	13 82       	std	Z+3, r1	; 0x03
	dataTx.mask = TXBUFSIZE -1;
     da8:	84 83       	std	Z+4, r24	; 0x04
	
	boxSizeconfig.smallboxF=Cm15;
     daa:	e9 e7       	ldi	r30, 0x79	; 121
     dac:	f2 e0       	ldi	r31, 0x02	; 2
     dae:	86 e6       	ldi	r24, 0x66	; 102
     db0:	93 e0       	ldi	r25, 0x03	; 3
     db2:	91 83       	std	Z+1, r25	; 0x01
     db4:	80 83       	st	Z, r24
	boxSizeconfig.smallboxC=Cm13;
     db6:	82 ef       	ldi	r24, 0xF2	; 242
     db8:	92 e0       	ldi	r25, 0x02	; 2
     dba:	93 83       	std	Z+3, r25	; 0x03
     dbc:	82 83       	std	Z+2, r24	; 0x02
	boxSizeconfig.mediumboxF=Cm13;
     dbe:	95 83       	std	Z+5, r25	; 0x05
     dc0:	84 83       	std	Z+4, r24	; 0x04
	boxSizeconfig.mediumboxC=Cm11;
     dc2:	8e e7       	ldi	r24, 0x7E	; 126
     dc4:	92 e0       	ldi	r25, 0x02	; 2
     dc6:	97 83       	std	Z+7, r25	; 0x07
     dc8:	86 83       	std	Z+6, r24	; 0x06
	boxSizeconfig.largeboxF=Cm11;
     dca:	91 87       	std	Z+9, r25	; 0x09
     dcc:	80 87       	std	Z+8, r24	; 0x08
	boxSizeconfig.largeboxC=Cm9;
     dce:	8a e0       	ldi	r24, 0x0A	; 10
     dd0:	92 e0       	ldi	r25, 0x02	; 2
     dd2:	93 87       	std	Z+11, r25	; 0x0b
     dd4:	82 87       	std	Z+10, r24	; 0x0a
	
	ir_sensor[1].irType = SmallBox;
     dd6:	e0 ea       	ldi	r30, 0xA0	; 160
     dd8:	f2 e0       	ldi	r31, 0x02	; 2
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	87 83       	std	Z+7, r24	; 0x07
	ir_sensor[2].irType = MediumBox;
     dde:	82 e0       	ldi	r24, 0x02	; 2
     de0:	83 87       	std	Z+11, r24	; 0x0b
	ir_sensor[3].irType = LargeBox;
     de2:	83 e0       	ldi	r24, 0x03	; 3
     de4:	87 87       	std	Z+15, r24	; 0x0f
	
	for (uint8_t i = 0; i < 3; i++) {
     de6:	80 e0       	ldi	r24, 0x00	; 0
     de8:	0f c0       	rjmp	.+30     	; 0xe08 <main+0x110>
		for (uint8_t j = 0; j < 20; j++) {
			CajitaArr[i][j] = 0;
     dea:	24 e1       	ldi	r18, 0x14	; 20
     dec:	82 9f       	mul	r24, r18
     dee:	f0 01       	movw	r30, r0
     df0:	11 24       	eor	r1, r1
     df2:	e0 55       	subi	r30, 0x50	; 80
     df4:	fd 4f       	sbci	r31, 0xFD	; 253
     df6:	e9 0f       	add	r30, r25
     df8:	f1 1d       	adc	r31, r1
     dfa:	10 82       	st	Z, r1
	ir_sensor[1].irType = SmallBox;
	ir_sensor[2].irType = MediumBox;
	ir_sensor[3].irType = LargeBox;
	
	for (uint8_t i = 0; i < 3; i++) {
		for (uint8_t j = 0; j < 20; j++) {
     dfc:	9f 5f       	subi	r25, 0xFF	; 255
     dfe:	01 c0       	rjmp	.+2      	; 0xe02 <main+0x10a>
     e00:	90 e0       	ldi	r25, 0x00	; 0
     e02:	94 31       	cpi	r25, 0x14	; 20
     e04:	90 f3       	brcs	.-28     	; 0xdea <main+0xf2>
	
	ir_sensor[1].irType = SmallBox;
	ir_sensor[2].irType = MediumBox;
	ir_sensor[3].irType = LargeBox;
	
	for (uint8_t i = 0; i < 3; i++) {
     e06:	8f 5f       	subi	r24, 0xFF	; 255
     e08:	83 30       	cpi	r24, 0x03	; 3
     e0a:	d0 f3       	brcs	.-12     	; 0xe00 <main+0x108>
			CajitaArr[i][j] = 0;
		}
	}
	
	/* END User code Init --------------------------------------------------------*/
	sei();
     e0c:	78 94       	sei

	while (1){
		/* User Code loop ------------------------------------------------------------*/
		task_HCSR();
     e0e:	0e 94 af 00 	call	0x15e	; 0x15e <task_HCSR>
		serialTask(&dataRx,&dataTx);
     e12:	60 e9       	ldi	r22, 0x90	; 144
     e14:	72 e0       	ldi	r23, 0x02	; 2
     e16:	85 e8       	ldi	r24, 0x85	; 133
     e18:	92 e0       	ldi	r25, 0x02	; 2
     e1a:	0e 94 13 04 	call	0x826	; 0x826 <serialTask>
		if (IS10MS)
     e1e:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     e22:	80 ff       	sbrs	r24, 0
     e24:	f4 cf       	rjmp	.-24     	; 0xe0e <main+0x116>
			every10ms();
     e26:	0e 94 fe 05 	call	0xbfc	; 0xbfc <every10ms>
     e2a:	f1 cf       	rjmp	.-30     	; 0xe0e <main+0x116>

00000e2c <addServo>:
static uint8_t ServN = 0;
volatile static uint8_t is20ms=156;
 
void addServo(volatile uint8_t* PORT,uint8_t Pin){
	
	servoHandle[ServN].pin=Pin;
     e2c:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <ServN>
     e30:	e2 2f       	mov	r30, r18
     e32:	f0 e0       	ldi	r31, 0x00	; 0
     e34:	af 01       	movw	r20, r30
     e36:	44 0f       	add	r20, r20
     e38:	55 1f       	adc	r21, r21
     e3a:	44 0f       	add	r20, r20
     e3c:	55 1f       	adc	r21, r21
     e3e:	e4 0f       	add	r30, r20
     e40:	f5 1f       	adc	r31, r21
     e42:	eb 59       	subi	r30, 0x9B	; 155
     e44:	fe 4f       	sbci	r31, 0xFE	; 254
     e46:	62 83       	std	Z+2, r22	; 0x02
	servoHandle[ServN].port=PORT;
     e48:	91 83       	std	Z+1, r25	; 0x01
     e4a:	80 83       	st	Z, r24
	ServN++;
     e4c:	2f 5f       	subi	r18, 0xFF	; 255
     e4e:	20 93 64 01 	sts	0x0164, r18	; 0x800164 <ServN>
     e52:	08 95       	ret

00000e54 <servo_Angle>:
}
void servo_Angle(uint8_t servo,uint8_t angulo){
     e54:	48 2f       	mov	r20, r24
	
	uint16_t riseValue;
	
	riseValue = (uint16_t)angulo * ANGLE_TO_PWM_SLOPE;
     e56:	85 e7       	ldi	r24, 0x75	; 117
     e58:	68 9f       	mul	r22, r24
     e5a:	90 01       	movw	r18, r0
     e5c:	11 24       	eor	r1, r1
	riseValue += ANGLE_TO_PWM_OFFSET;
     e5e:	2e 5c       	subi	r18, 0xCE	; 206
     e60:	36 4d       	sbci	r19, 0xD6	; 214
	riseValue /= 180;
     e62:	a3 e8       	ldi	r26, 0x83	; 131
     e64:	bd e2       	ldi	r27, 0x2D	; 45
     e66:	0e 94 bb 07 	call	0xf76	; 0xf76 <__umulhisi3>
     e6a:	96 95       	lsr	r25
     e6c:	87 95       	ror	r24
     e6e:	92 95       	swap	r25
     e70:	82 95       	swap	r24
     e72:	8f 70       	andi	r24, 0x0F	; 15
     e74:	89 27       	eor	r24, r25
     e76:	9f 70       	andi	r25, 0x0F	; 15
     e78:	89 27       	eor	r24, r25
	riseValue += ROUNDING_CORRECTION;
     e7a:	9c 01       	movw	r18, r24
     e7c:	2b 5f       	subi	r18, 0xFB	; 251
     e7e:	3f 4f       	sbci	r19, 0xFF	; 255
	riseValue /= 10;
     e80:	ad ec       	ldi	r26, 0xCD	; 205
     e82:	bc ec       	ldi	r27, 0xCC	; 204
     e84:	0e 94 bb 07 	call	0xf76	; 0xf76 <__umulhisi3>
     e88:	96 95       	lsr	r25
     e8a:	87 95       	ror	r24
     e8c:	96 95       	lsr	r25
     e8e:	87 95       	ror	r24
     e90:	96 95       	lsr	r25
     e92:	87 95       	ror	r24
		
	servoHandle[servo].dutyCycle = (uint8_t)riseValue;
     e94:	24 2f       	mov	r18, r20
     e96:	30 e0       	ldi	r19, 0x00	; 0
     e98:	f9 01       	movw	r30, r18
     e9a:	ee 0f       	add	r30, r30
     e9c:	ff 1f       	adc	r31, r31
     e9e:	ee 0f       	add	r30, r30
     ea0:	ff 1f       	adc	r31, r31
     ea2:	2e 0f       	add	r18, r30
     ea4:	3f 1f       	adc	r19, r31
     ea6:	f9 01       	movw	r30, r18
     ea8:	eb 59       	subi	r30, 0x9B	; 155
     eaa:	fe 4f       	sbci	r31, 0xFE	; 254
     eac:	84 83       	std	Z+4, r24	; 0x04
     eae:	08 95       	ret

00000eb0 <writeServo>:
}

void writeServo(){
	is20ms--;
     eb0:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <is20ms>
     eb4:	81 50       	subi	r24, 0x01	; 1
     eb6:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <is20ms>
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     eba:	20 e0       	ldi	r18, 0x00	; 0
     ebc:	2a c0       	rjmp	.+84     	; 0xf12 <writeServo+0x62>
		servoHandle[counter].cycle--;
     ebe:	82 2f       	mov	r24, r18
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	fc 01       	movw	r30, r24
     ec4:	ee 0f       	add	r30, r30
     ec6:	ff 1f       	adc	r31, r31
     ec8:	ee 0f       	add	r30, r30
     eca:	ff 1f       	adc	r31, r31
     ecc:	e8 0f       	add	r30, r24
     ece:	f9 1f       	adc	r31, r25
     ed0:	eb 59       	subi	r30, 0x9B	; 155
     ed2:	fe 4f       	sbci	r31, 0xFE	; 254
     ed4:	33 81       	ldd	r19, Z+3	; 0x03
     ed6:	31 50       	subi	r19, 0x01	; 1
     ed8:	33 83       	std	Z+3, r19	; 0x03
		if(!servoHandle[counter].cycle)
     eda:	33 81       	ldd	r19, Z+3	; 0x03
     edc:	31 11       	cpse	r19, r1
     ede:	18 c0       	rjmp	.+48     	; 0xf10 <writeServo+0x60>
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
     ee0:	fc 01       	movw	r30, r24
     ee2:	ee 0f       	add	r30, r30
     ee4:	ff 1f       	adc	r31, r31
     ee6:	ee 0f       	add	r30, r30
     ee8:	ff 1f       	adc	r31, r31
     eea:	8e 0f       	add	r24, r30
     eec:	9f 1f       	adc	r25, r31
     eee:	fc 01       	movw	r30, r24
     ef0:	eb 59       	subi	r30, 0x9B	; 155
     ef2:	fe 4f       	sbci	r31, 0xFE	; 254
     ef4:	a0 81       	ld	r26, Z
     ef6:	b1 81       	ldd	r27, Z+1	; 0x01
     ef8:	3c 91       	ld	r19, X
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	02 80       	ldd	r0, Z+2	; 0x02
     f00:	02 c0       	rjmp	.+4      	; 0xf06 <writeServo+0x56>
     f02:	88 0f       	add	r24, r24
     f04:	99 1f       	adc	r25, r25
     f06:	0a 94       	dec	r0
     f08:	e2 f7       	brpl	.-8      	; 0xf02 <writeServo+0x52>
     f0a:	80 95       	com	r24
     f0c:	83 23       	and	r24, r19
     f0e:	8c 93       	st	X, r24
void writeServo(){
	is20ms--;
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     f10:	2f 5f       	subi	r18, 0xFF	; 255
     f12:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <ServN>
     f16:	28 17       	cp	r18, r24
     f18:	90 f2       	brcs	.-92     	; 0xebe <writeServo+0xe>
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
     f1a:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <is20ms>
     f1e:	99 23       	and	r25, r25
     f20:	e9 f0       	breq	.+58     	; 0xf5c <writeServo+0xac>
     f22:	08 95       	ret
		for(counter = 0; counter < ServN; counter++){
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
     f24:	e9 2f       	mov	r30, r25
     f26:	f0 e0       	ldi	r31, 0x00	; 0
     f28:	9f 01       	movw	r18, r30
     f2a:	22 0f       	add	r18, r18
     f2c:	33 1f       	adc	r19, r19
     f2e:	22 0f       	add	r18, r18
     f30:	33 1f       	adc	r19, r19
     f32:	e2 0f       	add	r30, r18
     f34:	f3 1f       	adc	r31, r19
     f36:	eb 59       	subi	r30, 0x9B	; 155
     f38:	fe 4f       	sbci	r31, 0xFE	; 254
     f3a:	24 81       	ldd	r18, Z+4	; 0x04
     f3c:	23 83       	std	Z+3, r18	; 0x03
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
     f3e:	a0 81       	ld	r26, Z
     f40:	b1 81       	ldd	r27, Z+1	; 0x01
     f42:	4c 91       	ld	r20, X
     f44:	21 e0       	ldi	r18, 0x01	; 1
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	02 80       	ldd	r0, Z+2	; 0x02
     f4a:	02 c0       	rjmp	.+4      	; 0xf50 <writeServo+0xa0>
     f4c:	22 0f       	add	r18, r18
     f4e:	33 1f       	adc	r19, r19
     f50:	0a 94       	dec	r0
     f52:	e2 f7       	brpl	.-8      	; 0xf4c <writeServo+0x9c>
     f54:	24 2b       	or	r18, r20
     f56:	2c 93       	st	X, r18
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
		for(counter = 0; counter < ServN; counter++){
     f58:	9f 5f       	subi	r25, 0xFF	; 255
     f5a:	01 c0       	rjmp	.+2      	; 0xf5e <writeServo+0xae>
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	98 17       	cp	r25, r24
     f60:	08 f3       	brcs	.-62     	; 0xf24 <writeServo+0x74>
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
		}
		is20ms = 156;
     f62:	8c e9       	ldi	r24, 0x9C	; 156
     f64:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <is20ms>
     f68:	08 95       	ret

00000f6a <__tablejump2__>:
     f6a:	ee 0f       	add	r30, r30
     f6c:	ff 1f       	adc	r31, r31
     f6e:	05 90       	lpm	r0, Z+
     f70:	f4 91       	lpm	r31, Z
     f72:	e0 2d       	mov	r30, r0
     f74:	09 94       	ijmp

00000f76 <__umulhisi3>:
     f76:	a2 9f       	mul	r26, r18
     f78:	b0 01       	movw	r22, r0
     f7a:	b3 9f       	mul	r27, r19
     f7c:	c0 01       	movw	r24, r0
     f7e:	a3 9f       	mul	r26, r19
     f80:	70 0d       	add	r23, r0
     f82:	81 1d       	adc	r24, r1
     f84:	11 24       	eor	r1, r1
     f86:	91 1d       	adc	r25, r1
     f88:	b2 9f       	mul	r27, r18
     f8a:	70 0d       	add	r23, r0
     f8c:	81 1d       	adc	r24, r1
     f8e:	11 24       	eor	r1, r1
     f90:	91 1d       	adc	r25, r1
     f92:	08 95       	ret

00000f94 <malloc>:
     f94:	0f 93       	push	r16
     f96:	1f 93       	push	r17
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	82 30       	cpi	r24, 0x02	; 2
     f9e:	91 05       	cpc	r25, r1
     fa0:	10 f4       	brcc	.+4      	; 0xfa6 <malloc+0x12>
     fa2:	82 e0       	ldi	r24, 0x02	; 2
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	e0 91 0c 04 	lds	r30, 0x040C	; 0x80040c <__flp>
     faa:	f0 91 0d 04 	lds	r31, 0x040D	; 0x80040d <__flp+0x1>
     fae:	20 e0       	ldi	r18, 0x00	; 0
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	a0 e0       	ldi	r26, 0x00	; 0
     fb4:	b0 e0       	ldi	r27, 0x00	; 0
     fb6:	30 97       	sbiw	r30, 0x00	; 0
     fb8:	19 f1       	breq	.+70     	; 0x1000 <malloc+0x6c>
     fba:	40 81       	ld	r20, Z
     fbc:	51 81       	ldd	r21, Z+1	; 0x01
     fbe:	02 81       	ldd	r16, Z+2	; 0x02
     fc0:	13 81       	ldd	r17, Z+3	; 0x03
     fc2:	48 17       	cp	r20, r24
     fc4:	59 07       	cpc	r21, r25
     fc6:	c8 f0       	brcs	.+50     	; 0xffa <malloc+0x66>
     fc8:	84 17       	cp	r24, r20
     fca:	95 07       	cpc	r25, r21
     fcc:	69 f4       	brne	.+26     	; 0xfe8 <malloc+0x54>
     fce:	10 97       	sbiw	r26, 0x00	; 0
     fd0:	31 f0       	breq	.+12     	; 0xfde <malloc+0x4a>
     fd2:	12 96       	adiw	r26, 0x02	; 2
     fd4:	0c 93       	st	X, r16
     fd6:	12 97       	sbiw	r26, 0x02	; 2
     fd8:	13 96       	adiw	r26, 0x03	; 3
     fda:	1c 93       	st	X, r17
     fdc:	27 c0       	rjmp	.+78     	; 0x102c <malloc+0x98>
     fde:	00 93 0c 04 	sts	0x040C, r16	; 0x80040c <__flp>
     fe2:	10 93 0d 04 	sts	0x040D, r17	; 0x80040d <__flp+0x1>
     fe6:	22 c0       	rjmp	.+68     	; 0x102c <malloc+0x98>
     fe8:	21 15       	cp	r18, r1
     fea:	31 05       	cpc	r19, r1
     fec:	19 f0       	breq	.+6      	; 0xff4 <malloc+0x60>
     fee:	42 17       	cp	r20, r18
     ff0:	53 07       	cpc	r21, r19
     ff2:	18 f4       	brcc	.+6      	; 0xffa <malloc+0x66>
     ff4:	9a 01       	movw	r18, r20
     ff6:	bd 01       	movw	r22, r26
     ff8:	ef 01       	movw	r28, r30
     ffa:	df 01       	movw	r26, r30
     ffc:	f8 01       	movw	r30, r16
     ffe:	db cf       	rjmp	.-74     	; 0xfb6 <malloc+0x22>
    1000:	21 15       	cp	r18, r1
    1002:	31 05       	cpc	r19, r1
    1004:	f9 f0       	breq	.+62     	; 0x1044 <malloc+0xb0>
    1006:	28 1b       	sub	r18, r24
    1008:	39 0b       	sbc	r19, r25
    100a:	24 30       	cpi	r18, 0x04	; 4
    100c:	31 05       	cpc	r19, r1
    100e:	80 f4       	brcc	.+32     	; 0x1030 <malloc+0x9c>
    1010:	8a 81       	ldd	r24, Y+2	; 0x02
    1012:	9b 81       	ldd	r25, Y+3	; 0x03
    1014:	61 15       	cp	r22, r1
    1016:	71 05       	cpc	r23, r1
    1018:	21 f0       	breq	.+8      	; 0x1022 <malloc+0x8e>
    101a:	fb 01       	movw	r30, r22
    101c:	93 83       	std	Z+3, r25	; 0x03
    101e:	82 83       	std	Z+2, r24	; 0x02
    1020:	04 c0       	rjmp	.+8      	; 0x102a <malloc+0x96>
    1022:	90 93 0d 04 	sts	0x040D, r25	; 0x80040d <__flp+0x1>
    1026:	80 93 0c 04 	sts	0x040C, r24	; 0x80040c <__flp>
    102a:	fe 01       	movw	r30, r28
    102c:	32 96       	adiw	r30, 0x02	; 2
    102e:	44 c0       	rjmp	.+136    	; 0x10b8 <malloc+0x124>
    1030:	fe 01       	movw	r30, r28
    1032:	e2 0f       	add	r30, r18
    1034:	f3 1f       	adc	r31, r19
    1036:	81 93       	st	Z+, r24
    1038:	91 93       	st	Z+, r25
    103a:	22 50       	subi	r18, 0x02	; 2
    103c:	31 09       	sbc	r19, r1
    103e:	39 83       	std	Y+1, r19	; 0x01
    1040:	28 83       	st	Y, r18
    1042:	3a c0       	rjmp	.+116    	; 0x10b8 <malloc+0x124>
    1044:	20 91 0a 04 	lds	r18, 0x040A	; 0x80040a <__brkval>
    1048:	30 91 0b 04 	lds	r19, 0x040B	; 0x80040b <__brkval+0x1>
    104c:	23 2b       	or	r18, r19
    104e:	41 f4       	brne	.+16     	; 0x1060 <malloc+0xcc>
    1050:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1054:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1058:	30 93 0b 04 	sts	0x040B, r19	; 0x80040b <__brkval+0x1>
    105c:	20 93 0a 04 	sts	0x040A, r18	; 0x80040a <__brkval>
    1060:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    1064:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    1068:	21 15       	cp	r18, r1
    106a:	31 05       	cpc	r19, r1
    106c:	41 f4       	brne	.+16     	; 0x107e <malloc+0xea>
    106e:	2d b7       	in	r18, 0x3d	; 61
    1070:	3e b7       	in	r19, 0x3e	; 62
    1072:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1076:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    107a:	24 1b       	sub	r18, r20
    107c:	35 0b       	sbc	r19, r21
    107e:	e0 91 0a 04 	lds	r30, 0x040A	; 0x80040a <__brkval>
    1082:	f0 91 0b 04 	lds	r31, 0x040B	; 0x80040b <__brkval+0x1>
    1086:	e2 17       	cp	r30, r18
    1088:	f3 07       	cpc	r31, r19
    108a:	a0 f4       	brcc	.+40     	; 0x10b4 <malloc+0x120>
    108c:	2e 1b       	sub	r18, r30
    108e:	3f 0b       	sbc	r19, r31
    1090:	28 17       	cp	r18, r24
    1092:	39 07       	cpc	r19, r25
    1094:	78 f0       	brcs	.+30     	; 0x10b4 <malloc+0x120>
    1096:	ac 01       	movw	r20, r24
    1098:	4e 5f       	subi	r20, 0xFE	; 254
    109a:	5f 4f       	sbci	r21, 0xFF	; 255
    109c:	24 17       	cp	r18, r20
    109e:	35 07       	cpc	r19, r21
    10a0:	48 f0       	brcs	.+18     	; 0x10b4 <malloc+0x120>
    10a2:	4e 0f       	add	r20, r30
    10a4:	5f 1f       	adc	r21, r31
    10a6:	50 93 0b 04 	sts	0x040B, r21	; 0x80040b <__brkval+0x1>
    10aa:	40 93 0a 04 	sts	0x040A, r20	; 0x80040a <__brkval>
    10ae:	81 93       	st	Z+, r24
    10b0:	91 93       	st	Z+, r25
    10b2:	02 c0       	rjmp	.+4      	; 0x10b8 <malloc+0x124>
    10b4:	e0 e0       	ldi	r30, 0x00	; 0
    10b6:	f0 e0       	ldi	r31, 0x00	; 0
    10b8:	cf 01       	movw	r24, r30
    10ba:	df 91       	pop	r29
    10bc:	cf 91       	pop	r28
    10be:	1f 91       	pop	r17
    10c0:	0f 91       	pop	r16
    10c2:	08 95       	ret

000010c4 <free>:
    10c4:	cf 93       	push	r28
    10c6:	df 93       	push	r29
    10c8:	00 97       	sbiw	r24, 0x00	; 0
    10ca:	09 f4       	brne	.+2      	; 0x10ce <free+0xa>
    10cc:	81 c0       	rjmp	.+258    	; 0x11d0 <free+0x10c>
    10ce:	fc 01       	movw	r30, r24
    10d0:	32 97       	sbiw	r30, 0x02	; 2
    10d2:	13 82       	std	Z+3, r1	; 0x03
    10d4:	12 82       	std	Z+2, r1	; 0x02
    10d6:	a0 91 0c 04 	lds	r26, 0x040C	; 0x80040c <__flp>
    10da:	b0 91 0d 04 	lds	r27, 0x040D	; 0x80040d <__flp+0x1>
    10de:	10 97       	sbiw	r26, 0x00	; 0
    10e0:	81 f4       	brne	.+32     	; 0x1102 <free+0x3e>
    10e2:	20 81       	ld	r18, Z
    10e4:	31 81       	ldd	r19, Z+1	; 0x01
    10e6:	82 0f       	add	r24, r18
    10e8:	93 1f       	adc	r25, r19
    10ea:	20 91 0a 04 	lds	r18, 0x040A	; 0x80040a <__brkval>
    10ee:	30 91 0b 04 	lds	r19, 0x040B	; 0x80040b <__brkval+0x1>
    10f2:	28 17       	cp	r18, r24
    10f4:	39 07       	cpc	r19, r25
    10f6:	51 f5       	brne	.+84     	; 0x114c <free+0x88>
    10f8:	f0 93 0b 04 	sts	0x040B, r31	; 0x80040b <__brkval+0x1>
    10fc:	e0 93 0a 04 	sts	0x040A, r30	; 0x80040a <__brkval>
    1100:	67 c0       	rjmp	.+206    	; 0x11d0 <free+0x10c>
    1102:	ed 01       	movw	r28, r26
    1104:	20 e0       	ldi	r18, 0x00	; 0
    1106:	30 e0       	ldi	r19, 0x00	; 0
    1108:	ce 17       	cp	r28, r30
    110a:	df 07       	cpc	r29, r31
    110c:	40 f4       	brcc	.+16     	; 0x111e <free+0x5a>
    110e:	4a 81       	ldd	r20, Y+2	; 0x02
    1110:	5b 81       	ldd	r21, Y+3	; 0x03
    1112:	9e 01       	movw	r18, r28
    1114:	41 15       	cp	r20, r1
    1116:	51 05       	cpc	r21, r1
    1118:	f1 f0       	breq	.+60     	; 0x1156 <free+0x92>
    111a:	ea 01       	movw	r28, r20
    111c:	f5 cf       	rjmp	.-22     	; 0x1108 <free+0x44>
    111e:	d3 83       	std	Z+3, r29	; 0x03
    1120:	c2 83       	std	Z+2, r28	; 0x02
    1122:	40 81       	ld	r20, Z
    1124:	51 81       	ldd	r21, Z+1	; 0x01
    1126:	84 0f       	add	r24, r20
    1128:	95 1f       	adc	r25, r21
    112a:	c8 17       	cp	r28, r24
    112c:	d9 07       	cpc	r29, r25
    112e:	59 f4       	brne	.+22     	; 0x1146 <free+0x82>
    1130:	88 81       	ld	r24, Y
    1132:	99 81       	ldd	r25, Y+1	; 0x01
    1134:	84 0f       	add	r24, r20
    1136:	95 1f       	adc	r25, r21
    1138:	02 96       	adiw	r24, 0x02	; 2
    113a:	91 83       	std	Z+1, r25	; 0x01
    113c:	80 83       	st	Z, r24
    113e:	8a 81       	ldd	r24, Y+2	; 0x02
    1140:	9b 81       	ldd	r25, Y+3	; 0x03
    1142:	93 83       	std	Z+3, r25	; 0x03
    1144:	82 83       	std	Z+2, r24	; 0x02
    1146:	21 15       	cp	r18, r1
    1148:	31 05       	cpc	r19, r1
    114a:	29 f4       	brne	.+10     	; 0x1156 <free+0x92>
    114c:	f0 93 0d 04 	sts	0x040D, r31	; 0x80040d <__flp+0x1>
    1150:	e0 93 0c 04 	sts	0x040C, r30	; 0x80040c <__flp>
    1154:	3d c0       	rjmp	.+122    	; 0x11d0 <free+0x10c>
    1156:	e9 01       	movw	r28, r18
    1158:	fb 83       	std	Y+3, r31	; 0x03
    115a:	ea 83       	std	Y+2, r30	; 0x02
    115c:	49 91       	ld	r20, Y+
    115e:	59 91       	ld	r21, Y+
    1160:	c4 0f       	add	r28, r20
    1162:	d5 1f       	adc	r29, r21
    1164:	ec 17       	cp	r30, r28
    1166:	fd 07       	cpc	r31, r29
    1168:	61 f4       	brne	.+24     	; 0x1182 <free+0xbe>
    116a:	80 81       	ld	r24, Z
    116c:	91 81       	ldd	r25, Z+1	; 0x01
    116e:	84 0f       	add	r24, r20
    1170:	95 1f       	adc	r25, r21
    1172:	02 96       	adiw	r24, 0x02	; 2
    1174:	e9 01       	movw	r28, r18
    1176:	99 83       	std	Y+1, r25	; 0x01
    1178:	88 83       	st	Y, r24
    117a:	82 81       	ldd	r24, Z+2	; 0x02
    117c:	93 81       	ldd	r25, Z+3	; 0x03
    117e:	9b 83       	std	Y+3, r25	; 0x03
    1180:	8a 83       	std	Y+2, r24	; 0x02
    1182:	e0 e0       	ldi	r30, 0x00	; 0
    1184:	f0 e0       	ldi	r31, 0x00	; 0
    1186:	12 96       	adiw	r26, 0x02	; 2
    1188:	8d 91       	ld	r24, X+
    118a:	9c 91       	ld	r25, X
    118c:	13 97       	sbiw	r26, 0x03	; 3
    118e:	00 97       	sbiw	r24, 0x00	; 0
    1190:	19 f0       	breq	.+6      	; 0x1198 <free+0xd4>
    1192:	fd 01       	movw	r30, r26
    1194:	dc 01       	movw	r26, r24
    1196:	f7 cf       	rjmp	.-18     	; 0x1186 <free+0xc2>
    1198:	8d 91       	ld	r24, X+
    119a:	9c 91       	ld	r25, X
    119c:	11 97       	sbiw	r26, 0x01	; 1
    119e:	9d 01       	movw	r18, r26
    11a0:	2e 5f       	subi	r18, 0xFE	; 254
    11a2:	3f 4f       	sbci	r19, 0xFF	; 255
    11a4:	82 0f       	add	r24, r18
    11a6:	93 1f       	adc	r25, r19
    11a8:	20 91 0a 04 	lds	r18, 0x040A	; 0x80040a <__brkval>
    11ac:	30 91 0b 04 	lds	r19, 0x040B	; 0x80040b <__brkval+0x1>
    11b0:	28 17       	cp	r18, r24
    11b2:	39 07       	cpc	r19, r25
    11b4:	69 f4       	brne	.+26     	; 0x11d0 <free+0x10c>
    11b6:	30 97       	sbiw	r30, 0x00	; 0
    11b8:	29 f4       	brne	.+10     	; 0x11c4 <free+0x100>
    11ba:	10 92 0d 04 	sts	0x040D, r1	; 0x80040d <__flp+0x1>
    11be:	10 92 0c 04 	sts	0x040C, r1	; 0x80040c <__flp>
    11c2:	02 c0       	rjmp	.+4      	; 0x11c8 <free+0x104>
    11c4:	13 82       	std	Z+3, r1	; 0x03
    11c6:	12 82       	std	Z+2, r1	; 0x02
    11c8:	b0 93 0b 04 	sts	0x040B, r27	; 0x80040b <__brkval+0x1>
    11cc:	a0 93 0a 04 	sts	0x040A, r26	; 0x80040a <__brkval>
    11d0:	df 91       	pop	r29
    11d2:	cf 91       	pop	r28
    11d4:	08 95       	ret

000011d6 <printf>:
    11d6:	a0 e0       	ldi	r26, 0x00	; 0
    11d8:	b0 e0       	ldi	r27, 0x00	; 0
    11da:	e1 ef       	ldi	r30, 0xF1	; 241
    11dc:	f8 e0       	ldi	r31, 0x08	; 8
    11de:	0c 94 a9 0b 	jmp	0x1752	; 0x1752 <__prologue_saves__+0x20>
    11e2:	ae 01       	movw	r20, r28
    11e4:	4b 5f       	subi	r20, 0xFB	; 251
    11e6:	5f 4f       	sbci	r21, 0xFF	; 255
    11e8:	fa 01       	movw	r30, r20
    11ea:	61 91       	ld	r22, Z+
    11ec:	71 91       	ld	r23, Z+
    11ee:	af 01       	movw	r20, r30
    11f0:	80 91 10 04 	lds	r24, 0x0410	; 0x800410 <__iob+0x2>
    11f4:	90 91 11 04 	lds	r25, 0x0411	; 0x800411 <__iob+0x3>
    11f8:	0e 94 08 09 	call	0x1210	; 0x1210 <vfprintf>
    11fc:	e2 e0       	ldi	r30, 0x02	; 2
    11fe:	0c 94 c5 0b 	jmp	0x178a	; 0x178a <__epilogue_restores__+0x20>

00001202 <putchar>:
    1202:	60 91 10 04 	lds	r22, 0x0410	; 0x800410 <__iob+0x2>
    1206:	70 91 11 04 	lds	r23, 0x0411	; 0x800411 <__iob+0x3>
    120a:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    120e:	08 95       	ret

00001210 <vfprintf>:
    1210:	ab e0       	ldi	r26, 0x0B	; 11
    1212:	b0 e0       	ldi	r27, 0x00	; 0
    1214:	ee e0       	ldi	r30, 0x0E	; 14
    1216:	f9 e0       	ldi	r31, 0x09	; 9
    1218:	0c 94 99 0b 	jmp	0x1732	; 0x1732 <__prologue_saves__>
    121c:	6c 01       	movw	r12, r24
    121e:	7b 01       	movw	r14, r22
    1220:	8a 01       	movw	r16, r20
    1222:	fc 01       	movw	r30, r24
    1224:	17 82       	std	Z+7, r1	; 0x07
    1226:	16 82       	std	Z+6, r1	; 0x06
    1228:	83 81       	ldd	r24, Z+3	; 0x03
    122a:	81 ff       	sbrs	r24, 1
    122c:	cc c1       	rjmp	.+920    	; 0x15c6 <vfprintf+0x3b6>
    122e:	ce 01       	movw	r24, r28
    1230:	01 96       	adiw	r24, 0x01	; 1
    1232:	3c 01       	movw	r6, r24
    1234:	f6 01       	movw	r30, r12
    1236:	93 81       	ldd	r25, Z+3	; 0x03
    1238:	f7 01       	movw	r30, r14
    123a:	93 fd       	sbrc	r25, 3
    123c:	85 91       	lpm	r24, Z+
    123e:	93 ff       	sbrs	r25, 3
    1240:	81 91       	ld	r24, Z+
    1242:	7f 01       	movw	r14, r30
    1244:	88 23       	and	r24, r24
    1246:	09 f4       	brne	.+2      	; 0x124a <vfprintf+0x3a>
    1248:	ba c1       	rjmp	.+884    	; 0x15be <vfprintf+0x3ae>
    124a:	85 32       	cpi	r24, 0x25	; 37
    124c:	39 f4       	brne	.+14     	; 0x125c <vfprintf+0x4c>
    124e:	93 fd       	sbrc	r25, 3
    1250:	85 91       	lpm	r24, Z+
    1252:	93 ff       	sbrs	r25, 3
    1254:	81 91       	ld	r24, Z+
    1256:	7f 01       	movw	r14, r30
    1258:	85 32       	cpi	r24, 0x25	; 37
    125a:	29 f4       	brne	.+10     	; 0x1266 <vfprintf+0x56>
    125c:	b6 01       	movw	r22, r12
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    1264:	e7 cf       	rjmp	.-50     	; 0x1234 <vfprintf+0x24>
    1266:	91 2c       	mov	r9, r1
    1268:	21 2c       	mov	r2, r1
    126a:	31 2c       	mov	r3, r1
    126c:	ff e1       	ldi	r31, 0x1F	; 31
    126e:	f3 15       	cp	r31, r3
    1270:	d8 f0       	brcs	.+54     	; 0x12a8 <vfprintf+0x98>
    1272:	8b 32       	cpi	r24, 0x2B	; 43
    1274:	79 f0       	breq	.+30     	; 0x1294 <vfprintf+0x84>
    1276:	38 f4       	brcc	.+14     	; 0x1286 <vfprintf+0x76>
    1278:	80 32       	cpi	r24, 0x20	; 32
    127a:	79 f0       	breq	.+30     	; 0x129a <vfprintf+0x8a>
    127c:	83 32       	cpi	r24, 0x23	; 35
    127e:	a1 f4       	brne	.+40     	; 0x12a8 <vfprintf+0x98>
    1280:	23 2d       	mov	r18, r3
    1282:	20 61       	ori	r18, 0x10	; 16
    1284:	1d c0       	rjmp	.+58     	; 0x12c0 <vfprintf+0xb0>
    1286:	8d 32       	cpi	r24, 0x2D	; 45
    1288:	61 f0       	breq	.+24     	; 0x12a2 <vfprintf+0x92>
    128a:	80 33       	cpi	r24, 0x30	; 48
    128c:	69 f4       	brne	.+26     	; 0x12a8 <vfprintf+0x98>
    128e:	23 2d       	mov	r18, r3
    1290:	21 60       	ori	r18, 0x01	; 1
    1292:	16 c0       	rjmp	.+44     	; 0x12c0 <vfprintf+0xb0>
    1294:	83 2d       	mov	r24, r3
    1296:	82 60       	ori	r24, 0x02	; 2
    1298:	38 2e       	mov	r3, r24
    129a:	e3 2d       	mov	r30, r3
    129c:	e4 60       	ori	r30, 0x04	; 4
    129e:	3e 2e       	mov	r3, r30
    12a0:	2a c0       	rjmp	.+84     	; 0x12f6 <vfprintf+0xe6>
    12a2:	f3 2d       	mov	r31, r3
    12a4:	f8 60       	ori	r31, 0x08	; 8
    12a6:	1d c0       	rjmp	.+58     	; 0x12e2 <vfprintf+0xd2>
    12a8:	37 fc       	sbrc	r3, 7
    12aa:	2d c0       	rjmp	.+90     	; 0x1306 <vfprintf+0xf6>
    12ac:	20 ed       	ldi	r18, 0xD0	; 208
    12ae:	28 0f       	add	r18, r24
    12b0:	2a 30       	cpi	r18, 0x0A	; 10
    12b2:	40 f0       	brcs	.+16     	; 0x12c4 <vfprintf+0xb4>
    12b4:	8e 32       	cpi	r24, 0x2E	; 46
    12b6:	b9 f4       	brne	.+46     	; 0x12e6 <vfprintf+0xd6>
    12b8:	36 fc       	sbrc	r3, 6
    12ba:	81 c1       	rjmp	.+770    	; 0x15be <vfprintf+0x3ae>
    12bc:	23 2d       	mov	r18, r3
    12be:	20 64       	ori	r18, 0x40	; 64
    12c0:	32 2e       	mov	r3, r18
    12c2:	19 c0       	rjmp	.+50     	; 0x12f6 <vfprintf+0xe6>
    12c4:	36 fe       	sbrs	r3, 6
    12c6:	06 c0       	rjmp	.+12     	; 0x12d4 <vfprintf+0xc4>
    12c8:	8a e0       	ldi	r24, 0x0A	; 10
    12ca:	98 9e       	mul	r9, r24
    12cc:	20 0d       	add	r18, r0
    12ce:	11 24       	eor	r1, r1
    12d0:	92 2e       	mov	r9, r18
    12d2:	11 c0       	rjmp	.+34     	; 0x12f6 <vfprintf+0xe6>
    12d4:	ea e0       	ldi	r30, 0x0A	; 10
    12d6:	2e 9e       	mul	r2, r30
    12d8:	20 0d       	add	r18, r0
    12da:	11 24       	eor	r1, r1
    12dc:	22 2e       	mov	r2, r18
    12de:	f3 2d       	mov	r31, r3
    12e0:	f0 62       	ori	r31, 0x20	; 32
    12e2:	3f 2e       	mov	r3, r31
    12e4:	08 c0       	rjmp	.+16     	; 0x12f6 <vfprintf+0xe6>
    12e6:	8c 36       	cpi	r24, 0x6C	; 108
    12e8:	21 f4       	brne	.+8      	; 0x12f2 <vfprintf+0xe2>
    12ea:	83 2d       	mov	r24, r3
    12ec:	80 68       	ori	r24, 0x80	; 128
    12ee:	38 2e       	mov	r3, r24
    12f0:	02 c0       	rjmp	.+4      	; 0x12f6 <vfprintf+0xe6>
    12f2:	88 36       	cpi	r24, 0x68	; 104
    12f4:	41 f4       	brne	.+16     	; 0x1306 <vfprintf+0xf6>
    12f6:	f7 01       	movw	r30, r14
    12f8:	93 fd       	sbrc	r25, 3
    12fa:	85 91       	lpm	r24, Z+
    12fc:	93 ff       	sbrs	r25, 3
    12fe:	81 91       	ld	r24, Z+
    1300:	7f 01       	movw	r14, r30
    1302:	81 11       	cpse	r24, r1
    1304:	b3 cf       	rjmp	.-154    	; 0x126c <vfprintf+0x5c>
    1306:	98 2f       	mov	r25, r24
    1308:	9f 7d       	andi	r25, 0xDF	; 223
    130a:	95 54       	subi	r25, 0x45	; 69
    130c:	93 30       	cpi	r25, 0x03	; 3
    130e:	28 f4       	brcc	.+10     	; 0x131a <vfprintf+0x10a>
    1310:	0c 5f       	subi	r16, 0xFC	; 252
    1312:	1f 4f       	sbci	r17, 0xFF	; 255
    1314:	9f e3       	ldi	r25, 0x3F	; 63
    1316:	99 83       	std	Y+1, r25	; 0x01
    1318:	0d c0       	rjmp	.+26     	; 0x1334 <vfprintf+0x124>
    131a:	83 36       	cpi	r24, 0x63	; 99
    131c:	31 f0       	breq	.+12     	; 0x132a <vfprintf+0x11a>
    131e:	83 37       	cpi	r24, 0x73	; 115
    1320:	71 f0       	breq	.+28     	; 0x133e <vfprintf+0x12e>
    1322:	83 35       	cpi	r24, 0x53	; 83
    1324:	09 f0       	breq	.+2      	; 0x1328 <vfprintf+0x118>
    1326:	59 c0       	rjmp	.+178    	; 0x13da <vfprintf+0x1ca>
    1328:	21 c0       	rjmp	.+66     	; 0x136c <vfprintf+0x15c>
    132a:	f8 01       	movw	r30, r16
    132c:	80 81       	ld	r24, Z
    132e:	89 83       	std	Y+1, r24	; 0x01
    1330:	0e 5f       	subi	r16, 0xFE	; 254
    1332:	1f 4f       	sbci	r17, 0xFF	; 255
    1334:	88 24       	eor	r8, r8
    1336:	83 94       	inc	r8
    1338:	91 2c       	mov	r9, r1
    133a:	53 01       	movw	r10, r6
    133c:	13 c0       	rjmp	.+38     	; 0x1364 <vfprintf+0x154>
    133e:	28 01       	movw	r4, r16
    1340:	f2 e0       	ldi	r31, 0x02	; 2
    1342:	4f 0e       	add	r4, r31
    1344:	51 1c       	adc	r5, r1
    1346:	f8 01       	movw	r30, r16
    1348:	a0 80       	ld	r10, Z
    134a:	b1 80       	ldd	r11, Z+1	; 0x01
    134c:	36 fe       	sbrs	r3, 6
    134e:	03 c0       	rjmp	.+6      	; 0x1356 <vfprintf+0x146>
    1350:	69 2d       	mov	r22, r9
    1352:	70 e0       	ldi	r23, 0x00	; 0
    1354:	02 c0       	rjmp	.+4      	; 0x135a <vfprintf+0x14a>
    1356:	6f ef       	ldi	r22, 0xFF	; 255
    1358:	7f ef       	ldi	r23, 0xFF	; 255
    135a:	c5 01       	movw	r24, r10
    135c:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <strnlen>
    1360:	4c 01       	movw	r8, r24
    1362:	82 01       	movw	r16, r4
    1364:	f3 2d       	mov	r31, r3
    1366:	ff 77       	andi	r31, 0x7F	; 127
    1368:	3f 2e       	mov	r3, r31
    136a:	16 c0       	rjmp	.+44     	; 0x1398 <vfprintf+0x188>
    136c:	28 01       	movw	r4, r16
    136e:	22 e0       	ldi	r18, 0x02	; 2
    1370:	42 0e       	add	r4, r18
    1372:	51 1c       	adc	r5, r1
    1374:	f8 01       	movw	r30, r16
    1376:	a0 80       	ld	r10, Z
    1378:	b1 80       	ldd	r11, Z+1	; 0x01
    137a:	36 fe       	sbrs	r3, 6
    137c:	03 c0       	rjmp	.+6      	; 0x1384 <vfprintf+0x174>
    137e:	69 2d       	mov	r22, r9
    1380:	70 e0       	ldi	r23, 0x00	; 0
    1382:	02 c0       	rjmp	.+4      	; 0x1388 <vfprintf+0x178>
    1384:	6f ef       	ldi	r22, 0xFF	; 255
    1386:	7f ef       	ldi	r23, 0xFF	; 255
    1388:	c5 01       	movw	r24, r10
    138a:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <strnlen_P>
    138e:	4c 01       	movw	r8, r24
    1390:	f3 2d       	mov	r31, r3
    1392:	f0 68       	ori	r31, 0x80	; 128
    1394:	3f 2e       	mov	r3, r31
    1396:	82 01       	movw	r16, r4
    1398:	33 fc       	sbrc	r3, 3
    139a:	1b c0       	rjmp	.+54     	; 0x13d2 <vfprintf+0x1c2>
    139c:	82 2d       	mov	r24, r2
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	88 16       	cp	r8, r24
    13a2:	99 06       	cpc	r9, r25
    13a4:	b0 f4       	brcc	.+44     	; 0x13d2 <vfprintf+0x1c2>
    13a6:	b6 01       	movw	r22, r12
    13a8:	80 e2       	ldi	r24, 0x20	; 32
    13aa:	90 e0       	ldi	r25, 0x00	; 0
    13ac:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    13b0:	2a 94       	dec	r2
    13b2:	f4 cf       	rjmp	.-24     	; 0x139c <vfprintf+0x18c>
    13b4:	f5 01       	movw	r30, r10
    13b6:	37 fc       	sbrc	r3, 7
    13b8:	85 91       	lpm	r24, Z+
    13ba:	37 fe       	sbrs	r3, 7
    13bc:	81 91       	ld	r24, Z+
    13be:	5f 01       	movw	r10, r30
    13c0:	b6 01       	movw	r22, r12
    13c2:	90 e0       	ldi	r25, 0x00	; 0
    13c4:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    13c8:	21 10       	cpse	r2, r1
    13ca:	2a 94       	dec	r2
    13cc:	21 e0       	ldi	r18, 0x01	; 1
    13ce:	82 1a       	sub	r8, r18
    13d0:	91 08       	sbc	r9, r1
    13d2:	81 14       	cp	r8, r1
    13d4:	91 04       	cpc	r9, r1
    13d6:	71 f7       	brne	.-36     	; 0x13b4 <vfprintf+0x1a4>
    13d8:	e8 c0       	rjmp	.+464    	; 0x15aa <vfprintf+0x39a>
    13da:	84 36       	cpi	r24, 0x64	; 100
    13dc:	11 f0       	breq	.+4      	; 0x13e2 <vfprintf+0x1d2>
    13de:	89 36       	cpi	r24, 0x69	; 105
    13e0:	41 f5       	brne	.+80     	; 0x1432 <vfprintf+0x222>
    13e2:	f8 01       	movw	r30, r16
    13e4:	37 fe       	sbrs	r3, 7
    13e6:	07 c0       	rjmp	.+14     	; 0x13f6 <vfprintf+0x1e6>
    13e8:	60 81       	ld	r22, Z
    13ea:	71 81       	ldd	r23, Z+1	; 0x01
    13ec:	82 81       	ldd	r24, Z+2	; 0x02
    13ee:	93 81       	ldd	r25, Z+3	; 0x03
    13f0:	0c 5f       	subi	r16, 0xFC	; 252
    13f2:	1f 4f       	sbci	r17, 0xFF	; 255
    13f4:	08 c0       	rjmp	.+16     	; 0x1406 <vfprintf+0x1f6>
    13f6:	60 81       	ld	r22, Z
    13f8:	71 81       	ldd	r23, Z+1	; 0x01
    13fa:	07 2e       	mov	r0, r23
    13fc:	00 0c       	add	r0, r0
    13fe:	88 0b       	sbc	r24, r24
    1400:	99 0b       	sbc	r25, r25
    1402:	0e 5f       	subi	r16, 0xFE	; 254
    1404:	1f 4f       	sbci	r17, 0xFF	; 255
    1406:	f3 2d       	mov	r31, r3
    1408:	ff 76       	andi	r31, 0x6F	; 111
    140a:	3f 2e       	mov	r3, r31
    140c:	97 ff       	sbrs	r25, 7
    140e:	09 c0       	rjmp	.+18     	; 0x1422 <vfprintf+0x212>
    1410:	90 95       	com	r25
    1412:	80 95       	com	r24
    1414:	70 95       	com	r23
    1416:	61 95       	neg	r22
    1418:	7f 4f       	sbci	r23, 0xFF	; 255
    141a:	8f 4f       	sbci	r24, 0xFF	; 255
    141c:	9f 4f       	sbci	r25, 0xFF	; 255
    141e:	f0 68       	ori	r31, 0x80	; 128
    1420:	3f 2e       	mov	r3, r31
    1422:	2a e0       	ldi	r18, 0x0A	; 10
    1424:	30 e0       	ldi	r19, 0x00	; 0
    1426:	a3 01       	movw	r20, r6
    1428:	0e 94 3b 0b 	call	0x1676	; 0x1676 <__ultoa_invert>
    142c:	88 2e       	mov	r8, r24
    142e:	86 18       	sub	r8, r6
    1430:	45 c0       	rjmp	.+138    	; 0x14bc <vfprintf+0x2ac>
    1432:	85 37       	cpi	r24, 0x75	; 117
    1434:	31 f4       	brne	.+12     	; 0x1442 <vfprintf+0x232>
    1436:	23 2d       	mov	r18, r3
    1438:	2f 7e       	andi	r18, 0xEF	; 239
    143a:	b2 2e       	mov	r11, r18
    143c:	2a e0       	ldi	r18, 0x0A	; 10
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	25 c0       	rjmp	.+74     	; 0x148c <vfprintf+0x27c>
    1442:	93 2d       	mov	r25, r3
    1444:	99 7f       	andi	r25, 0xF9	; 249
    1446:	b9 2e       	mov	r11, r25
    1448:	8f 36       	cpi	r24, 0x6F	; 111
    144a:	c1 f0       	breq	.+48     	; 0x147c <vfprintf+0x26c>
    144c:	18 f4       	brcc	.+6      	; 0x1454 <vfprintf+0x244>
    144e:	88 35       	cpi	r24, 0x58	; 88
    1450:	79 f0       	breq	.+30     	; 0x1470 <vfprintf+0x260>
    1452:	b5 c0       	rjmp	.+362    	; 0x15be <vfprintf+0x3ae>
    1454:	80 37       	cpi	r24, 0x70	; 112
    1456:	19 f0       	breq	.+6      	; 0x145e <vfprintf+0x24e>
    1458:	88 37       	cpi	r24, 0x78	; 120
    145a:	21 f0       	breq	.+8      	; 0x1464 <vfprintf+0x254>
    145c:	b0 c0       	rjmp	.+352    	; 0x15be <vfprintf+0x3ae>
    145e:	e9 2f       	mov	r30, r25
    1460:	e0 61       	ori	r30, 0x10	; 16
    1462:	be 2e       	mov	r11, r30
    1464:	b4 fe       	sbrs	r11, 4
    1466:	0d c0       	rjmp	.+26     	; 0x1482 <vfprintf+0x272>
    1468:	fb 2d       	mov	r31, r11
    146a:	f4 60       	ori	r31, 0x04	; 4
    146c:	bf 2e       	mov	r11, r31
    146e:	09 c0       	rjmp	.+18     	; 0x1482 <vfprintf+0x272>
    1470:	34 fe       	sbrs	r3, 4
    1472:	0a c0       	rjmp	.+20     	; 0x1488 <vfprintf+0x278>
    1474:	29 2f       	mov	r18, r25
    1476:	26 60       	ori	r18, 0x06	; 6
    1478:	b2 2e       	mov	r11, r18
    147a:	06 c0       	rjmp	.+12     	; 0x1488 <vfprintf+0x278>
    147c:	28 e0       	ldi	r18, 0x08	; 8
    147e:	30 e0       	ldi	r19, 0x00	; 0
    1480:	05 c0       	rjmp	.+10     	; 0x148c <vfprintf+0x27c>
    1482:	20 e1       	ldi	r18, 0x10	; 16
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	02 c0       	rjmp	.+4      	; 0x148c <vfprintf+0x27c>
    1488:	20 e1       	ldi	r18, 0x10	; 16
    148a:	32 e0       	ldi	r19, 0x02	; 2
    148c:	f8 01       	movw	r30, r16
    148e:	b7 fe       	sbrs	r11, 7
    1490:	07 c0       	rjmp	.+14     	; 0x14a0 <vfprintf+0x290>
    1492:	60 81       	ld	r22, Z
    1494:	71 81       	ldd	r23, Z+1	; 0x01
    1496:	82 81       	ldd	r24, Z+2	; 0x02
    1498:	93 81       	ldd	r25, Z+3	; 0x03
    149a:	0c 5f       	subi	r16, 0xFC	; 252
    149c:	1f 4f       	sbci	r17, 0xFF	; 255
    149e:	06 c0       	rjmp	.+12     	; 0x14ac <vfprintf+0x29c>
    14a0:	60 81       	ld	r22, Z
    14a2:	71 81       	ldd	r23, Z+1	; 0x01
    14a4:	80 e0       	ldi	r24, 0x00	; 0
    14a6:	90 e0       	ldi	r25, 0x00	; 0
    14a8:	0e 5f       	subi	r16, 0xFE	; 254
    14aa:	1f 4f       	sbci	r17, 0xFF	; 255
    14ac:	a3 01       	movw	r20, r6
    14ae:	0e 94 3b 0b 	call	0x1676	; 0x1676 <__ultoa_invert>
    14b2:	88 2e       	mov	r8, r24
    14b4:	86 18       	sub	r8, r6
    14b6:	fb 2d       	mov	r31, r11
    14b8:	ff 77       	andi	r31, 0x7F	; 127
    14ba:	3f 2e       	mov	r3, r31
    14bc:	36 fe       	sbrs	r3, 6
    14be:	0d c0       	rjmp	.+26     	; 0x14da <vfprintf+0x2ca>
    14c0:	23 2d       	mov	r18, r3
    14c2:	2e 7f       	andi	r18, 0xFE	; 254
    14c4:	a2 2e       	mov	r10, r18
    14c6:	89 14       	cp	r8, r9
    14c8:	58 f4       	brcc	.+22     	; 0x14e0 <vfprintf+0x2d0>
    14ca:	34 fe       	sbrs	r3, 4
    14cc:	0b c0       	rjmp	.+22     	; 0x14e4 <vfprintf+0x2d4>
    14ce:	32 fc       	sbrc	r3, 2
    14d0:	09 c0       	rjmp	.+18     	; 0x14e4 <vfprintf+0x2d4>
    14d2:	83 2d       	mov	r24, r3
    14d4:	8e 7e       	andi	r24, 0xEE	; 238
    14d6:	a8 2e       	mov	r10, r24
    14d8:	05 c0       	rjmp	.+10     	; 0x14e4 <vfprintf+0x2d4>
    14da:	b8 2c       	mov	r11, r8
    14dc:	a3 2c       	mov	r10, r3
    14de:	03 c0       	rjmp	.+6      	; 0x14e6 <vfprintf+0x2d6>
    14e0:	b8 2c       	mov	r11, r8
    14e2:	01 c0       	rjmp	.+2      	; 0x14e6 <vfprintf+0x2d6>
    14e4:	b9 2c       	mov	r11, r9
    14e6:	a4 fe       	sbrs	r10, 4
    14e8:	0f c0       	rjmp	.+30     	; 0x1508 <vfprintf+0x2f8>
    14ea:	fe 01       	movw	r30, r28
    14ec:	e8 0d       	add	r30, r8
    14ee:	f1 1d       	adc	r31, r1
    14f0:	80 81       	ld	r24, Z
    14f2:	80 33       	cpi	r24, 0x30	; 48
    14f4:	21 f4       	brne	.+8      	; 0x14fe <vfprintf+0x2ee>
    14f6:	9a 2d       	mov	r25, r10
    14f8:	99 7e       	andi	r25, 0xE9	; 233
    14fa:	a9 2e       	mov	r10, r25
    14fc:	09 c0       	rjmp	.+18     	; 0x1510 <vfprintf+0x300>
    14fe:	a2 fe       	sbrs	r10, 2
    1500:	06 c0       	rjmp	.+12     	; 0x150e <vfprintf+0x2fe>
    1502:	b3 94       	inc	r11
    1504:	b3 94       	inc	r11
    1506:	04 c0       	rjmp	.+8      	; 0x1510 <vfprintf+0x300>
    1508:	8a 2d       	mov	r24, r10
    150a:	86 78       	andi	r24, 0x86	; 134
    150c:	09 f0       	breq	.+2      	; 0x1510 <vfprintf+0x300>
    150e:	b3 94       	inc	r11
    1510:	a3 fc       	sbrc	r10, 3
    1512:	11 c0       	rjmp	.+34     	; 0x1536 <vfprintf+0x326>
    1514:	a0 fe       	sbrs	r10, 0
    1516:	06 c0       	rjmp	.+12     	; 0x1524 <vfprintf+0x314>
    1518:	b2 14       	cp	r11, r2
    151a:	88 f4       	brcc	.+34     	; 0x153e <vfprintf+0x32e>
    151c:	28 0c       	add	r2, r8
    151e:	92 2c       	mov	r9, r2
    1520:	9b 18       	sub	r9, r11
    1522:	0e c0       	rjmp	.+28     	; 0x1540 <vfprintf+0x330>
    1524:	b2 14       	cp	r11, r2
    1526:	60 f4       	brcc	.+24     	; 0x1540 <vfprintf+0x330>
    1528:	b6 01       	movw	r22, r12
    152a:	80 e2       	ldi	r24, 0x20	; 32
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    1532:	b3 94       	inc	r11
    1534:	f7 cf       	rjmp	.-18     	; 0x1524 <vfprintf+0x314>
    1536:	b2 14       	cp	r11, r2
    1538:	18 f4       	brcc	.+6      	; 0x1540 <vfprintf+0x330>
    153a:	2b 18       	sub	r2, r11
    153c:	02 c0       	rjmp	.+4      	; 0x1542 <vfprintf+0x332>
    153e:	98 2c       	mov	r9, r8
    1540:	21 2c       	mov	r2, r1
    1542:	a4 fe       	sbrs	r10, 4
    1544:	10 c0       	rjmp	.+32     	; 0x1566 <vfprintf+0x356>
    1546:	b6 01       	movw	r22, r12
    1548:	80 e3       	ldi	r24, 0x30	; 48
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    1550:	a2 fe       	sbrs	r10, 2
    1552:	17 c0       	rjmp	.+46     	; 0x1582 <vfprintf+0x372>
    1554:	a1 fc       	sbrc	r10, 1
    1556:	03 c0       	rjmp	.+6      	; 0x155e <vfprintf+0x34e>
    1558:	88 e7       	ldi	r24, 0x78	; 120
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	02 c0       	rjmp	.+4      	; 0x1562 <vfprintf+0x352>
    155e:	88 e5       	ldi	r24, 0x58	; 88
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	b6 01       	movw	r22, r12
    1564:	0c c0       	rjmp	.+24     	; 0x157e <vfprintf+0x36e>
    1566:	8a 2d       	mov	r24, r10
    1568:	86 78       	andi	r24, 0x86	; 134
    156a:	59 f0       	breq	.+22     	; 0x1582 <vfprintf+0x372>
    156c:	a1 fe       	sbrs	r10, 1
    156e:	02 c0       	rjmp	.+4      	; 0x1574 <vfprintf+0x364>
    1570:	8b e2       	ldi	r24, 0x2B	; 43
    1572:	01 c0       	rjmp	.+2      	; 0x1576 <vfprintf+0x366>
    1574:	80 e2       	ldi	r24, 0x20	; 32
    1576:	a7 fc       	sbrc	r10, 7
    1578:	8d e2       	ldi	r24, 0x2D	; 45
    157a:	b6 01       	movw	r22, r12
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    1582:	89 14       	cp	r8, r9
    1584:	38 f4       	brcc	.+14     	; 0x1594 <vfprintf+0x384>
    1586:	b6 01       	movw	r22, r12
    1588:	80 e3       	ldi	r24, 0x30	; 48
    158a:	90 e0       	ldi	r25, 0x00	; 0
    158c:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    1590:	9a 94       	dec	r9
    1592:	f7 cf       	rjmp	.-18     	; 0x1582 <vfprintf+0x372>
    1594:	8a 94       	dec	r8
    1596:	f3 01       	movw	r30, r6
    1598:	e8 0d       	add	r30, r8
    159a:	f1 1d       	adc	r31, r1
    159c:	80 81       	ld	r24, Z
    159e:	b6 01       	movw	r22, r12
    15a0:	90 e0       	ldi	r25, 0x00	; 0
    15a2:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    15a6:	81 10       	cpse	r8, r1
    15a8:	f5 cf       	rjmp	.-22     	; 0x1594 <vfprintf+0x384>
    15aa:	22 20       	and	r2, r2
    15ac:	09 f4       	brne	.+2      	; 0x15b0 <vfprintf+0x3a0>
    15ae:	42 ce       	rjmp	.-892    	; 0x1234 <vfprintf+0x24>
    15b0:	b6 01       	movw	r22, r12
    15b2:	80 e2       	ldi	r24, 0x20	; 32
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <fputc>
    15ba:	2a 94       	dec	r2
    15bc:	f6 cf       	rjmp	.-20     	; 0x15aa <vfprintf+0x39a>
    15be:	f6 01       	movw	r30, r12
    15c0:	86 81       	ldd	r24, Z+6	; 0x06
    15c2:	97 81       	ldd	r25, Z+7	; 0x07
    15c4:	02 c0       	rjmp	.+4      	; 0x15ca <vfprintf+0x3ba>
    15c6:	8f ef       	ldi	r24, 0xFF	; 255
    15c8:	9f ef       	ldi	r25, 0xFF	; 255
    15ca:	2b 96       	adiw	r28, 0x0b	; 11
    15cc:	e2 e1       	ldi	r30, 0x12	; 18
    15ce:	0c 94 b5 0b 	jmp	0x176a	; 0x176a <__epilogue_restores__>

000015d2 <strnlen_P>:
    15d2:	fc 01       	movw	r30, r24
    15d4:	05 90       	lpm	r0, Z+
    15d6:	61 50       	subi	r22, 0x01	; 1
    15d8:	70 40       	sbci	r23, 0x00	; 0
    15da:	01 10       	cpse	r0, r1
    15dc:	d8 f7       	brcc	.-10     	; 0x15d4 <strnlen_P+0x2>
    15de:	80 95       	com	r24
    15e0:	90 95       	com	r25
    15e2:	8e 0f       	add	r24, r30
    15e4:	9f 1f       	adc	r25, r31
    15e6:	08 95       	ret

000015e8 <strnlen>:
    15e8:	fc 01       	movw	r30, r24
    15ea:	61 50       	subi	r22, 0x01	; 1
    15ec:	70 40       	sbci	r23, 0x00	; 0
    15ee:	01 90       	ld	r0, Z+
    15f0:	01 10       	cpse	r0, r1
    15f2:	d8 f7       	brcc	.-10     	; 0x15ea <strnlen+0x2>
    15f4:	80 95       	com	r24
    15f6:	90 95       	com	r25
    15f8:	8e 0f       	add	r24, r30
    15fa:	9f 1f       	adc	r25, r31
    15fc:	08 95       	ret

000015fe <fputc>:
    15fe:	0f 93       	push	r16
    1600:	1f 93       	push	r17
    1602:	cf 93       	push	r28
    1604:	df 93       	push	r29
    1606:	fb 01       	movw	r30, r22
    1608:	23 81       	ldd	r18, Z+3	; 0x03
    160a:	21 fd       	sbrc	r18, 1
    160c:	03 c0       	rjmp	.+6      	; 0x1614 <fputc+0x16>
    160e:	8f ef       	ldi	r24, 0xFF	; 255
    1610:	9f ef       	ldi	r25, 0xFF	; 255
    1612:	2c c0       	rjmp	.+88     	; 0x166c <fputc+0x6e>
    1614:	22 ff       	sbrs	r18, 2
    1616:	16 c0       	rjmp	.+44     	; 0x1644 <fputc+0x46>
    1618:	46 81       	ldd	r20, Z+6	; 0x06
    161a:	57 81       	ldd	r21, Z+7	; 0x07
    161c:	24 81       	ldd	r18, Z+4	; 0x04
    161e:	35 81       	ldd	r19, Z+5	; 0x05
    1620:	42 17       	cp	r20, r18
    1622:	53 07       	cpc	r21, r19
    1624:	44 f4       	brge	.+16     	; 0x1636 <fputc+0x38>
    1626:	a0 81       	ld	r26, Z
    1628:	b1 81       	ldd	r27, Z+1	; 0x01
    162a:	9d 01       	movw	r18, r26
    162c:	2f 5f       	subi	r18, 0xFF	; 255
    162e:	3f 4f       	sbci	r19, 0xFF	; 255
    1630:	31 83       	std	Z+1, r19	; 0x01
    1632:	20 83       	st	Z, r18
    1634:	8c 93       	st	X, r24
    1636:	26 81       	ldd	r18, Z+6	; 0x06
    1638:	37 81       	ldd	r19, Z+7	; 0x07
    163a:	2f 5f       	subi	r18, 0xFF	; 255
    163c:	3f 4f       	sbci	r19, 0xFF	; 255
    163e:	37 83       	std	Z+7, r19	; 0x07
    1640:	26 83       	std	Z+6, r18	; 0x06
    1642:	14 c0       	rjmp	.+40     	; 0x166c <fputc+0x6e>
    1644:	8b 01       	movw	r16, r22
    1646:	ec 01       	movw	r28, r24
    1648:	fb 01       	movw	r30, r22
    164a:	00 84       	ldd	r0, Z+8	; 0x08
    164c:	f1 85       	ldd	r31, Z+9	; 0x09
    164e:	e0 2d       	mov	r30, r0
    1650:	09 95       	icall
    1652:	89 2b       	or	r24, r25
    1654:	e1 f6       	brne	.-72     	; 0x160e <fputc+0x10>
    1656:	d8 01       	movw	r26, r16
    1658:	16 96       	adiw	r26, 0x06	; 6
    165a:	8d 91       	ld	r24, X+
    165c:	9c 91       	ld	r25, X
    165e:	17 97       	sbiw	r26, 0x07	; 7
    1660:	01 96       	adiw	r24, 0x01	; 1
    1662:	17 96       	adiw	r26, 0x07	; 7
    1664:	9c 93       	st	X, r25
    1666:	8e 93       	st	-X, r24
    1668:	16 97       	sbiw	r26, 0x06	; 6
    166a:	ce 01       	movw	r24, r28
    166c:	df 91       	pop	r29
    166e:	cf 91       	pop	r28
    1670:	1f 91       	pop	r17
    1672:	0f 91       	pop	r16
    1674:	08 95       	ret

00001676 <__ultoa_invert>:
    1676:	fa 01       	movw	r30, r20
    1678:	aa 27       	eor	r26, r26
    167a:	28 30       	cpi	r18, 0x08	; 8
    167c:	51 f1       	breq	.+84     	; 0x16d2 <__ultoa_invert+0x5c>
    167e:	20 31       	cpi	r18, 0x10	; 16
    1680:	81 f1       	breq	.+96     	; 0x16e2 <__ultoa_invert+0x6c>
    1682:	e8 94       	clt
    1684:	6f 93       	push	r22
    1686:	6e 7f       	andi	r22, 0xFE	; 254
    1688:	6e 5f       	subi	r22, 0xFE	; 254
    168a:	7f 4f       	sbci	r23, 0xFF	; 255
    168c:	8f 4f       	sbci	r24, 0xFF	; 255
    168e:	9f 4f       	sbci	r25, 0xFF	; 255
    1690:	af 4f       	sbci	r26, 0xFF	; 255
    1692:	b1 e0       	ldi	r27, 0x01	; 1
    1694:	3e d0       	rcall	.+124    	; 0x1712 <__ultoa_invert+0x9c>
    1696:	b4 e0       	ldi	r27, 0x04	; 4
    1698:	3c d0       	rcall	.+120    	; 0x1712 <__ultoa_invert+0x9c>
    169a:	67 0f       	add	r22, r23
    169c:	78 1f       	adc	r23, r24
    169e:	89 1f       	adc	r24, r25
    16a0:	9a 1f       	adc	r25, r26
    16a2:	a1 1d       	adc	r26, r1
    16a4:	68 0f       	add	r22, r24
    16a6:	79 1f       	adc	r23, r25
    16a8:	8a 1f       	adc	r24, r26
    16aa:	91 1d       	adc	r25, r1
    16ac:	a1 1d       	adc	r26, r1
    16ae:	6a 0f       	add	r22, r26
    16b0:	71 1d       	adc	r23, r1
    16b2:	81 1d       	adc	r24, r1
    16b4:	91 1d       	adc	r25, r1
    16b6:	a1 1d       	adc	r26, r1
    16b8:	20 d0       	rcall	.+64     	; 0x16fa <__ultoa_invert+0x84>
    16ba:	09 f4       	brne	.+2      	; 0x16be <__ultoa_invert+0x48>
    16bc:	68 94       	set
    16be:	3f 91       	pop	r19
    16c0:	2a e0       	ldi	r18, 0x0A	; 10
    16c2:	26 9f       	mul	r18, r22
    16c4:	11 24       	eor	r1, r1
    16c6:	30 19       	sub	r19, r0
    16c8:	30 5d       	subi	r19, 0xD0	; 208
    16ca:	31 93       	st	Z+, r19
    16cc:	de f6       	brtc	.-74     	; 0x1684 <__ultoa_invert+0xe>
    16ce:	cf 01       	movw	r24, r30
    16d0:	08 95       	ret
    16d2:	46 2f       	mov	r20, r22
    16d4:	47 70       	andi	r20, 0x07	; 7
    16d6:	40 5d       	subi	r20, 0xD0	; 208
    16d8:	41 93       	st	Z+, r20
    16da:	b3 e0       	ldi	r27, 0x03	; 3
    16dc:	0f d0       	rcall	.+30     	; 0x16fc <__ultoa_invert+0x86>
    16de:	c9 f7       	brne	.-14     	; 0x16d2 <__ultoa_invert+0x5c>
    16e0:	f6 cf       	rjmp	.-20     	; 0x16ce <__ultoa_invert+0x58>
    16e2:	46 2f       	mov	r20, r22
    16e4:	4f 70       	andi	r20, 0x0F	; 15
    16e6:	40 5d       	subi	r20, 0xD0	; 208
    16e8:	4a 33       	cpi	r20, 0x3A	; 58
    16ea:	18 f0       	brcs	.+6      	; 0x16f2 <__ultoa_invert+0x7c>
    16ec:	49 5d       	subi	r20, 0xD9	; 217
    16ee:	31 fd       	sbrc	r19, 1
    16f0:	40 52       	subi	r20, 0x20	; 32
    16f2:	41 93       	st	Z+, r20
    16f4:	02 d0       	rcall	.+4      	; 0x16fa <__ultoa_invert+0x84>
    16f6:	a9 f7       	brne	.-22     	; 0x16e2 <__ultoa_invert+0x6c>
    16f8:	ea cf       	rjmp	.-44     	; 0x16ce <__ultoa_invert+0x58>
    16fa:	b4 e0       	ldi	r27, 0x04	; 4
    16fc:	a6 95       	lsr	r26
    16fe:	97 95       	ror	r25
    1700:	87 95       	ror	r24
    1702:	77 95       	ror	r23
    1704:	67 95       	ror	r22
    1706:	ba 95       	dec	r27
    1708:	c9 f7       	brne	.-14     	; 0x16fc <__ultoa_invert+0x86>
    170a:	00 97       	sbiw	r24, 0x00	; 0
    170c:	61 05       	cpc	r22, r1
    170e:	71 05       	cpc	r23, r1
    1710:	08 95       	ret
    1712:	9b 01       	movw	r18, r22
    1714:	ac 01       	movw	r20, r24
    1716:	0a 2e       	mov	r0, r26
    1718:	06 94       	lsr	r0
    171a:	57 95       	ror	r21
    171c:	47 95       	ror	r20
    171e:	37 95       	ror	r19
    1720:	27 95       	ror	r18
    1722:	ba 95       	dec	r27
    1724:	c9 f7       	brne	.-14     	; 0x1718 <__ultoa_invert+0xa2>
    1726:	62 0f       	add	r22, r18
    1728:	73 1f       	adc	r23, r19
    172a:	84 1f       	adc	r24, r20
    172c:	95 1f       	adc	r25, r21
    172e:	a0 1d       	adc	r26, r0
    1730:	08 95       	ret

00001732 <__prologue_saves__>:
    1732:	2f 92       	push	r2
    1734:	3f 92       	push	r3
    1736:	4f 92       	push	r4
    1738:	5f 92       	push	r5
    173a:	6f 92       	push	r6
    173c:	7f 92       	push	r7
    173e:	8f 92       	push	r8
    1740:	9f 92       	push	r9
    1742:	af 92       	push	r10
    1744:	bf 92       	push	r11
    1746:	cf 92       	push	r12
    1748:	df 92       	push	r13
    174a:	ef 92       	push	r14
    174c:	ff 92       	push	r15
    174e:	0f 93       	push	r16
    1750:	1f 93       	push	r17
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
    1756:	cd b7       	in	r28, 0x3d	; 61
    1758:	de b7       	in	r29, 0x3e	; 62
    175a:	ca 1b       	sub	r28, r26
    175c:	db 0b       	sbc	r29, r27
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	de bf       	out	0x3e, r29	; 62
    1764:	0f be       	out	0x3f, r0	; 63
    1766:	cd bf       	out	0x3d, r28	; 61
    1768:	09 94       	ijmp

0000176a <__epilogue_restores__>:
    176a:	2a 88       	ldd	r2, Y+18	; 0x12
    176c:	39 88       	ldd	r3, Y+17	; 0x11
    176e:	48 88       	ldd	r4, Y+16	; 0x10
    1770:	5f 84       	ldd	r5, Y+15	; 0x0f
    1772:	6e 84       	ldd	r6, Y+14	; 0x0e
    1774:	7d 84       	ldd	r7, Y+13	; 0x0d
    1776:	8c 84       	ldd	r8, Y+12	; 0x0c
    1778:	9b 84       	ldd	r9, Y+11	; 0x0b
    177a:	aa 84       	ldd	r10, Y+10	; 0x0a
    177c:	b9 84       	ldd	r11, Y+9	; 0x09
    177e:	c8 84       	ldd	r12, Y+8	; 0x08
    1780:	df 80       	ldd	r13, Y+7	; 0x07
    1782:	ee 80       	ldd	r14, Y+6	; 0x06
    1784:	fd 80       	ldd	r15, Y+5	; 0x05
    1786:	0c 81       	ldd	r16, Y+4	; 0x04
    1788:	1b 81       	ldd	r17, Y+3	; 0x03
    178a:	aa 81       	ldd	r26, Y+2	; 0x02
    178c:	b9 81       	ldd	r27, Y+1	; 0x01
    178e:	ce 0f       	add	r28, r30
    1790:	d1 1d       	adc	r29, r1
    1792:	0f b6       	in	r0, 0x3f	; 63
    1794:	f8 94       	cli
    1796:	de bf       	out	0x3e, r29	; 62
    1798:	0f be       	out	0x3f, r0	; 63
    179a:	cd bf       	out	0x3d, r28	; 61
    179c:	ed 01       	movw	r28, r26
    179e:	08 95       	ret

000017a0 <_exit>:
    17a0:	f8 94       	cli

000017a2 <__stop_program>:
    17a2:	ff cf       	rjmp	.-2      	; 0x17a2 <__stop_program>
