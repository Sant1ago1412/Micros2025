
Cinta_Final.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005a  00800100  00001828  000018bc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001828  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002ba  0080015a  0080015a  00001916  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001916  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001974  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000160  00000000  00000000  000019b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001e76  00000000  00000000  00001b14  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c31  00000000  00000000  0000398a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000fba  00000000  00000000  000045bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000048c  00000000  00000000  00005578  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009f7  00000000  00000000  00005a04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000dd2  00000000  00000000  000063fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000160  00000000  00000000  000071cd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
       4:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       8:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
       c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      28:	0c 94 47 01 	jmp	0x28e	; 0x28e <__vector_10>
      2c:	0c 94 f3 00 	jmp	0x1e6	; 0x1e6 <__vector_11>
      30:	0c 94 12 01 	jmp	0x224	; 0x224 <__vector_12>
      34:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      40:	0c 94 8e 01 	jmp	0x31c	; 0x31c <__vector_16>
      44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      48:	0c 94 b2 01 	jmp	0x364	; 0x364 <__vector_18>
      4c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      54:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      58:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      5c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      60:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      64:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
      68:	52 03       	mulsu	r21, r18
      6a:	60 03       	mulsu	r22, r16
      6c:	78 03       	fmul	r23, r16
      6e:	8d 03       	fmulsu	r16, r21
      70:	a2 03       	fmuls	r18, r18
      72:	b0 03       	fmuls	r19, r16
      74:	d5 03       	fmuls	r21, r21

00000076 <__ctors_end>:
      76:	11 24       	eor	r1, r1
      78:	1f be       	out	0x3f, r1	; 63
      7a:	cf ef       	ldi	r28, 0xFF	; 255
      7c:	d8 e0       	ldi	r29, 0x08	; 8
      7e:	de bf       	out	0x3e, r29	; 62
      80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
      82:	11 e0       	ldi	r17, 0x01	; 1
      84:	a0 e0       	ldi	r26, 0x00	; 0
      86:	b1 e0       	ldi	r27, 0x01	; 1
      88:	e8 e2       	ldi	r30, 0x28	; 40
      8a:	f8 e1       	ldi	r31, 0x18	; 24
      8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
      8e:	05 90       	lpm	r0, Z+
      90:	0d 92       	st	X+, r0
      92:	aa 35       	cpi	r26, 0x5A	; 90
      94:	b1 07       	cpc	r27, r17
      96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
      98:	24 e0       	ldi	r18, 0x04	; 4
      9a:	aa e5       	ldi	r26, 0x5A	; 90
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
      a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
      a2:	a4 31       	cpi	r26, 0x14	; 20
      a4:	b2 07       	cpc	r27, r18
      a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
      a8:	0e 94 be 06 	call	0xd7c	; 0xd7c <main>
      ac:	0c 94 12 0c 	jmp	0x1824	; 0x1824 <_exit>

000000b0 <__bad_interrupt>:
      b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <HCSR04_AddNew>:

//variable interna estatica
static _sHCSR04Handle *mySensor;		//puntero a la estructura _sHCSR04Handle. Se usa como variable auxiliar para manipular los datos de los sensores ultrasónicos HCSR04.

unsigned int HCSR04_AddNew(void (*WritePin_HCSR04)(uint8_t value), uint32_t ticks)
{
      b4:	cf 92       	push	r12
      b6:	df 92       	push	r13
      b8:	ef 92       	push	r14
      ba:	ff 92       	push	r15
      bc:	cf 93       	push	r28
      be:	df 93       	push	r29
      c0:	ec 01       	movw	r28, r24
      c2:	6a 01       	movw	r12, r20
      c4:	7b 01       	movw	r14, r22
	mySensor = (_sHCSR04Handle *)malloc(sizeof(_sHCSR04Handle));	//myHandleAux almacena un nuevo sensor dinámicamente, por lo que myHandleAux apunta a la nueva estructura creada.
      c6:	8f e0       	ldi	r24, 0x0F	; 15
      c8:	90 e0       	ldi	r25, 0x00	; 0
      ca:	0e 94 0c 08 	call	0x1018	; 0x1018 <malloc>
      ce:	fc 01       	movw	r30, r24
      d0:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
      d4:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>

	mySensor->WritePin = WritePin_HCSR04;
      d8:	d1 83       	std	Z+1, r29	; 0x01
      da:	c0 83       	st	Z, r28
	mySensor->ticks = ticks;
      dc:	c2 86       	std	Z+10, r12	; 0x0a
      de:	d3 86       	std	Z+11, r13	; 0x0b
      e0:	e4 86       	std	Z+12, r14	; 0x0c
      e2:	f5 86       	std	Z+13, r15	; 0x0d
	mySensor->flags.byte = 0;								
      e4:	16 86       	std	Z+14, r1	; 0x0e
	mySensor->lastDistanceUs = 0;
      e6:	11 86       	std	Z+9, r1	; 0x09
      e8:	10 86       	std	Z+8, r1	; 0x08
	mySensor->usTimeRise = 0;
      ea:	15 82       	std	Z+5, r1	; 0x05
      ec:	14 82       	std	Z+4, r1	; 0x04
	mySensor->usTimeFall = 0;
      ee:	17 82       	std	Z+7, r1	; 0x07
      f0:	16 82       	std	Z+6, r1	; 0x06
	mySensor->WritePin(0);		
      f2:	80 e0       	ldi	r24, 0x00	; 0
      f4:	fe 01       	movw	r30, r28
      f6:	09 95       	icall
	
	return (unsigned int)mySensor;
}
      f8:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <__data_end>
      fc:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <__data_end+0x1>
     100:	df 91       	pop	r29
     102:	cf 91       	pop	r28
     104:	ff 90       	pop	r15
     106:	ef 90       	pop	r14
     108:	df 90       	pop	r13
     10a:	cf 90       	pop	r12
     10c:	08 95       	ret

0000010e <HCSR04_Start>:
//}


void HCSR04_Start(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     10e:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
     112:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>
	
	mySensor->WritePin(1);					
     116:	dc 01       	movw	r26, r24
     118:	ed 91       	ld	r30, X+
     11a:	fc 91       	ld	r31, X
     11c:	81 e0       	ldi	r24, 0x01	; 1
     11e:	09 95       	icall
     120:	08 95       	ret

00000122 <HCSR04_TriggerReady>:
	
}

void HCSR04_TriggerReady(unsigned int handleHCSR04)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     122:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
     126:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>
	
	mySensor->WritePin(0);
     12a:	dc 01       	movw	r26, r24
     12c:	ed 91       	ld	r30, X+
     12e:	fc 91       	ld	r31, X
     130:	80 e0       	ldi	r24, 0x00	; 0
     132:	09 95       	icall
     134:	08 95       	ret

00000136 <HCSR04_RiseEdgeTime>:
}

void HCSR04_RiseEdgeTime(unsigned int handleHCSR04, uint16_t usTimeRise)
{
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     136:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
     13a:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>

	mySensor->usTimeRise = usTimeRise;	//Cargo cuando se pone en RISE
     13e:	fc 01       	movw	r30, r24
     140:	75 83       	std	Z+5, r23	; 0x05
     142:	64 83       	std	Z+4, r22	; 0x04
	mySensor->flags.byte = 0;
     144:	16 86       	std	Z+14, r1	; 0x0e
     146:	08 95       	ret

00000148 <HCSR04_FallEdgeTime>:

}

void HCSR04_FallEdgeTime(unsigned int handleHCSR04, uint16_t usTimeFall)
{
     148:	fc 01       	movw	r30, r24
	mySensor = (_sHCSR04Handle *)handleHCSR04;
     14a:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <__data_end+0x1>
     14e:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <__data_end>

	mySensor->usTimeFall = usTimeFall;	//Cargo cuando se pone en Fall 
     152:	77 83       	std	Z+7, r23	; 0x07
     154:	66 83       	std	Z+6, r22	; 0x06
	mySensor->flags.bit.EDGEREADY = 1;
     156:	86 85       	ldd	r24, Z+14	; 0x0e
     158:	81 60       	ori	r24, 0x01	; 1
     15a:	86 87       	std	Z+14, r24	; 0x0e
     15c:	08 95       	ret

0000015e <task_HCSR>:
	
}

void task_HCSR()
{
	if (mySensor != NULL)
     15e:	e0 91 5a 01 	lds	r30, 0x015A	; 0x80015a <__data_end>
     162:	f0 91 5b 01 	lds	r31, 0x015B	; 0x80015b <__data_end+0x1>
     166:	30 97       	sbiw	r30, 0x00	; 0
     168:	11 f1       	breq	.+68     	; 0x1ae <task_HCSR+0x50>
	{
		if (mySensor->flags.bit.EDGEREADY) //¿el sensor midió? Esto indica que ya se recibieron los dos flancos (rising y falling) y se puede calcular el tiempo que tardó el eco en volver = la distancia.
     16a:	86 85       	ldd	r24, Z+14	; 0x0e
     16c:	80 ff       	sbrs	r24, 0
     16e:	1f c0       	rjmp	.+62     	; 0x1ae <task_HCSR+0x50>
		{
			mySensor->flags.byte = 0;
     170:	16 86       	std	Z+14, r1	; 0x0e
			
			if(mySensor->usTimeRise < mySensor->usTimeFall){ //si no hubo overflow
     172:	24 81       	ldd	r18, Z+4	; 0x04
     174:	35 81       	ldd	r19, Z+5	; 0x05
     176:	86 81       	ldd	r24, Z+6	; 0x06
     178:	97 81       	ldd	r25, Z+7	; 0x07
     17a:	28 17       	cp	r18, r24
     17c:	39 07       	cpc	r19, r25
     17e:	28 f4       	brcc	.+10     	; 0x18a <task_HCSR+0x2c>
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise; //distancia medida
     180:	82 1b       	sub	r24, r18
     182:	93 0b       	sbc	r25, r19
     184:	91 87       	std	Z+9, r25	; 0x09
     186:	80 87       	std	Z+8, r24	; 0x08
     188:	05 c0       	rjmp	.+10     	; 0x194 <task_HCSR+0x36>
				}else{ //hubo overflow
				mySensor->lastDistanceUs = mySensor->usTimeFall - mySensor->usTimeRise + 0xFFFF; //para corregir
     18a:	82 1b       	sub	r24, r18
     18c:	93 0b       	sbc	r25, r19
     18e:	01 97       	sbiw	r24, 0x01	; 1
     190:	91 87       	std	Z+9, r25	; 0x09
     192:	80 87       	std	Z+8, r24	; 0x08
			}
			
			if(mySensor->lastDistanceUs > 11764) //2 metros
     194:	80 85       	ldd	r24, Z+8	; 0x08
     196:	91 85       	ldd	r25, Z+9	; 0x09
     198:	85 3f       	cpi	r24, 0xF5	; 245
     19a:	9d 42       	sbci	r25, 0x2D	; 45
     19c:	20 f0       	brcs	.+8      	; 0x1a6 <task_HCSR+0x48>
				mySensor->lastDistanceUs = 0xFFFF;
     19e:	8f ef       	ldi	r24, 0xFF	; 255
     1a0:	9f ef       	ldi	r25, 0xFF	; 255
     1a2:	91 87       	std	Z+9, r25	; 0x09
     1a4:	80 87       	std	Z+8, r24	; 0x08
			
			sensorMeasure(mySensor->lastDistanceUs);
     1a6:	80 85       	ldd	r24, Z+8	; 0x08
     1a8:	91 85       	ldd	r25, Z+9	; 0x09
     1aa:	0e 94 44 04 	call	0x888	; 0x888 <sensorMeasure>
     1ae:	08 95       	ret

000001b0 <WritePin_HCSR>:
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
	}
}

void WritePin_HCSR(uint8_t value){
	if (value)
     1b0:	88 23       	and	r24, r24
     1b2:	21 f0       	breq	.+8      	; 0x1bc <WritePin_HCSR+0xc>
	PORTB |= (1<<TRIGGER);				// Sets a HIGH state (1) in the TRIGGER pin
     1b4:	85 b1       	in	r24, 0x05	; 5
     1b6:	82 60       	ori	r24, 0x02	; 2
     1b8:	85 b9       	out	0x05, r24	; 5
     1ba:	08 95       	ret
	else
	PORTB &= ~(1<<TRIGGER);				// Sets a LOW state (0) in the TRIGGER pin
     1bc:	85 b1       	in	r24, 0x05	; 5
     1be:	8d 7f       	andi	r24, 0xFD	; 253
     1c0:	85 b9       	out	0x05, r24	; 5
     1c2:	08 95       	ret

000001c4 <USART_putchar>:
#include "HCSR04.h"
#include "util.h"

#include <stdio.h>

int USART_putchar(char c, FILE *stream) {
     1c4:	cf 93       	push	r28
     1c6:	c8 2f       	mov	r28, r24
	if (c == '\n') USART_putchar('\r', stream);  // salto de línea para terminal
     1c8:	8a 30       	cpi	r24, 0x0A	; 10
     1ca:	19 f4       	brne	.+6      	; 0x1d2 <USART_putchar+0xe>
     1cc:	8d e0       	ldi	r24, 0x0D	; 13
     1ce:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <USART_putchar>
	while (!(UCSR0A & (1 << UDRE0)));  // Espera a que el buffer esté vacío
     1d2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     1d6:	85 ff       	sbrs	r24, 5
     1d8:	fc cf       	rjmp	.-8      	; 0x1d2 <USART_putchar+0xe>
	UDR0 = c;
     1da:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	return 0;
}
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <__vector_11>:

/* END Constant in Flash -----------------------------------------------------*/


/* Function ISR --------------------------------------------------------------*/
ISR(TIMER1_COMPA_vect){
     1e6:	1f 92       	push	r1
     1e8:	0f 92       	push	r0
     1ea:	0f b6       	in	r0, 0x3f	; 63
     1ec:	0f 92       	push	r0
     1ee:	11 24       	eor	r1, r1
     1f0:	8f 93       	push	r24
     1f2:	9f 93       	push	r25
     1f4:	ef 93       	push	r30
     1f6:	ff 93       	push	r31
	
	/*		Con el OCR1B en 20000 , cuento cada 10ms		*/
	IS10MS=TRUE;
     1f8:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     1fc:	81 60       	ori	r24, 0x01	; 1
     1fe:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
	OCR1A += 19999;
     202:	e8 e8       	ldi	r30, 0x88	; 136
     204:	f0 e0       	ldi	r31, 0x00	; 0
     206:	80 81       	ld	r24, Z
     208:	91 81       	ldd	r25, Z+1	; 0x01
     20a:	81 5e       	subi	r24, 0xE1	; 225
     20c:	91 4b       	sbci	r25, 0xB1	; 177
     20e:	91 83       	std	Z+1, r25	; 0x01
     210:	80 83       	st	Z, r24
	
}
     212:	ff 91       	pop	r31
     214:	ef 91       	pop	r30
     216:	9f 91       	pop	r25
     218:	8f 91       	pop	r24
     21a:	0f 90       	pop	r0
     21c:	0f be       	out	0x3f, r0	; 63
     21e:	0f 90       	pop	r0
     220:	1f 90       	pop	r1
     222:	18 95       	reti

00000224 <__vector_12>:

ISR(TIMER1_COMPB_vect){
     224:	1f 92       	push	r1
     226:	0f 92       	push	r0
     228:	0f b6       	in	r0, 0x3f	; 63
     22a:	0f 92       	push	r0
     22c:	11 24       	eor	r1, r1
     22e:	2f 93       	push	r18
     230:	3f 93       	push	r19
     232:	4f 93       	push	r20
     234:	5f 93       	push	r21
     236:	6f 93       	push	r22
     238:	7f 93       	push	r23
     23a:	8f 93       	push	r24
     23c:	9f 93       	push	r25
     23e:	af 93       	push	r26
     240:	bf 93       	push	r27
     242:	ef 93       	push	r30
     244:	ff 93       	push	r31
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
}

static inline void on_timer1_compb_hcsr(){
	HCSR04_TriggerReady(HCSR_1);					//Pongo en LOW el Trigger
     246:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <HCSR_1>
     24a:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <HCSR_1+0x1>
     24e:	0e 94 91 00 	call	0x122	; 0x122 <HCSR04_TriggerReady>
	TIFR1 |= (1<<ICF1);								// Timer/Counter1 Output Compare A Match Flag enabled
     252:	86 b3       	in	r24, 0x16	; 22
     254:	80 62       	ori	r24, 0x20	; 32
     256:	86 bb       	out	0x16, r24	; 22
	TCCR1B = (1 << ICNC1) | (1 << ICES1);			// Input Capture Noise Canceler and Input Capture Edge Select activated
     258:	e1 e8       	ldi	r30, 0x81	; 129
     25a:	f0 e0       	ldi	r31, 0x00	; 0
     25c:	80 ec       	ldi	r24, 0xC0	; 192
     25e:	80 83       	st	Z, r24
	TCCR1B |= (1 << CS11);							// Prescaler definition (x8): CS12 = 0 and CS10 = 0
     260:	80 81       	ld	r24, Z
     262:	82 60       	ori	r24, 0x02	; 2
     264:	80 83       	st	Z, r24
	TIMSK1 = (1<<ICIE1) | (1<<OCIE1A);				// Input Capture Interrupt and Output Compare A Match Interrupt enabled <---
     266:	82 e2       	ldi	r24, 0x22	; 34
     268:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	
	on_timer1_compb_hcsr();
	
}
     26c:	ff 91       	pop	r31
     26e:	ef 91       	pop	r30
     270:	bf 91       	pop	r27
     272:	af 91       	pop	r26
     274:	9f 91       	pop	r25
     276:	8f 91       	pop	r24
     278:	7f 91       	pop	r23
     27a:	6f 91       	pop	r22
     27c:	5f 91       	pop	r21
     27e:	4f 91       	pop	r20
     280:	3f 91       	pop	r19
     282:	2f 91       	pop	r18
     284:	0f 90       	pop	r0
     286:	0f be       	out	0x3f, r0	; 63
     288:	0f 90       	pop	r0
     28a:	1f 90       	pop	r1
     28c:	18 95       	reti

0000028e <__vector_10>:

ISR(TIMER1_CAPT_vect){
     28e:	1f 92       	push	r1
     290:	0f 92       	push	r0
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	0f 92       	push	r0
     296:	11 24       	eor	r1, r1
     298:	2f 93       	push	r18
     29a:	3f 93       	push	r19
     29c:	4f 93       	push	r20
     29e:	5f 93       	push	r21
     2a0:	6f 93       	push	r22
     2a2:	7f 93       	push	r23
     2a4:	8f 93       	push	r24
     2a6:	9f 93       	push	r25
     2a8:	af 93       	push	r26
     2aa:	bf 93       	push	r27
     2ac:	ef 93       	push	r30
     2ae:	ff 93       	push	r31
}

static inline void on_timer1_capt_hcsr(){
	if (TCCR1B & (1<<ICES1)){						// Si ICES1 = 1  el Timer va a capturar en el flanco de subida (rising edge).
     2b0:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
     2b4:	86 ff       	sbrs	r24, 6
     2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <__vector_10+0x4a>
		
		TCCR1B = (1 << ICNC1) | (1 << CS11);		//preparo para capturar el flanco de bajada
     2b8:	82 e8       	ldi	r24, 0x82	; 130
     2ba:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
		HCSR04_RiseEdgeTime(HCSR_1, ICR1 >> 1);		//[[ ICR1 >> 1  ==  ICR1 / 2 ]] -> En ICR1 almacena el valor de TCNT1, Es decir, guardo el momento en que llego el RISE. Como ICR1 obtiene un tick cada 500ns, si contó 3000 ticks, se hace la cuenta 3000 * 0,5us = 1500us. (500ns = 0,5us = 1/2).
     2be:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2c2:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2c6:	76 95       	lsr	r23
     2c8:	67 95       	ror	r22
     2ca:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <HCSR_1>
     2ce:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <HCSR_1+0x1>
     2d2:	0e 94 9b 00 	call	0x136	; 0x136 <HCSR04_RiseEdgeTime>
     2d6:	11 c0       	rjmp	.+34     	; 0x2fa <__vector_10+0x6c>
		}else{										// Falling edge is used as trigger

		TIMSK1 &= ~_BV(ICIE1);						//desactivo la interrupcion por input capture
     2d8:	ef e6       	ldi	r30, 0x6F	; 111
     2da:	f0 e0       	ldi	r31, 0x00	; 0
     2dc:	80 81       	ld	r24, Z
     2de:	8f 7d       	andi	r24, 0xDF	; 223
     2e0:	80 83       	st	Z, r24
		HCSR04_FallEdgeTime(HCSR_1, ICR1 >> 1);		//guardo el momento en que llego el FALLING
     2e2:	60 91 86 00 	lds	r22, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
     2e6:	70 91 87 00 	lds	r23, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
     2ea:	76 95       	lsr	r23
     2ec:	67 95       	ror	r22
     2ee:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <HCSR_1>
     2f2:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <HCSR_1+0x1>
     2f6:	0e 94 a4 00 	call	0x148	; 0x148 <HCSR04_FallEdgeTime>
	
	on_timer1_capt_hcsr();
	
}
     2fa:	ff 91       	pop	r31
     2fc:	ef 91       	pop	r30
     2fe:	bf 91       	pop	r27
     300:	af 91       	pop	r26
     302:	9f 91       	pop	r25
     304:	8f 91       	pop	r24
     306:	7f 91       	pop	r23
     308:	6f 91       	pop	r22
     30a:	5f 91       	pop	r21
     30c:	4f 91       	pop	r20
     30e:	3f 91       	pop	r19
     310:	2f 91       	pop	r18
     312:	0f 90       	pop	r0
     314:	0f be       	out	0x3f, r0	; 63
     316:	0f 90       	pop	r0
     318:	1f 90       	pop	r1
     31a:	18 95       	reti

0000031c <__vector_16>:

ISR(TIMER0_OVF_vect){
     31c:	1f 92       	push	r1
     31e:	0f 92       	push	r0
     320:	0f b6       	in	r0, 0x3f	; 63
     322:	0f 92       	push	r0
     324:	11 24       	eor	r1, r1
     326:	2f 93       	push	r18
     328:	3f 93       	push	r19
     32a:	4f 93       	push	r20
     32c:	5f 93       	push	r21
     32e:	6f 93       	push	r22
     330:	7f 93       	push	r23
     332:	8f 93       	push	r24
     334:	9f 93       	push	r25
     336:	af 93       	push	r26
     338:	bf 93       	push	r27
     33a:	ef 93       	push	r30
     33c:	ff 93       	push	r31
	
	writeServo();
     33e:	0e 94 9a 07 	call	0xf34	; 0xf34 <writeServo>
	
}
     342:	ff 91       	pop	r31
     344:	ef 91       	pop	r30
     346:	bf 91       	pop	r27
     348:	af 91       	pop	r26
     34a:	9f 91       	pop	r25
     34c:	8f 91       	pop	r24
     34e:	7f 91       	pop	r23
     350:	6f 91       	pop	r22
     352:	5f 91       	pop	r21
     354:	4f 91       	pop	r20
     356:	3f 91       	pop	r19
     358:	2f 91       	pop	r18
     35a:	0f 90       	pop	r0
     35c:	0f be       	out	0x3f, r0	; 63
     35e:	0f 90       	pop	r0
     360:	1f 90       	pop	r1
     362:	18 95       	reti

00000364 <__vector_18>:

ISR(USART_RX_vect){
     364:	1f 92       	push	r1
     366:	0f 92       	push	r0
     368:	0f b6       	in	r0, 0x3f	; 63
     36a:	0f 92       	push	r0
     36c:	11 24       	eor	r1, r1
     36e:	8f 93       	push	r24
     370:	9f 93       	push	r25
     372:	af 93       	push	r26
     374:	bf 93       	push	r27
     376:	ef 93       	push	r30
     378:	ff 93       	push	r31
	dataRx.buff[dataRx.indexW++] = UDR0;
     37a:	e5 e8       	ldi	r30, 0x85	; 133
     37c:	f2 e0       	ldi	r31, 0x02	; 2
     37e:	a0 81       	ld	r26, Z
     380:	b1 81       	ldd	r27, Z+1	; 0x01
     382:	83 81       	ldd	r24, Z+3	; 0x03
     384:	91 e0       	ldi	r25, 0x01	; 1
     386:	98 0f       	add	r25, r24
     388:	93 83       	std	Z+3, r25	; 0x03
     38a:	a8 0f       	add	r26, r24
     38c:	b1 1d       	adc	r27, r1
     38e:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     392:	8c 93       	st	X, r24
	dataRx.indexW &= dataRx.mask;
     394:	85 81       	ldd	r24, Z+5	; 0x05
     396:	93 81       	ldd	r25, Z+3	; 0x03
     398:	89 23       	and	r24, r25
     39a:	83 83       	std	Z+3, r24	; 0x03
}
     39c:	ff 91       	pop	r31
     39e:	ef 91       	pop	r30
     3a0:	bf 91       	pop	r27
     3a2:	af 91       	pop	r26
     3a4:	9f 91       	pop	r25
     3a6:	8f 91       	pop	r24
     3a8:	0f 90       	pop	r0
     3aa:	0f be       	out	0x3f, r0	; 63
     3ac:	0f 90       	pop	r0
     3ae:	1f 90       	pop	r1
     3b0:	18 95       	reti

000003b2 <ini_ports>:
void ini_ports(){
	
	/************************************************************************/
	/*								OUTPUTS                                 */
	/************************************************************************/
	DDRB = ((1 << LED_BI)| (1 << SV1) | (1 << SV2) | (1<<TRIGGER));
     3b2:	8a e3       	ldi	r24, 0x3A	; 58
     3b4:	84 b9       	out	0x04, r24	; 4
	DDRD = (1 << SV0);
     3b6:	80 e8       	ldi	r24, 0x80	; 128
     3b8:	8a b9       	out	0x0a, r24	; 10
	
	/************************************************************************/
	/*								INPUTS                                  */
	/************************************************************************/
	DDRB &= ~(1<<ECHO);
     3ba:	84 b1       	in	r24, 0x04	; 4
     3bc:	8e 7f       	andi	r24, 0xFE	; 254
     3be:	84 b9       	out	0x04, r24	; 4
	DDRD &= ~((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3c0:	8a b1       	in	r24, 0x0a	; 10
     3c2:	83 7c       	andi	r24, 0xC3	; 195
     3c4:	8a b9       	out	0x0a, r24	; 10
	
	/*						Activo Pull ups internos						*/
	PORTB = (1<<ECHO);
     3c6:	81 e0       	ldi	r24, 0x01	; 1
     3c8:	85 b9       	out	0x05, r24	; 5
	PORTD = ((1<<IR0) | (1<<IR1) | (1<<IR2) | (1<<IR3));
     3ca:	8c e3       	ldi	r24, 0x3C	; 60
     3cc:	8b b9       	out	0x0b, r24	; 11
     3ce:	08 95       	ret

000003d0 <ini_timer1>:
/************************************************************************/
/*		Timer 1 es funcional al HCSR y a la accion cada 10ms            */
/************************************************************************/
void ini_timer1(){
	
	TCCR1A = 0x00;
     3d0:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
	/* Configuro noise canceler del input capture, el flanco del input capture y prescaler en 8 (f = 16MHz / 8 = 2MHz ? 1 tick = 0.5 µs) */
	TCCR1B = 0xC2;
     3d4:	82 ec       	ldi	r24, 0xC2	; 194
     3d6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
	TCNT1 = 0x00;
     3da:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     3de:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
	/*	Activo la interrupcion por comparador b	*/
	TIMSK1 = (1<<OCIE1A);
     3e2:	82 e0       	ldi	r24, 0x02	; 2
     3e4:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	/* Le doy un valor al comparador B	*/
	OCR1A = 19999;
     3e8:	8f e1       	ldi	r24, 0x1F	; 31
     3ea:	9e e4       	ldi	r25, 0x4E	; 78
     3ec:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     3f0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
	TIFR1 = TIFR1;
     3f4:	86 b3       	in	r24, 0x16	; 22
     3f6:	86 bb       	out	0x16, r24	; 22
     3f8:	08 95       	ret

000003fa <ini_timer0>:
/************************************************************************/
/*			Timer 0 funcional a generar el pwm de los servos			*/
/************************************************************************/
void ini_timer0(){
	
	TCCR0A = 0;
     3fa:	14 bc       	out	0x24, r1	; 36
	TCNT0 = 0;
     3fc:	16 bc       	out	0x26, r1	; 38
	/*	Pongo las banderas en 0 con TIFR	*/
	TIFR0 = 0x07;
     3fe:	87 e0       	ldi	r24, 0x07	; 7
     400:	85 bb       	out	0x15, r24	; 21
	/*	Habilito la interrupcion por TOV	*/
	TIMSK0 = (1<<TOIE0);
     402:	81 e0       	ldi	r24, 0x01	; 1
     404:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
	/*	Prescaler en 8 , obtengo el cuentas de 500ns, tov a 500*256 = 128us		*/
	TCCR0B = (1<<CS01);
     408:	82 e0       	ldi	r24, 0x02	; 2
     40a:	85 bd       	out	0x25, r24	; 37
     40c:	08 95       	ret

0000040e <ini_USART>:
	
}

void ini_USART(uint8_t ubrr){
	UBRR0H = 0;
     40e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = ubrr;
     412:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	UCSR0A = 0xFE; //inicializo todas las banderas excepto el multiprocesor
     416:	8e ef       	ldi	r24, 0xFE	; 254
     418:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	UCSR0B =   0x98; // (1<<RXCIE0) | (1<<RXEN0)|(1<<TXEN0); //Activo las banderas de interrupcion de recepcion y la habilitacion del rx y tx
     41c:	88 e9       	ldi	r24, 0x98	; 152
     41e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
     422:	86 e0       	ldi	r24, 0x06	; 6
     424:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     428:	08 95       	ret

0000042a <IR_Init>:
	
}

void IR_Init(IRDebounce *ir) {
     42a:	ac 01       	movw	r20, r24
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     42c:	20 e0       	ldi	r18, 0x00	; 0
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	0d c0       	rjmp	.+26     	; 0x44c <IR_Init+0x22>
		ir[globalIndex].state = IR_DOWN;
     432:	f9 01       	movw	r30, r18
     434:	ee 0f       	add	r30, r30
     436:	ff 1f       	adc	r31, r31
     438:	ee 0f       	add	r30, r30
     43a:	ff 1f       	adc	r31, r31
     43c:	e4 0f       	add	r30, r20
     43e:	f5 1f       	adc	r31, r21
     440:	93 e0       	ldi	r25, 0x03	; 3
     442:	90 83       	st	Z, r25
		ir[globalIndex].last_sample = 0;
     444:	12 82       	std	Z+2, r1	; 0x02
		ir[globalIndex].stateConfirmed = 0;
     446:	11 82       	std	Z+1, r1	; 0x01
	UCSR0C =  0x06; // (0<<UCSZ02) | (1<<UCSZ01) | (1<<UCSZ00); //se setea como asincrono, paridad desactivada, 1 stop bit, 8 data bits
	
}

void IR_Init(IRDebounce *ir) {
	for(int globalIndex = 0;globalIndex<bufferIrn;globalIndex++){
     448:	2f 5f       	subi	r18, 0xFF	; 255
     44a:	3f 4f       	sbci	r19, 0xFF	; 255
     44c:	24 30       	cpi	r18, 0x04	; 4
     44e:	31 05       	cpc	r19, r1
     450:	84 f3       	brlt	.-32     	; 0x432 <IR_Init+0x8>
		ir[globalIndex].state = IR_DOWN;
		ir[globalIndex].last_sample = 0;
		ir[globalIndex].stateConfirmed = 0;
	}
}
     452:	08 95       	ret

00000454 <IR_Update>:

void IR_Update(IRDebounce *ir, uint8_t sample) {
     454:	fc 01       	movw	r30, r24
	switch (ir->state) {
     456:	80 81       	ld	r24, Z
     458:	81 30       	cpi	r24, 0x01	; 1
     45a:	89 f0       	breq	.+34     	; 0x47e <IR_Update+0x2a>
     45c:	28 f0       	brcs	.+10     	; 0x468 <IR_Update+0x14>
     45e:	82 30       	cpi	r24, 0x02	; 2
     460:	b1 f0       	breq	.+44     	; 0x48e <IR_Update+0x3a>
     462:	83 30       	cpi	r24, 0x03	; 3
     464:	01 f1       	breq	.+64     	; 0x4a6 <IR_Update+0x52>
     466:	26 c0       	rjmp	.+76     	; 0x4b4 <IR_Update+0x60>
		case IR_RISING:
		if (sample == 1 && ir->last_sample == 1){
     468:	61 30       	cpi	r22, 0x01	; 1
     46a:	31 f4       	brne	.+12     	; 0x478 <IR_Update+0x24>
     46c:	82 81       	ldd	r24, Z+2	; 0x02
     46e:	81 30       	cpi	r24, 0x01	; 1
     470:	19 f4       	brne	.+6      	; 0x478 <IR_Update+0x24>
			ir->state = IR_UP;
     472:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x01;
     474:	81 83       	std	Z+1, r24	; 0x01
     476:	20 c0       	rjmp	.+64     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     478:	83 e0       	ldi	r24, 0x03	; 3
     47a:	80 83       	st	Z, r24
     47c:	1d c0       	rjmp	.+58     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_UP:
		if (sample == 0){
     47e:	61 11       	cpse	r22, r1
     480:	03 c0       	rjmp	.+6      	; 0x488 <IR_Update+0x34>
			ir->state = IR_FALLING;
     482:	82 e0       	ldi	r24, 0x02	; 2
     484:	80 83       	st	Z, r24
     486:	18 c0       	rjmp	.+48     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	80 83       	st	Z, r24
     48c:	15 c0       	rjmp	.+42     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_FALLING:
		if (sample == 0 && ir->last_sample == 0){
     48e:	61 11       	cpse	r22, r1
     490:	07 c0       	rjmp	.+14     	; 0x4a0 <IR_Update+0x4c>
     492:	82 81       	ldd	r24, Z+2	; 0x02
     494:	81 11       	cpse	r24, r1
     496:	04 c0       	rjmp	.+8      	; 0x4a0 <IR_Update+0x4c>
			ir->state = IR_DOWN;
     498:	83 e0       	ldi	r24, 0x03	; 3
     49a:	80 83       	st	Z, r24
			ir->stateConfirmed = 0x00;
     49c:	11 82       	std	Z+1, r1	; 0x01
     49e:	0c c0       	rjmp	.+24     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_UP;
     4a0:	81 e0       	ldi	r24, 0x01	; 1
     4a2:	80 83       	st	Z, r24
     4a4:	09 c0       	rjmp	.+18     	; 0x4b8 <IR_Update+0x64>
		}
		break;

		case IR_DOWN:
		if (sample == 1){
     4a6:	61 30       	cpi	r22, 0x01	; 1
     4a8:	11 f4       	brne	.+4      	; 0x4ae <IR_Update+0x5a>
			ir->state = IR_RISING;
     4aa:	10 82       	st	Z, r1
     4ac:	05 c0       	rjmp	.+10     	; 0x4b8 <IR_Update+0x64>
			}else{
			ir->state = IR_DOWN;
     4ae:	83 e0       	ldi	r24, 0x03	; 3
     4b0:	80 83       	st	Z, r24
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <IR_Update+0x64>
		}
		break;
		default:
		ir->state = IR_UP;
     4b4:	81 e0       	ldi	r24, 0x01	; 1
     4b6:	80 83       	st	Z, r24
		break;
	}

	ir->last_sample = sample;
     4b8:	62 83       	std	Z+2, r22	; 0x02
     4ba:	08 95       	ret

000004bc <IR_GetState>:
}

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}
     4bc:	fc 01       	movw	r30, r24
     4be:	81 81       	ldd	r24, Z+1	; 0x01
     4c0:	08 95       	ret

000004c2 <putHeaderOnTx>:
			dataTx->indexR &= dataTx->mask;
		}
	}
}

uint8_t putHeaderOnTx(_sTx  *dataTx, _eCmd ID, uint8_t frameLength){
     4c2:	fc 01       	movw	r30, r24
	dataTx->chk = 0;
     4c4:	15 82       	std	Z+5, r1	; 0x05
	dataTx->buff[dataTx->indexW++]='U';
     4c6:	a0 81       	ld	r26, Z
     4c8:	b1 81       	ldd	r27, Z+1	; 0x01
     4ca:	83 81       	ldd	r24, Z+3	; 0x03
     4cc:	91 e0       	ldi	r25, 0x01	; 1
     4ce:	98 0f       	add	r25, r24
     4d0:	93 83       	std	Z+3, r25	; 0x03
     4d2:	a8 0f       	add	r26, r24
     4d4:	b1 1d       	adc	r27, r1
     4d6:	85 e5       	ldi	r24, 0x55	; 85
     4d8:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4da:	84 81       	ldd	r24, Z+4	; 0x04
     4dc:	93 81       	ldd	r25, Z+3	; 0x03
     4de:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='N';
     4e0:	a0 81       	ld	r26, Z
     4e2:	b1 81       	ldd	r27, Z+1	; 0x01
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	89 0f       	add	r24, r25
     4e8:	83 83       	std	Z+3, r24	; 0x03
     4ea:	a9 0f       	add	r26, r25
     4ec:	b1 1d       	adc	r27, r1
     4ee:	8e e4       	ldi	r24, 0x4E	; 78
     4f0:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     4f2:	84 81       	ldd	r24, Z+4	; 0x04
     4f4:	93 81       	ldd	r25, Z+3	; 0x03
     4f6:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='E';
     4f8:	a0 81       	ld	r26, Z
     4fa:	b1 81       	ldd	r27, Z+1	; 0x01
     4fc:	81 e0       	ldi	r24, 0x01	; 1
     4fe:	89 0f       	add	r24, r25
     500:	83 83       	std	Z+3, r24	; 0x03
     502:	a9 0f       	add	r26, r25
     504:	b1 1d       	adc	r27, r1
     506:	85 e4       	ldi	r24, 0x45	; 69
     508:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     50a:	84 81       	ldd	r24, Z+4	; 0x04
     50c:	93 81       	ldd	r25, Z+3	; 0x03
     50e:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]='R';
     510:	a0 81       	ld	r26, Z
     512:	b1 81       	ldd	r27, Z+1	; 0x01
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	89 0f       	add	r24, r25
     518:	83 83       	std	Z+3, r24	; 0x03
     51a:	a9 0f       	add	r26, r25
     51c:	b1 1d       	adc	r27, r1
     51e:	82 e5       	ldi	r24, 0x52	; 82
     520:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     522:	84 81       	ldd	r24, Z+4	; 0x04
     524:	93 81       	ldd	r25, Z+3	; 0x03
     526:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=frameLength+1;
     528:	a0 81       	ld	r26, Z
     52a:	b1 81       	ldd	r27, Z+1	; 0x01
     52c:	81 e0       	ldi	r24, 0x01	; 1
     52e:	89 0f       	add	r24, r25
     530:	83 83       	std	Z+3, r24	; 0x03
     532:	a9 0f       	add	r26, r25
     534:	b1 1d       	adc	r27, r1
     536:	4f 5f       	subi	r20, 0xFF	; 255
     538:	4c 93       	st	X, r20
	dataTx->indexW &= dataTx->mask;
     53a:	84 81       	ldd	r24, Z+4	; 0x04
     53c:	93 81       	ldd	r25, Z+3	; 0x03
     53e:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=':';
     540:	a0 81       	ld	r26, Z
     542:	b1 81       	ldd	r27, Z+1	; 0x01
     544:	81 e0       	ldi	r24, 0x01	; 1
     546:	89 0f       	add	r24, r25
     548:	83 83       	std	Z+3, r24	; 0x03
     54a:	a9 0f       	add	r26, r25
     54c:	b1 1d       	adc	r27, r1
     54e:	8a e3       	ldi	r24, 0x3A	; 58
     550:	8c 93       	st	X, r24
	dataTx->indexW &= dataTx->mask;
     552:	84 81       	ldd	r24, Z+4	; 0x04
     554:	93 81       	ldd	r25, Z+3	; 0x03
     556:	98 23       	and	r25, r24
	dataTx->buff[dataTx->indexW++]=ID;
     558:	a0 81       	ld	r26, Z
     55a:	b1 81       	ldd	r27, Z+1	; 0x01
     55c:	81 e0       	ldi	r24, 0x01	; 1
     55e:	89 0f       	add	r24, r25
     560:	83 83       	std	Z+3, r24	; 0x03
     562:	a9 0f       	add	r26, r25
     564:	b1 1d       	adc	r27, r1
     566:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     568:	94 81       	ldd	r25, Z+4	; 0x04
     56a:	83 81       	ldd	r24, Z+3	; 0x03
     56c:	98 23       	and	r25, r24
     56e:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= (frameLength+1);
     570:	95 81       	ldd	r25, Z+5	; 0x05
     572:	49 27       	eor	r20, r25
	dataTx->chk ^= ('U' ^'N' ^'E' ^'R' ^ID ^':') ;
     574:	64 27       	eor	r22, r20
     576:	86 e3       	ldi	r24, 0x36	; 54
     578:	86 27       	eor	r24, r22
     57a:	85 83       	std	Z+5, r24	; 0x05
	return  dataTx->chk;
}
     57c:	08 95       	ret

0000057e <putByteOnTx>:
uint8_t putByteOnTx(_sTx *dataTx, uint8_t byte)
{
     57e:	fc 01       	movw	r30, r24
	dataTx->buff[dataTx->indexW++]=byte;
     580:	a0 81       	ld	r26, Z
     582:	b1 81       	ldd	r27, Z+1	; 0x01
     584:	83 81       	ldd	r24, Z+3	; 0x03
     586:	91 e0       	ldi	r25, 0x01	; 1
     588:	98 0f       	add	r25, r24
     58a:	93 83       	std	Z+3, r25	; 0x03
     58c:	a8 0f       	add	r26, r24
     58e:	b1 1d       	adc	r27, r1
     590:	6c 93       	st	X, r22
	dataTx->indexW &= dataTx->mask;
     592:	94 81       	ldd	r25, Z+4	; 0x04
     594:	83 81       	ldd	r24, Z+3	; 0x03
     596:	98 23       	and	r25, r24
     598:	93 83       	std	Z+3, r25	; 0x03
	dataTx->chk ^= byte;
     59a:	85 81       	ldd	r24, Z+5	; 0x05
     59c:	86 27       	eor	r24, r22
     59e:	85 83       	std	Z+5, r24	; 0x05
	return dataTx->chk;
}
     5a0:	08 95       	ret

000005a2 <decodeCommand>:
void decodeCommand(_sRx *dataRx, _sTx *dataTx){
     5a2:	0f 93       	push	r16
     5a4:	1f 93       	push	r17
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	eb 01       	movw	r28, r22
	switch(dataRx->buff[dataRx->indexData]){
     5ac:	dc 01       	movw	r26, r24
     5ae:	ed 91       	ld	r30, X+
     5b0:	fc 91       	ld	r31, X
     5b2:	11 97       	sbiw	r26, 0x01	; 1
     5b4:	14 96       	adiw	r26, 0x04	; 4
     5b6:	8c 91       	ld	r24, X
     5b8:	e8 0f       	add	r30, r24
     5ba:	f1 1d       	adc	r31, r1
     5bc:	60 81       	ld	r22, Z
     5be:	60 3f       	cpi	r22, 0xF0	; 240
     5c0:	39 f0       	breq	.+14     	; 0x5d0 <decodeCommand+0x2e>
     5c2:	61 3f       	cpi	r22, 0xF1	; 241
     5c4:	09 f4       	brne	.+2      	; 0x5c8 <decodeCommand+0x26>
     5c6:	56 c0       	rjmp	.+172    	; 0x674 <decodeCommand+0xd2>
     5c8:	65 3a       	cpi	r22, 0xA5	; 165
     5ca:	09 f0       	breq	.+2      	; 0x5ce <decodeCommand+0x2c>
     5cc:	47 c0       	rjmp	.+142    	; 0x65c <decodeCommand+0xba>
     5ce:	0e c0       	rjmp	.+28     	; 0x5ec <decodeCommand+0x4a>
		
		case ALIVE:
		
			putHeaderOnTx(dataTx, ALIVE, 2);
     5d0:	42 e0       	ldi	r20, 0x02	; 2
     5d2:	60 ef       	ldi	r22, 0xF0	; 240
     5d4:	ce 01       	movw	r24, r28
     5d6:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx, ACK );
     5da:	6d e0       	ldi	r22, 0x0D	; 13
     5dc:	ce 01       	movw	r24, r28
     5de:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     5e2:	6d 81       	ldd	r22, Y+5	; 0x05
     5e4:	ce 01       	movw	r24, r28
     5e6:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		
		break;
     5ea:	44 c0       	rjmp	.+136    	; 0x674 <decodeCommand+0xd2>
		case FIRMWARE:
		break;

		case DATA:
			myWord.ui16[0]	= globalDistance;
     5ec:	0c e9       	ldi	r16, 0x9C	; 156
     5ee:	12 e0       	ldi	r17, 0x02	; 2
     5f0:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <globalDistance>
     5f4:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <globalDistance+0x1>
     5f8:	f8 01       	movw	r30, r16
     5fa:	91 83       	std	Z+1, r25	; 0x01
     5fc:	80 83       	st	Z, r24
			putHeaderOnTx(dataTx, DATA, 7);
     5fe:	47 e0       	ldi	r20, 0x07	; 7
     600:	65 ea       	ldi	r22, 0xA5	; 165
     602:	ce 01       	movw	r24, r28
     604:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx, myWord.ui8[0]);
     608:	d8 01       	movw	r26, r16
     60a:	6c 91       	ld	r22, X
     60c:	ce 01       	movw	r24, r28
     60e:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     612:	f8 01       	movw	r30, r16
     614:	61 81       	ldd	r22, Z+1	; 0x01
     616:	ce 01       	movw	r24, r28
     618:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, boxToTx);
     61c:	60 91 78 01 	lds	r22, 0x0178	; 0x800178 <boxToTx>
     620:	ce 01       	movw	r24, r28
     622:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			myWord.ui16[0] = IR_GetState(&ir_sensor[0]);
     626:	80 ea       	ldi	r24, 0xA0	; 160
     628:	92 e0       	ldi	r25, 0x02	; 2
     62a:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	68 2f       	mov	r22, r24
     632:	d8 01       	movw	r26, r16
     634:	8d 93       	st	X+, r24
     636:	9c 93       	st	X, r25
			putByteOnTx(dataTx, myWord.ui8[0]);
     638:	ce 01       	movw	r24, r28
     63a:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, myWord.ui8[1]);
     63e:	f8 01       	movw	r30, r16
     640:	61 81       	ldd	r22, Z+1	; 0x01
     642:	ce 01       	movw	r24, r28
     644:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, Numbox);
     648:	60 91 61 01 	lds	r22, 0x0161	; 0x800161 <Numbox>
     64c:	ce 01       	movw	r24, r28
     64e:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     652:	6d 81       	ldd	r22, Y+5	; 0x05
     654:	ce 01       	movw	r24, r28
     656:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		break;
     65a:	0c c0       	rjmp	.+24     	; 0x674 <decodeCommand+0xd2>
		//putByteOnTx(dataTx, dataTx->chk);
		//
		//break;

		default:
			putHeaderOnTx(dataTx, (_eCmd)dataRx->buff[dataRx->indexData], 2);
     65c:	42 e0       	ldi	r20, 0x02	; 2
     65e:	ce 01       	movw	r24, r28
     660:	0e 94 61 02 	call	0x4c2	; 0x4c2 <putHeaderOnTx>
			putByteOnTx(dataTx,UNKNOWN );
     664:	6f ef       	ldi	r22, 0xFF	; 255
     666:	ce 01       	movw	r24, r28
     668:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
			putByteOnTx(dataTx, dataTx->chk);
     66c:	6d 81       	ldd	r22, Y+5	; 0x05
     66e:	ce 01       	movw	r24, r28
     670:	0e 94 bf 02 	call	0x57e	; 0x57e <putByteOnTx>
		break;
		
	}
}
     674:	df 91       	pop	r29
     676:	cf 91       	pop	r28
     678:	1f 91       	pop	r17
     67a:	0f 91       	pop	r16
     67c:	08 95       	ret

0000067e <decodeHeader>:
void decodeHeader(_sRx *dataRx){
     67e:	dc 01       	movw	r26, r24
	uint8_t auxIndex=dataRx->indexW;
     680:	13 96       	adiw	r26, 0x03	; 3
     682:	2c 91       	ld	r18, X
     684:	13 97       	sbiw	r26, 0x03	; 3
	while(dataRx->indexR != auxIndex){
     686:	c9 c0       	rjmp	.+402    	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
		switch(dataRx->header)
     688:	18 96       	adiw	r26, 0x08	; 8
     68a:	ec 91       	ld	r30, X
     68c:	18 97       	sbiw	r26, 0x08	; 8
     68e:	4e 2f       	mov	r20, r30
     690:	50 e0       	ldi	r21, 0x00	; 0
     692:	47 30       	cpi	r20, 0x07	; 7
     694:	51 05       	cpc	r21, r1
     696:	08 f0       	brcs	.+2      	; 0x69a <decodeHeader+0x1c>
     698:	b2 c0       	rjmp	.+356    	; 0x7fe <decodeHeader+0x180>
     69a:	fa 01       	movw	r30, r20
     69c:	ec 5c       	subi	r30, 0xCC	; 204
     69e:	ff 4f       	sbci	r31, 0xFF	; 255
     6a0:	0c 94 f7 07 	jmp	0xfee	; 0xfee <__tablejump2__>
		{
			case HEADER_U:
			if(dataRx->buff[dataRx->indexR] == 'U'){
     6a4:	ed 91       	ld	r30, X+
     6a6:	fc 91       	ld	r31, X
     6a8:	11 97       	sbiw	r26, 0x01	; 1
     6aa:	e8 0f       	add	r30, r24
     6ac:	f1 1d       	adc	r31, r1
     6ae:	80 81       	ld	r24, Z
     6b0:	85 35       	cpi	r24, 0x55	; 85
     6b2:	09 f0       	breq	.+2      	; 0x6b6 <decodeHeader+0x38>
     6b4:	a7 c0       	rjmp	.+334    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				dataRx->header = HEADER_N;
     6b6:	81 e0       	ldi	r24, 0x01	; 1
     6b8:	18 96       	adiw	r26, 0x08	; 8
     6ba:	8c 93       	st	X, r24
     6bc:	18 97       	sbiw	r26, 0x08	; 8
     6be:	a2 c0       	rjmp	.+324    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case HEADER_N:
			if(dataRx->buff[dataRx->indexR] == 'N'){
     6c0:	ed 91       	ld	r30, X+
     6c2:	fc 91       	ld	r31, X
     6c4:	11 97       	sbiw	r26, 0x01	; 1
     6c6:	e8 0f       	add	r30, r24
     6c8:	f1 1d       	adc	r31, r1
     6ca:	90 81       	ld	r25, Z
     6cc:	9e 34       	cpi	r25, 0x4E	; 78
     6ce:	29 f4       	brne	.+10     	; 0x6da <decodeHeader+0x5c>
				dataRx->header = HEADER_E;
     6d0:	82 e0       	ldi	r24, 0x02	; 2
     6d2:	18 96       	adiw	r26, 0x08	; 8
     6d4:	8c 93       	st	X, r24
     6d6:	18 97       	sbiw	r26, 0x08	; 8
     6d8:	95 c0       	rjmp	.+298    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				if(dataRx->buff[dataRx->indexR] != 'U'){
     6da:	95 35       	cpi	r25, 0x55	; 85
     6dc:	09 f4       	brne	.+2      	; 0x6e0 <decodeHeader+0x62>
     6de:	92 c0       	rjmp	.+292    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
					dataRx->header = HEADER_U;
     6e0:	18 96       	adiw	r26, 0x08	; 8
     6e2:	1c 92       	st	X, r1
     6e4:	18 97       	sbiw	r26, 0x08	; 8
					dataRx->indexR--;
     6e6:	81 50       	subi	r24, 0x01	; 1
     6e8:	12 96       	adiw	r26, 0x02	; 2
     6ea:	8c 93       	st	X, r24
     6ec:	12 97       	sbiw	r26, 0x02	; 2
     6ee:	8a c0       	rjmp	.+276    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}
			}
			break;
			case HEADER_E:
			if(dataRx->buff[dataRx->indexR] == 'E'){
     6f0:	ed 91       	ld	r30, X+
     6f2:	fc 91       	ld	r31, X
     6f4:	11 97       	sbiw	r26, 0x01	; 1
     6f6:	e8 0f       	add	r30, r24
     6f8:	f1 1d       	adc	r31, r1
     6fa:	90 81       	ld	r25, Z
     6fc:	95 34       	cpi	r25, 0x45	; 69
     6fe:	29 f4       	brne	.+10     	; 0x70a <decodeHeader+0x8c>
				dataRx->header = HEADER_R;
     700:	83 e0       	ldi	r24, 0x03	; 3
     702:	18 96       	adiw	r26, 0x08	; 8
     704:	8c 93       	st	X, r24
     706:	18 97       	sbiw	r26, 0x08	; 8
     708:	7d c0       	rjmp	.+250    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     70a:	18 96       	adiw	r26, 0x08	; 8
     70c:	1c 92       	st	X, r1
     70e:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     710:	81 50       	subi	r24, 0x01	; 1
     712:	12 96       	adiw	r26, 0x02	; 2
     714:	8c 93       	st	X, r24
     716:	12 97       	sbiw	r26, 0x02	; 2
     718:	75 c0       	rjmp	.+234    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case HEADER_R:
			if(dataRx->buff[dataRx->indexR] == 'R'){
     71a:	ed 91       	ld	r30, X+
     71c:	fc 91       	ld	r31, X
     71e:	11 97       	sbiw	r26, 0x01	; 1
     720:	e8 0f       	add	r30, r24
     722:	f1 1d       	adc	r31, r1
     724:	90 81       	ld	r25, Z
     726:	92 35       	cpi	r25, 0x52	; 82
     728:	29 f4       	brne	.+10     	; 0x734 <decodeHeader+0xb6>
				dataRx->header = NBYTES;
     72a:	84 e0       	ldi	r24, 0x04	; 4
     72c:	18 96       	adiw	r26, 0x08	; 8
     72e:	8c 93       	st	X, r24
     730:	18 97       	sbiw	r26, 0x08	; 8
     732:	68 c0       	rjmp	.+208    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     734:	18 96       	adiw	r26, 0x08	; 8
     736:	1c 92       	st	X, r1
     738:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     73a:	81 50       	subi	r24, 0x01	; 1
     73c:	12 96       	adiw	r26, 0x02	; 2
     73e:	8c 93       	st	X, r24
     740:	12 97       	sbiw	r26, 0x02	; 2
     742:	60 c0       	rjmp	.+192    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case NBYTES:
			dataRx->nBytes=dataRx->buff[dataRx->indexR];
     744:	ed 91       	ld	r30, X+
     746:	fc 91       	ld	r31, X
     748:	11 97       	sbiw	r26, 0x01	; 1
     74a:	e8 0f       	add	r30, r24
     74c:	f1 1d       	adc	r31, r1
     74e:	80 81       	ld	r24, Z
     750:	17 96       	adiw	r26, 0x07	; 7
     752:	8c 93       	st	X, r24
     754:	17 97       	sbiw	r26, 0x07	; 7
			dataRx->header = TOKEN;
     756:	85 e0       	ldi	r24, 0x05	; 5
     758:	18 96       	adiw	r26, 0x08	; 8
     75a:	8c 93       	st	X, r24
     75c:	18 97       	sbiw	r26, 0x08	; 8
			break;
     75e:	52 c0       	rjmp	.+164    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			case TOKEN:
			if(dataRx->buff[dataRx->indexR] == ':'){
     760:	ed 91       	ld	r30, X+
     762:	fc 91       	ld	r31, X
     764:	11 97       	sbiw	r26, 0x01	; 1
     766:	e8 0f       	add	r30, r24
     768:	f1 1d       	adc	r31, r1
     76a:	90 81       	ld	r25, Z
     76c:	9a 33       	cpi	r25, 0x3A	; 58
     76e:	a9 f4       	brne	.+42     	; 0x79a <decodeHeader+0x11c>
				dataRx->header = PAYLOAD;
     770:	96 e0       	ldi	r25, 0x06	; 6
     772:	18 96       	adiw	r26, 0x08	; 8
     774:	9c 93       	st	X, r25
     776:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexData = dataRx->indexR+1;
     778:	8f 5f       	subi	r24, 0xFF	; 255
				dataRx->indexData &= dataRx->mask;
     77a:	15 96       	adiw	r26, 0x05	; 5
     77c:	9c 91       	ld	r25, X
     77e:	15 97       	sbiw	r26, 0x05	; 5
     780:	89 23       	and	r24, r25
     782:	14 96       	adiw	r26, 0x04	; 4
     784:	8c 93       	st	X, r24
     786:	14 97       	sbiw	r26, 0x04	; 4
				dataRx->chk = 0;
				dataRx->chk ^= ('U' ^'N' ^'E' ^'R' ^dataRx->nBytes ^':') ;
     788:	17 96       	adiw	r26, 0x07	; 7
     78a:	9c 91       	ld	r25, X
     78c:	17 97       	sbiw	r26, 0x07	; 7
     78e:	86 e3       	ldi	r24, 0x36	; 54
     790:	89 27       	eor	r24, r25
     792:	16 96       	adiw	r26, 0x06	; 6
     794:	8c 93       	st	X, r24
     796:	16 97       	sbiw	r26, 0x06	; 6
     798:	35 c0       	rjmp	.+106    	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     79a:	18 96       	adiw	r26, 0x08	; 8
     79c:	1c 92       	st	X, r1
     79e:	18 97       	sbiw	r26, 0x08	; 8
				dataRx->indexR--;
     7a0:	81 50       	subi	r24, 0x01	; 1
     7a2:	12 96       	adiw	r26, 0x02	; 2
     7a4:	8c 93       	st	X, r24
     7a6:	12 97       	sbiw	r26, 0x02	; 2
     7a8:	2d c0       	rjmp	.+90     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			case PAYLOAD:
			dataRx->nBytes--;
     7aa:	17 96       	adiw	r26, 0x07	; 7
     7ac:	9c 91       	ld	r25, X
     7ae:	17 97       	sbiw	r26, 0x07	; 7
     7b0:	91 50       	subi	r25, 0x01	; 1
     7b2:	17 96       	adiw	r26, 0x07	; 7
     7b4:	9c 93       	st	X, r25
     7b6:	17 97       	sbiw	r26, 0x07	; 7
			if(dataRx->nBytes>0){
     7b8:	99 23       	and	r25, r25
     7ba:	71 f0       	breq	.+28     	; 0x7d8 <decodeHeader+0x15a>
				dataRx->chk ^= dataRx->buff[dataRx->indexR];
     7bc:	ed 91       	ld	r30, X+
     7be:	fc 91       	ld	r31, X
     7c0:	11 97       	sbiw	r26, 0x01	; 1
     7c2:	e8 0f       	add	r30, r24
     7c4:	f1 1d       	adc	r31, r1
     7c6:	80 81       	ld	r24, Z
     7c8:	16 96       	adiw	r26, 0x06	; 6
     7ca:	9c 91       	ld	r25, X
     7cc:	16 97       	sbiw	r26, 0x06	; 6
     7ce:	89 27       	eor	r24, r25
     7d0:	16 96       	adiw	r26, 0x06	; 6
     7d2:	8c 93       	st	X, r24
     7d4:	16 97       	sbiw	r26, 0x06	; 6
     7d6:	16 c0       	rjmp	.+44     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				}else{
				dataRx->header = HEADER_U;
     7d8:	18 96       	adiw	r26, 0x08	; 8
     7da:	1c 92       	st	X, r1
     7dc:	18 97       	sbiw	r26, 0x08	; 8
				if(dataRx->buff[dataRx->indexR] == dataRx->chk)
     7de:	ed 91       	ld	r30, X+
     7e0:	fc 91       	ld	r31, X
     7e2:	11 97       	sbiw	r26, 0x01	; 1
     7e4:	e8 0f       	add	r30, r24
     7e6:	f1 1d       	adc	r31, r1
     7e8:	90 81       	ld	r25, Z
     7ea:	16 96       	adiw	r26, 0x06	; 6
     7ec:	8c 91       	ld	r24, X
     7ee:	16 97       	sbiw	r26, 0x06	; 6
     7f0:	98 13       	cpse	r25, r24
     7f2:	08 c0       	rjmp	.+16     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				dataRx->isComannd = TRUE;
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	1a 96       	adiw	r26, 0x0a	; 10
     7f8:	8c 93       	st	X, r24
     7fa:	1a 97       	sbiw	r26, 0x0a	; 10
     7fc:	03 c0       	rjmp	.+6      	; 0x804 <__DATA_REGION_LENGTH__+0x4>
			}
			break;
			default:
			dataRx->header = HEADER_U;
     7fe:	18 96       	adiw	r26, 0x08	; 8
     800:	1c 92       	st	X, r1
     802:	18 97       	sbiw	r26, 0x08	; 8
			break;
		}
		dataRx->indexR++;
     804:	12 96       	adiw	r26, 0x02	; 2
     806:	8c 91       	ld	r24, X
     808:	12 97       	sbiw	r26, 0x02	; 2
     80a:	8f 5f       	subi	r24, 0xFF	; 255
		dataRx->indexR &= dataRx->mask;
     80c:	15 96       	adiw	r26, 0x05	; 5
     80e:	9c 91       	ld	r25, X
     810:	15 97       	sbiw	r26, 0x05	; 5
     812:	89 23       	and	r24, r25
     814:	12 96       	adiw	r26, 0x02	; 2
     816:	8c 93       	st	X, r24
     818:	12 97       	sbiw	r26, 0x02	; 2
		
	}
}
void decodeHeader(_sRx *dataRx){
	uint8_t auxIndex=dataRx->indexW;
	while(dataRx->indexR != auxIndex){
     81a:	12 96       	adiw	r26, 0x02	; 2
     81c:	8c 91       	ld	r24, X
     81e:	12 97       	sbiw	r26, 0x02	; 2
     820:	28 13       	cpse	r18, r24
     822:	32 cf       	rjmp	.-412    	; 0x688 <decodeHeader+0xa>
			break;
		}
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}
     824:	08 95       	ret

00000826 <serialTask>:

uint8_t IR_GetState( IRDebounce *ir) {
	return ir->stateConfirmed;
}

void serialTask(_sRx* dataRx, _sTx* dataTx){
     826:	0f 93       	push	r16
     828:	1f 93       	push	r17
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	8c 01       	movw	r16, r24
     830:	eb 01       	movw	r28, r22
	if(dataRx->isComannd){
     832:	fc 01       	movw	r30, r24
     834:	82 85       	ldd	r24, Z+10	; 0x0a
     836:	88 23       	and	r24, r24
     838:	21 f0       	breq	.+8      	; 0x842 <serialTask+0x1c>
		dataRx->isComannd=FALSE;
     83a:	12 86       	std	Z+10, r1	; 0x0a
		decodeCommand(dataRx,dataTx);
     83c:	c8 01       	movw	r24, r16
     83e:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <decodeCommand>
	}
	if(dataRx->indexR!=dataRx->indexW){
     842:	f8 01       	movw	r30, r16
     844:	92 81       	ldd	r25, Z+2	; 0x02
     846:	83 81       	ldd	r24, Z+3	; 0x03
     848:	98 17       	cp	r25, r24
     84a:	19 f0       	breq	.+6      	; 0x852 <serialTask+0x2c>
		
		decodeHeader(dataRx);
     84c:	c8 01       	movw	r24, r16
     84e:	0e 94 3f 03 	call	0x67e	; 0x67e <decodeHeader>
	}
	if (dataTx->indexR!= dataTx->indexW) {
     852:	8a 81       	ldd	r24, Y+2	; 0x02
     854:	9b 81       	ldd	r25, Y+3	; 0x03
     856:	89 17       	cp	r24, r25
     858:	91 f0       	breq	.+36     	; 0x87e <serialTask+0x58>
		if (UCSR0A & (1 << UDRE0)) { // Si el buffer de transmisión está vacío
     85a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     85e:	95 ff       	sbrs	r25, 5
     860:	0e c0       	rjmp	.+28     	; 0x87e <serialTask+0x58>
			UDR0 = dataTx->buff[dataTx->indexR++]; // Enviar el dato
     862:	e8 81       	ld	r30, Y
     864:	f9 81       	ldd	r31, Y+1	; 0x01
     866:	91 e0       	ldi	r25, 0x01	; 1
     868:	98 0f       	add	r25, r24
     86a:	9a 83       	std	Y+2, r25	; 0x02
     86c:	e8 0f       	add	r30, r24
     86e:	f1 1d       	adc	r31, r1
     870:	80 81       	ld	r24, Z
     872:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
			dataTx->indexR &= dataTx->mask;
     876:	8c 81       	ldd	r24, Y+4	; 0x04
     878:	9a 81       	ldd	r25, Y+2	; 0x02
     87a:	89 23       	and	r24, r25
     87c:	8a 83       	std	Y+2, r24	; 0x02
		}
	}
}
     87e:	df 91       	pop	r29
     880:	cf 91       	pop	r28
     882:	1f 91       	pop	r17
     884:	0f 91       	pop	r16
     886:	08 95       	ret

00000888 <sensorMeasure>:
	countservoReset--;
}

void sensorMeasure(uint16_t distance){
	
	globalDistance = distance;
     888:	90 93 60 01 	sts	0x0160, r25	; 0x800160 <globalDistance+0x1>
     88c:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <globalDistance>
     890:	08 95       	ret

00000892 <addBox>:
	
}

void addBox(uint16_t distance){
     892:	cf 93       	push	r28
	static uint8_t i = 1, j = 1, k = 1;
	
	if ((distance >= Cm13) && (distance < Cm15)) { //si la distancia se encuentra entre 15 y 13 cm es caja chica
     894:	9c 01       	movw	r18, r24
     896:	22 5f       	subi	r18, 0xF2	; 242
     898:	32 40       	sbci	r19, 0x02	; 2
     89a:	24 37       	cpi	r18, 0x74	; 116
     89c:	31 05       	cpc	r19, r1
     89e:	d0 f5       	brcc	.+116    	; 0x914 <__stack+0x15>
		Cajita[Numbox].boxState=isOn;
     8a0:	e0 91 61 01 	lds	r30, 0x0161	; 0x800161 <Numbox>
     8a4:	f0 e0       	ldi	r31, 0x00	; 0
     8a6:	ee 0f       	add	r30, r30
     8a8:	ff 1f       	adc	r31, r31
     8aa:	e4 51       	subi	r30, 0x14	; 20
     8ac:	fc 4f       	sbci	r31, 0xFC	; 252
     8ae:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=SmallBox;
     8b0:	91 e0       	ldi	r25, 0x01	; 1
     8b2:	90 83       	st	Z, r25
		boxToTx = 0x4;
     8b4:	84 e0       	ldi	r24, 0x04	; 4
     8b6:	80 93 78 01 	sts	0x0178, r24	; 0x800178 <boxToTx>
		CajitaArr[0][i] = 1;
     8ba:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <i.2284>
     8be:	e8 2f       	mov	r30, r24
     8c0:	f0 e0       	ldi	r31, 0x00	; 0
     8c2:	e0 55       	subi	r30, 0x50	; 80
     8c4:	fd 4f       	sbci	r31, 0xFD	; 253
     8c6:	90 83       	st	Z, r25
		i++;
     8c8:	8f 5f       	subi	r24, 0xFF	; 255
     8ca:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <i.2284>
			
		printf("Fila SmallBox: ");
     8ce:	8c e1       	ldi	r24, 0x1C	; 28
     8d0:	91 e0       	ldi	r25, 0x01	; 1
     8d2:	9f 93       	push	r25
     8d4:	8f 93       	push	r24
     8d6:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		for (uint8_t n = 0; n < 20; n++) {
     8da:	0f 90       	pop	r0
     8dc:	0f 90       	pop	r0
     8de:	c0 e0       	ldi	r28, 0x00	; 0
     8e0:	12 c0       	rjmp	.+36     	; 0x906 <__stack+0x7>
			printf("%u ", CajitaArr[0][n]);
     8e2:	ec 2f       	mov	r30, r28
     8e4:	f0 e0       	ldi	r31, 0x00	; 0
     8e6:	e0 55       	subi	r30, 0x50	; 80
     8e8:	fd 4f       	sbci	r31, 0xFD	; 253
     8ea:	80 81       	ld	r24, Z
     8ec:	1f 92       	push	r1
     8ee:	8f 93       	push	r24
     8f0:	8c e2       	ldi	r24, 0x2C	; 44
     8f2:	91 e0       	ldi	r25, 0x01	; 1
     8f4:	9f 93       	push	r25
     8f6:	8f 93       	push	r24
     8f8:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		boxToTx = 0x4;
		CajitaArr[0][i] = 1;
		i++;
			
		printf("Fila SmallBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     8fc:	cf 5f       	subi	r28, 0xFF	; 255
     8fe:	0f 90       	pop	r0
     900:	0f 90       	pop	r0
     902:	0f 90       	pop	r0
     904:	0f 90       	pop	r0
     906:	c4 31       	cpi	r28, 0x14	; 20
     908:	60 f3       	brcs	.-40     	; 0x8e2 <addBox+0x50>
			printf("%u ", CajitaArr[0][n]);
		}
		printf("\n");
     90a:	8a e0       	ldi	r24, 0x0A	; 10
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	0e 94 43 09 	call	0x1286	; 0x1286 <putchar>
     912:	a5 c0       	rjmp	.+330    	; 0xa5e <__stack+0x15f>
	}
	else if ((distance >= Cm11) && (distance < Cm13)){
     914:	9c 01       	movw	r18, r24
     916:	2e 57       	subi	r18, 0x7E	; 126
     918:	32 40       	sbci	r19, 0x02	; 2
     91a:	24 37       	cpi	r18, 0x74	; 116
     91c:	31 05       	cpc	r19, r1
     91e:	08 f0       	brcs	.+2      	; 0x922 <__stack+0x23>
     920:	44 c0       	rjmp	.+136    	; 0x9aa <__stack+0xab>
		Cajita[Numbox].boxState=isOn;
     922:	e0 91 61 01 	lds	r30, 0x0161	; 0x800161 <Numbox>
     926:	f0 e0       	ldi	r31, 0x00	; 0
     928:	ee 0f       	add	r30, r30
     92a:	ff 1f       	adc	r31, r31
     92c:	e4 51       	subi	r30, 0x14	; 20
     92e:	fc 4f       	sbci	r31, 0xFC	; 252
     930:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=MediumBox;
     932:	82 e0       	ldi	r24, 0x02	; 2
     934:	80 83       	st	Z, r24
		boxToTx = 0x2;
     936:	80 93 78 01 	sts	0x0178, r24	; 0x800178 <boxToTx>
		CajitaArr[1][j] = 1;
     93a:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <j.2285>
     93e:	e9 2f       	mov	r30, r25
     940:	f0 e0       	ldi	r31, 0x00	; 0
     942:	e0 55       	subi	r30, 0x50	; 80
     944:	fd 4f       	sbci	r31, 0xFD	; 253
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	84 8b       	std	Z+20, r24	; 0x14
		CajitaArr[0][i] = 0;
     94a:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <i.2284>
     94e:	e8 2f       	mov	r30, r24
     950:	f0 e0       	ldi	r31, 0x00	; 0
     952:	e0 55       	subi	r30, 0x50	; 80
     954:	fd 4f       	sbci	r31, 0xFD	; 253
     956:	10 82       	st	Z, r1
		j++;
     958:	9f 5f       	subi	r25, 0xFF	; 255
     95a:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <j.2285>
		i++;
     95e:	8f 5f       	subi	r24, 0xFF	; 255
     960:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <i.2284>
			
		printf("Fila MediumBox: ");
     964:	80 e3       	ldi	r24, 0x30	; 48
     966:	91 e0       	ldi	r25, 0x01	; 1
     968:	9f 93       	push	r25
     96a:	8f 93       	push	r24
     96c:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		for (uint8_t n = 0; n < 20; n++) {
     970:	0f 90       	pop	r0
     972:	0f 90       	pop	r0
     974:	c0 e0       	ldi	r28, 0x00	; 0
     976:	12 c0       	rjmp	.+36     	; 0x99c <__stack+0x9d>
			printf("%u ", CajitaArr[1][n]);
     978:	ec 2f       	mov	r30, r28
     97a:	f0 e0       	ldi	r31, 0x00	; 0
     97c:	e0 55       	subi	r30, 0x50	; 80
     97e:	fd 4f       	sbci	r31, 0xFD	; 253
     980:	84 89       	ldd	r24, Z+20	; 0x14
     982:	1f 92       	push	r1
     984:	8f 93       	push	r24
     986:	8c e2       	ldi	r24, 0x2C	; 44
     988:	91 e0       	ldi	r25, 0x01	; 1
     98a:	9f 93       	push	r25
     98c:	8f 93       	push	r24
     98e:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		CajitaArr[0][i] = 0;
		j++;
		i++;
			
		printf("Fila MediumBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     992:	cf 5f       	subi	r28, 0xFF	; 255
     994:	0f 90       	pop	r0
     996:	0f 90       	pop	r0
     998:	0f 90       	pop	r0
     99a:	0f 90       	pop	r0
     99c:	c4 31       	cpi	r28, 0x14	; 20
     99e:	60 f3       	brcs	.-40     	; 0x978 <__stack+0x79>
			printf("%u ", CajitaArr[1][n]);
		}
		printf("\n");
     9a0:	8a e0       	ldi	r24, 0x0A	; 10
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	0e 94 43 09 	call	0x1286	; 0x1286 <putchar>
     9a8:	5a c0       	rjmp	.+180    	; 0xa5e <__stack+0x15f>
	}
	else if ((distance >= Cm9) && (distance < Cm11)){
     9aa:	8a 50       	subi	r24, 0x0A	; 10
     9ac:	92 40       	sbci	r25, 0x02	; 2
     9ae:	84 37       	cpi	r24, 0x74	; 116
     9b0:	91 05       	cpc	r25, r1
     9b2:	08 f0       	brcs	.+2      	; 0x9b6 <__stack+0xb7>
     9b4:	4e c0       	rjmp	.+156    	; 0xa52 <__stack+0x153>
		Cajita[Numbox].boxState=isOn;
     9b6:	e0 91 61 01 	lds	r30, 0x0161	; 0x800161 <Numbox>
     9ba:	f0 e0       	ldi	r31, 0x00	; 0
     9bc:	ee 0f       	add	r30, r30
     9be:	ff 1f       	adc	r31, r31
     9c0:	e4 51       	subi	r30, 0x14	; 20
     9c2:	fc 4f       	sbci	r31, 0xFC	; 252
     9c4:	11 82       	std	Z+1, r1	; 0x01
		Cajita[Numbox].boxSize=LargeBox;
     9c6:	83 e0       	ldi	r24, 0x03	; 3
     9c8:	80 83       	st	Z, r24
		boxToTx = 0x1;
     9ca:	31 e0       	ldi	r19, 0x01	; 1
     9cc:	30 93 78 01 	sts	0x0178, r19	; 0x800178 <boxToTx>
		CajitaArr[0][i] = 0;
     9d0:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <i.2284>
     9d4:	e9 2f       	mov	r30, r25
     9d6:	f0 e0       	ldi	r31, 0x00	; 0
     9d8:	e0 55       	subi	r30, 0x50	; 80
     9da:	fd 4f       	sbci	r31, 0xFD	; 253
     9dc:	10 82       	st	Z, r1
		CajitaArr[1][j] = 0;
     9de:	20 91 07 01 	lds	r18, 0x0107	; 0x800107 <j.2285>
     9e2:	e2 2f       	mov	r30, r18
     9e4:	f0 e0       	ldi	r31, 0x00	; 0
     9e6:	e0 55       	subi	r30, 0x50	; 80
     9e8:	fd 4f       	sbci	r31, 0xFD	; 253
     9ea:	14 8a       	std	Z+20, r1	; 0x14
		CajitaArr[2][k] = 1;
     9ec:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <k.2286>
     9f0:	e8 2f       	mov	r30, r24
     9f2:	f0 e0       	ldi	r31, 0x00	; 0
     9f4:	e0 55       	subi	r30, 0x50	; 80
     9f6:	fd 4f       	sbci	r31, 0xFD	; 253
     9f8:	30 a7       	std	Z+40, r19	; 0x28
		j++;
     9fa:	2f 5f       	subi	r18, 0xFF	; 255
     9fc:	20 93 07 01 	sts	0x0107, r18	; 0x800107 <j.2285>
		i++;
     a00:	9f 5f       	subi	r25, 0xFF	; 255
     a02:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <i.2284>
		k++;
     a06:	8f 5f       	subi	r24, 0xFF	; 255
     a08:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <k.2286>
					
		printf("Fila LargeBox: ");
     a0c:	81 e4       	ldi	r24, 0x41	; 65
     a0e:	91 e0       	ldi	r25, 0x01	; 1
     a10:	9f 93       	push	r25
     a12:	8f 93       	push	r24
     a14:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		for (uint8_t n = 0; n < 20; n++) {
     a18:	0f 90       	pop	r0
     a1a:	0f 90       	pop	r0
     a1c:	c0 e0       	ldi	r28, 0x00	; 0
     a1e:	12 c0       	rjmp	.+36     	; 0xa44 <__stack+0x145>
			printf("%u ", CajitaArr[2][n]);
     a20:	ec 2f       	mov	r30, r28
     a22:	f0 e0       	ldi	r31, 0x00	; 0
     a24:	e0 55       	subi	r30, 0x50	; 80
     a26:	fd 4f       	sbci	r31, 0xFD	; 253
     a28:	80 a5       	ldd	r24, Z+40	; 0x28
     a2a:	1f 92       	push	r1
     a2c:	8f 93       	push	r24
     a2e:	8c e2       	ldi	r24, 0x2C	; 44
     a30:	91 e0       	ldi	r25, 0x01	; 1
     a32:	9f 93       	push	r25
     a34:	8f 93       	push	r24
     a36:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		j++;
		i++;
		k++;
					
		printf("Fila LargeBox: ");
		for (uint8_t n = 0; n < 20; n++) {
     a3a:	cf 5f       	subi	r28, 0xFF	; 255
     a3c:	0f 90       	pop	r0
     a3e:	0f 90       	pop	r0
     a40:	0f 90       	pop	r0
     a42:	0f 90       	pop	r0
     a44:	c4 31       	cpi	r28, 0x14	; 20
     a46:	60 f3       	brcs	.-40     	; 0xa20 <__stack+0x121>
			printf("%u ", CajitaArr[2][n]);
		}
		printf("\n");
     a48:	8a e0       	ldi	r24, 0x0A	; 10
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	0e 94 43 09 	call	0x1286	; 0x1286 <putchar>
     a50:	06 c0       	rjmp	.+12     	; 0xa5e <__stack+0x15f>
		
	}
	else if ((distance < Cm9) || (distance >= Cm15)){
     a52:	8c 35       	cpi	r24, 0x5C	; 92
     a54:	91 40       	sbci	r25, 0x01	; 1
     a56:	18 f0       	brcs	.+6      	; 0xa5e <__stack+0x15f>
		Cajita->boxSize=NotSelected;
     a58:	84 e0       	ldi	r24, 0x04	; 4
     a5a:	80 93 ec 03 	sts	0x03EC, r24	; 0x8003ec <Cajita>
	}
	Numbox++;
     a5e:	80 91 61 01 	lds	r24, 0x0161	; 0x800161 <Numbox>
     a62:	8f 5f       	subi	r24, 0xFF	; 255
     a64:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <Numbox>
	
	if(Numbox>=bufferBox) //reinicio el buffer
     a68:	8f 30       	cpi	r24, 0x0F	; 15
     a6a:	10 f0       	brcs	.+4      	; 0xa70 <__stack+0x171>
	Numbox=0;
     a6c:	10 92 61 01 	sts	0x0161, r1	; 0x800161 <Numbox>
}
     a70:	cf 91       	pop	r28
     a72:	08 95       	ret

00000a74 <newBox>:

void newBox(uint16_t distance){
     a74:	cf 93       	push	r28
     a76:	df 93       	push	r29
	if(distance<Cm18){
     a78:	8c 34       	cpi	r24, 0x4C	; 76
     a7a:	24 e0       	ldi	r18, 0x04	; 4
     a7c:	92 07       	cpc	r25, r18
     a7e:	00 f5       	brcc	.+64     	; 0xac0 <newBox+0x4c>
     a80:	ec 01       	movw	r28, r24
		if((IR_GetState(&ir_sensor[0]) == 0) && !MEASURINGBOX){
     a82:	80 ea       	ldi	r24, 0xA0	; 160
     a84:	92 e0       	ldi	r25, 0x02	; 2
     a86:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     a8a:	81 11       	cpse	r24, r1
     a8c:	0e c0       	rjmp	.+28     	; 0xaaa <newBox+0x36>
     a8e:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     a92:	81 fd       	sbrc	r24, 1
     a94:	0a c0       	rjmp	.+20     	; 0xaaa <newBox+0x36>
			MEASURINGBOX=TRUE;
     a96:	82 60       	ori	r24, 0x02	; 2
     a98:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
			addBox(distance);
     a9c:	ce 01       	movw	r24, r28
     a9e:	0e 94 49 04 	call	0x892	; 0x892 <addBox>
			PORTB ^=(1<<LED_BI);
     aa2:	95 b1       	in	r25, 0x05	; 5
     aa4:	80 e2       	ldi	r24, 0x20	; 32
     aa6:	89 27       	eor	r24, r25
     aa8:	85 b9       	out	0x05, r24	; 5
		}
		if ((IR_GetState(&ir_sensor[0]) == 1)) //si IR no mide
     aaa:	80 ea       	ldi	r24, 0xA0	; 160
     aac:	92 e0       	ldi	r25, 0x02	; 2
     aae:	0e 94 5e 02 	call	0x4bc	; 0x4bc <IR_GetState>
     ab2:	81 30       	cpi	r24, 0x01	; 1
     ab4:	29 f4       	brne	.+10     	; 0xac0 <newBox+0x4c>
				MEASURINGBOX=FALSE;
     ab6:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     aba:	8d 7f       	andi	r24, 0xFD	; 253
     abc:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
	}
}
     ac0:	df 91       	pop	r29
     ac2:	cf 91       	pop	r28
     ac4:	08 95       	ret

00000ac6 <kickBox>:

void kickBox(){
	

	if (ir_sensor[1].state== IR_FALLING){
     ac6:	80 91 a4 02 	lds	r24, 0x02A4	; 0x8002a4 <ir_sensor+0x4>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	61 f5       	brne	.+88     	; 0xb26 <kickBox+0x60>
		sIR1++;
     ace:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <sIR1>
     ad2:	8f 5f       	subi	r24, 0xFF	; 255
     ad4:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <sIR1>
		printf("%u ", sIR1);
     ad8:	1f 92       	push	r1
     ada:	8f 93       	push	r24
     adc:	8c e2       	ldi	r24, 0x2C	; 44
     ade:	91 e0       	ldi	r25, 0x01	; 1
     ae0:	9f 93       	push	r25
     ae2:	8f 93       	push	r24
     ae4:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		waittt = 0;
     ae8:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <waittt>
		if(CajitaArr[0][sIR1] == 1){
     aec:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <sIR1>
     af0:	f0 e0       	ldi	r31, 0x00	; 0
     af2:	e0 55       	subi	r30, 0x50	; 80
     af4:	fd 4f       	sbci	r31, 0xFD	; 253
     af6:	80 81       	ld	r24, Z
     af8:	0f 90       	pop	r0
     afa:	0f 90       	pop	r0
     afc:	0f 90       	pop	r0
     afe:	0f 90       	pop	r0
     b00:	81 30       	cpi	r24, 0x01	; 1
     b02:	89 f4       	brne	.+34     	; 0xb26 <kickBox+0x60>
			printf("ENTRE: ");
     b04:	81 e5       	ldi	r24, 0x51	; 81
     b06:	91 e0       	ldi	r25, 0x01	; 1
     b08:	9f 93       	push	r25
     b0a:	8f 93       	push	r24
     b0c:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
			printf("\n");
     b10:	8a e0       	ldi	r24, 0x0A	; 10
     b12:	90 e0       	ldi	r25, 0x00	; 0
     b14:	0e 94 43 09 	call	0x1286	; 0x1286 <putchar>
			Kick1=1;
     b18:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     b1c:	84 60       	ori	r24, 0x04	; 4
     b1e:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
     b22:	0f 90       	pop	r0
     b24:	0f 90       	pop	r0
		}
	}
	
	if (ir_sensor[2].state== IR_FALLING){
     b26:	80 91 a8 02 	lds	r24, 0x02A8	; 0x8002a8 <ir_sensor+0x8>
     b2a:	82 30       	cpi	r24, 0x02	; 2
     b2c:	61 f5       	brne	.+88     	; 0xb86 <kickBox+0xc0>
		sIR2++;
     b2e:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <sIR2>
     b32:	8f 5f       	subi	r24, 0xFF	; 255
     b34:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <sIR2>
		printf("%u ", sIR2);
     b38:	1f 92       	push	r1
     b3a:	8f 93       	push	r24
     b3c:	8c e2       	ldi	r24, 0x2C	; 44
     b3e:	91 e0       	ldi	r25, 0x01	; 1
     b40:	9f 93       	push	r25
     b42:	8f 93       	push	r24
     b44:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		waittt = 0;
     b48:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <waittt>
		if(CajitaArr[1][sIR2] == 1){
     b4c:	e0 91 5d 01 	lds	r30, 0x015D	; 0x80015d <sIR2>
     b50:	f0 e0       	ldi	r31, 0x00	; 0
     b52:	e0 55       	subi	r30, 0x50	; 80
     b54:	fd 4f       	sbci	r31, 0xFD	; 253
     b56:	84 89       	ldd	r24, Z+20	; 0x14
     b58:	0f 90       	pop	r0
     b5a:	0f 90       	pop	r0
     b5c:	0f 90       	pop	r0
     b5e:	0f 90       	pop	r0
     b60:	81 30       	cpi	r24, 0x01	; 1
     b62:	89 f4       	brne	.+34     	; 0xb86 <kickBox+0xc0>
			printf("ENTRE: ");
     b64:	81 e5       	ldi	r24, 0x51	; 81
     b66:	91 e0       	ldi	r25, 0x01	; 1
     b68:	9f 93       	push	r25
     b6a:	8f 93       	push	r24
     b6c:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
			printf("\n");
     b70:	8a e0       	ldi	r24, 0x0A	; 10
     b72:	90 e0       	ldi	r25, 0x00	; 0
     b74:	0e 94 43 09 	call	0x1286	; 0x1286 <putchar>
			Kick2=1;
     b78:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     b7c:	88 60       	ori	r24, 0x08	; 8
     b7e:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
     b82:	0f 90       	pop	r0
     b84:	0f 90       	pop	r0
		}
	}
	
	if (ir_sensor[3].state== IR_FALLING){
     b86:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <ir_sensor+0xc>
     b8a:	82 30       	cpi	r24, 0x02	; 2
     b8c:	61 f5       	brne	.+88     	; 0xbe6 <kickBox+0x120>
		sIR3++;
     b8e:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <sIR3>
     b92:	8f 5f       	subi	r24, 0xFF	; 255
     b94:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <sIR3>
		printf("%u ", sIR3);
     b98:	1f 92       	push	r1
     b9a:	8f 93       	push	r24
     b9c:	8c e2       	ldi	r24, 0x2C	; 44
     b9e:	91 e0       	ldi	r25, 0x01	; 1
     ba0:	9f 93       	push	r25
     ba2:	8f 93       	push	r24
     ba4:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
		waittt = 0;
     ba8:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <waittt>
		if(CajitaArr[2][sIR3] == 1){
     bac:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <sIR3>
     bb0:	f0 e0       	ldi	r31, 0x00	; 0
     bb2:	e0 55       	subi	r30, 0x50	; 80
     bb4:	fd 4f       	sbci	r31, 0xFD	; 253
     bb6:	80 a5       	ldd	r24, Z+40	; 0x28
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	0f 90       	pop	r0
     bbe:	0f 90       	pop	r0
     bc0:	81 30       	cpi	r24, 0x01	; 1
     bc2:	89 f4       	brne	.+34     	; 0xbe6 <kickBox+0x120>
			printf("ENTRE: ");
     bc4:	81 e5       	ldi	r24, 0x51	; 81
     bc6:	91 e0       	ldi	r25, 0x01	; 1
     bc8:	9f 93       	push	r25
     bca:	8f 93       	push	r24
     bcc:	0e 94 2d 09 	call	0x125a	; 0x125a <printf>
			printf("\n");
     bd0:	8a e0       	ldi	r24, 0x0A	; 10
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	0e 94 43 09 	call	0x1286	; 0x1286 <putchar>
			Kick3=1;
     bd8:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     bdc:	80 61       	ori	r24, 0x10	; 16
     bde:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
     be2:	0f 90       	pop	r0
     be4:	0f 90       	pop	r0
		}
	}
	
	if(ir_sensor[1].state== IR_RISING && Kick1){
     be6:	80 91 a4 02 	lds	r24, 0x02A4	; 0x8002a4 <ir_sensor+0x4>
     bea:	81 11       	cpse	r24, r1
     bec:	11 c0       	rjmp	.+34     	; 0xc10 <kickBox+0x14a>
     bee:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     bf2:	82 ff       	sbrs	r24, 2
     bf4:	0d c0       	rjmp	.+26     	; 0xc10 <kickBox+0x14a>
		servo_Angle(0,0);
     bf6:	60 e0       	ldi	r22, 0x00	; 0
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
		Kick1=0;	
     bfe:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
		needtoReset=1;
     c02:	8b 7f       	andi	r24, 0xFB	; 251
     c04:	80 61       	ori	r24, 0x10	; 16
     c06:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
		countservoReset=100;
     c0a:	84 e6       	ldi	r24, 0x64	; 100
     c0c:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <countservoReset>
	}
		
	if(ir_sensor[2].state== IR_RISING && Kick2){
     c10:	80 91 a8 02 	lds	r24, 0x02A8	; 0x8002a8 <ir_sensor+0x8>
     c14:	81 11       	cpse	r24, r1
     c16:	11 c0       	rjmp	.+34     	; 0xc3a <kickBox+0x174>
     c18:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     c1c:	83 ff       	sbrs	r24, 3
     c1e:	0d c0       	rjmp	.+26     	; 0xc3a <kickBox+0x174>
		servo_Angle(1,0);
     c20:	60 e0       	ldi	r22, 0x00	; 0
     c22:	81 e0       	ldi	r24, 0x01	; 1
     c24:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
		Kick2=0;
     c28:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
		needtoReset=1;
     c2c:	87 7f       	andi	r24, 0xF7	; 247
     c2e:	80 61       	ori	r24, 0x10	; 16
     c30:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
		countservoReset=100;
     c34:	84 e6       	ldi	r24, 0x64	; 100
     c36:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <countservoReset>
	}
	
	if(ir_sensor[3].state== IR_RISING && Kick3){
     c3a:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <ir_sensor+0xc>
     c3e:	81 11       	cpse	r24, r1
     c40:	11 c0       	rjmp	.+34     	; 0xc64 <kickBox+0x19e>
     c42:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     c46:	84 ff       	sbrs	r24, 4
     c48:	0d c0       	rjmp	.+26     	; 0xc64 <kickBox+0x19e>
		servo_Angle(2,0);
     c4a:	60 e0       	ldi	r22, 0x00	; 0
     c4c:	82 e0       	ldi	r24, 0x02	; 2
     c4e:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
		Kick3=0;
     c52:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
		needtoReset=1;
     c56:	8f 7e       	andi	r24, 0xEF	; 239
     c58:	80 61       	ori	r24, 0x10	; 16
     c5a:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
		countservoReset=100;
     c5e:	84 e6       	ldi	r24, 0x64	; 100
     c60:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <countservoReset>
     c64:	08 95       	ret

00000c66 <servoreset>:
	}
		
}

void servoreset(){
	servo_Angle(0,120);
     c66:	68 e7       	ldi	r22, 0x78	; 120
     c68:	80 e0       	ldi	r24, 0x00	; 0
     c6a:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
	servo_Angle(1,120);
     c6e:	68 e7       	ldi	r22, 0x78	; 120
     c70:	81 e0       	ldi	r24, 0x01	; 1
     c72:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
	servo_Angle(2,120);
     c76:	68 e7       	ldi	r22, 0x78	; 120
     c78:	82 e0       	ldi	r24, 0x02	; 2
     c7a:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
     c7e:	08 95       	ret

00000c80 <every10ms>:
		dataRx->indexR++;
		dataRx->indexR &= dataRx->mask;
	}
}

void every10ms(){
     c80:	cf 93       	push	r28
     c82:	df 93       	push	r29
	
	if (!count100ms){		//Si pasaron 100ms
     c84:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <count100ms>
     c88:	81 11       	cpse	r24, r1
     c8a:	1f c0       	rjmp	.+62     	; 0xcca <every10ms+0x4a>

uint32_t	HCSR_1;
uint16_t	aux16 = 0;

static inline void on_reset_hcsr(){
	aux16 = TCNT1;								// Loads actual time in TCNT1 into aux16
     c8c:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
     c90:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
	aux16 += 20;								// 20*500ns = 10us (tiempo del trigger), Adds 10 (us) to the previously saved time at TCNT1
     c94:	44 96       	adiw	r24, 0x14	; 20
     c96:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <aux16+0x1>
     c9a:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <aux16>
	OCR1B = aux16;								// Then loads the value into OCR1B, generating an Output Compare Interrupt
     c9e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7f808b>
     ca2:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7f808a>
	TIFR1 = (1<<OCF1B) | (1<<OCF1A);			// Flag set after the counter value in TCNT1 equals OCR1A and OCR1B
     ca6:	86 e0       	ldi	r24, 0x06	; 6
     ca8:	86 bb       	out	0x16, r24	; 22
	TIMSK1 = (1<<OCIE1B);			// Habilita interrupciones B 
     caa:	84 e0       	ldi	r24, 0x04	; 4
     cac:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	HCSR04_Start(HCSR_1);						// Trigger en HIGH
     cb0:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <HCSR_1>
     cb4:	90 91 75 01 	lds	r25, 0x0175	; 0x800175 <HCSR_1+0x1>
     cb8:	0e 94 87 00 	call	0x10e	; 0x10e <HCSR04_Start>
		on_reset_hcsr();
		count100ms = 10;
     cbc:	8a e0       	ldi	r24, 0x0A	; 10
     cbe:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <count100ms>
		PORTB ^= (1<<LED_BI);
     cc2:	95 b1       	in	r25, 0x05	; 5
     cc4:	80 e2       	ldi	r24, 0x20	; 32
     cc6:	89 27       	eor	r24, r25
     cc8:	85 b9       	out	0x05, r24	; 5
	}
	
	if (!count40ms){
     cca:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <count40ms>
     cce:	88 23       	and	r24, r24
     cd0:	81 f0       	breq	.+32     	; 0xcf2 <every10ms+0x72>
     cd2:	1f c0       	rjmp	.+62     	; 0xd12 <every10ms+0x92>
		for(int i=0;i<4;i++){
			IR_Update(&ir_sensor[i], raw_input[i]);
     cd4:	fe 01       	movw	r30, r28
     cd6:	e9 56       	subi	r30, 0x69	; 105
     cd8:	fd 4f       	sbci	r31, 0xFD	; 253
     cda:	ce 01       	movw	r24, r28
     cdc:	88 0f       	add	r24, r24
     cde:	99 1f       	adc	r25, r25
     ce0:	88 0f       	add	r24, r24
     ce2:	99 1f       	adc	r25, r25
     ce4:	60 81       	ld	r22, Z
     ce6:	80 56       	subi	r24, 0x60	; 96
     ce8:	9d 4f       	sbci	r25, 0xFD	; 253
     cea:	0e 94 2a 02 	call	0x454	; 0x454 <IR_Update>
		count100ms = 10;
		PORTB ^= (1<<LED_BI);
	}
	
	if (!count40ms){
		for(int i=0;i<4;i++){
     cee:	21 96       	adiw	r28, 0x01	; 1
     cf0:	02 c0       	rjmp	.+4      	; 0xcf6 <every10ms+0x76>
     cf2:	c0 e0       	ldi	r28, 0x00	; 0
     cf4:	d0 e0       	ldi	r29, 0x00	; 0
     cf6:	c4 30       	cpi	r28, 0x04	; 4
     cf8:	d1 05       	cpc	r29, r1
     cfa:	64 f3       	brlt	.-40     	; 0xcd4 <every10ms+0x54>
			IR_Update(&ir_sensor[i], raw_input[i]);
		}
		count40ms = 4;
     cfc:	84 e0       	ldi	r24, 0x04	; 4
     cfe:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <count40ms>
		newBox(globalDistance);
     d02:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <globalDistance>
     d06:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <globalDistance+0x1>
     d0a:	0e 94 3a 05 	call	0xa74	; 0xa74 <newBox>
		kickBox();
     d0e:	0e 94 63 05 	call	0xac6	; 0xac6 <kickBox>
	}
	if (!countservoReset && needtoReset){
     d12:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <countservoReset>
     d16:	81 11       	cpse	r24, r1
     d18:	05 c0       	rjmp	.+10     	; 0xd24 <every10ms+0xa4>
     d1a:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     d1e:	84 fd       	sbrc	r24, 4
		servoreset();
     d20:	0e 94 33 06 	call	0xc66	; 0xc66 <servoreset>
	}
	raw_input[0] = (PIND & (1<<IR0)) ? 1 : 0;
     d24:	89 b1       	in	r24, 0x09	; 9
     d26:	82 fb       	bst	r24, 2
     d28:	88 27       	eor	r24, r24
     d2a:	80 f9       	bld	r24, 0
     d2c:	e7 e9       	ldi	r30, 0x97	; 151
     d2e:	f2 e0       	ldi	r31, 0x02	; 2
     d30:	80 83       	st	Z, r24
	raw_input[1] = (PIND & (1<<IR1)) ? 1 : 0;
     d32:	89 b1       	in	r24, 0x09	; 9
     d34:	83 fb       	bst	r24, 3
     d36:	88 27       	eor	r24, r24
     d38:	80 f9       	bld	r24, 0
     d3a:	81 83       	std	Z+1, r24	; 0x01
	raw_input[2] = (PIND & (1<<IR2)) ? 1 : 0;
     d3c:	89 b1       	in	r24, 0x09	; 9
     d3e:	82 95       	swap	r24
     d40:	81 70       	andi	r24, 0x01	; 1
     d42:	82 83       	std	Z+2, r24	; 0x02
	raw_input[3] = (PIND & (1<<IR3)) ? 1 : 0;
     d44:	89 b1       	in	r24, 0x09	; 9
     d46:	85 fb       	bst	r24, 5
     d48:	88 27       	eor	r24, r24
     d4a:	80 f9       	bld	r24, 0
     d4c:	83 83       	std	Z+3, r24	; 0x03
	
	IS10MS = FALSE;
     d4e:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     d52:	8e 7f       	andi	r24, 0xFE	; 254
     d54:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <flag0>
	count100ms--;
     d58:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <count100ms>
     d5c:	81 50       	subi	r24, 0x01	; 1
     d5e:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <count100ms>
	count40ms--;
     d62:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <count40ms>
     d66:	81 50       	subi	r24, 0x01	; 1
     d68:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <count40ms>
	countservoReset--;
     d6c:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <countservoReset>
     d70:	81 50       	subi	r24, 0x01	; 1
     d72:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <countservoReset>
}
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	08 95       	ret

00000d7c <main>:
}
/* END Function prototypes user code ------------------------------------------*/

int main(){
	
	cli();
     d7c:	f8 94       	cli

	/* END Local variables -------------------------------------------------------*/


	/* User code Init ------------------------------------------------------------*/
	flag0.byte = 0;
     d7e:	10 92 96 02 	sts	0x0296, r1	; 0x800296 <flag0>
	
	ini_ports();
     d82:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <ini_ports>
	ini_timer1();
     d86:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <ini_timer1>
	ini_timer0();
     d8a:	0e 94 fd 01 	call	0x3fa	; 0x3fa <ini_timer0>
	ini_USART(16);
     d8e:	80 e1       	ldi	r24, 0x10	; 16
     d90:	0e 94 07 02 	call	0x40e	; 0x40e <ini_USART>
	
	IR_Init(&ir_sensor[0]);
     d94:	80 ea       	ldi	r24, 0xA0	; 160
     d96:	92 e0       	ldi	r25, 0x02	; 2
     d98:	0e 94 15 02 	call	0x42a	; 0x42a <IR_Init>
	stdout = &usart_output;
     d9c:	8d e0       	ldi	r24, 0x0D	; 13
     d9e:	91 e0       	ldi	r25, 0x01	; 1
     da0:	90 93 11 04 	sts	0x0411, r25	; 0x800411 <__iob+0x3>
     da4:	80 93 10 04 	sts	0x0410, r24	; 0x800410 <__iob+0x2>
	
	addServo(&PORTD,SV0);
     da8:	67 e0       	ldi	r22, 0x07	; 7
     daa:	8b e2       	ldi	r24, 0x2B	; 43
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	0e 94 58 07 	call	0xeb0	; 0xeb0 <addServo>
	addServo(&PORTB,SV1);
     db2:	64 e0       	ldi	r22, 0x04	; 4
     db4:	85 e2       	ldi	r24, 0x25	; 37
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	0e 94 58 07 	call	0xeb0	; 0xeb0 <addServo>
	addServo(&PORTB,SV2);
     dbc:	63 e0       	ldi	r22, 0x03	; 3
     dbe:	85 e2       	ldi	r24, 0x25	; 37
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	0e 94 58 07 	call	0xeb0	; 0xeb0 <addServo>
	servo_Angle(0,90);
     dc6:	6a e5       	ldi	r22, 0x5A	; 90
     dc8:	80 e0       	ldi	r24, 0x00	; 0
     dca:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
	servo_Angle(1,90);
     dce:	6a e5       	ldi	r22, 0x5A	; 90
     dd0:	81 e0       	ldi	r24, 0x01	; 1
     dd2:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
	servo_Angle(2,90);
     dd6:	6a e5       	ldi	r22, 0x5A	; 90
     dd8:	82 e0       	ldi	r24, 0x02	; 2
     dda:	0e 94 6c 07 	call	0xed8	; 0xed8 <servo_Angle>
	HCSR_1 = HCSR04_AddNew(&WritePin_HCSR, 16);
     dde:	40 e1       	ldi	r20, 0x10	; 16
     de0:	50 e0       	ldi	r21, 0x00	; 0
     de2:	60 e0       	ldi	r22, 0x00	; 0
     de4:	70 e0       	ldi	r23, 0x00	; 0
     de6:	88 ed       	ldi	r24, 0xD8	; 216
     de8:	90 e0       	ldi	r25, 0x00	; 0
     dea:	0e 94 5a 00 	call	0xb4	; 0xb4 <HCSR04_AddNew>
     dee:	a0 e0       	ldi	r26, 0x00	; 0
     df0:	b0 e0       	ldi	r27, 0x00	; 0
     df2:	80 93 74 01 	sts	0x0174, r24	; 0x800174 <HCSR_1>
     df6:	90 93 75 01 	sts	0x0175, r25	; 0x800175 <HCSR_1+0x1>
     dfa:	a0 93 76 01 	sts	0x0176, r26	; 0x800176 <HCSR_1+0x2>
     dfe:	b0 93 77 01 	sts	0x0177, r27	; 0x800177 <HCSR_1+0x3>
	
	Numbox = 255;
     e02:	8f ef       	ldi	r24, 0xFF	; 255
     e04:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <Numbox>
	
	dataRx.buff = (uint8_t *)buffRx;
     e08:	e5 e8       	ldi	r30, 0x85	; 133
     e0a:	f2 e0       	ldi	r31, 0x02	; 2
     e0c:	29 e7       	ldi	r18, 0x79	; 121
     e0e:	31 e0       	ldi	r19, 0x01	; 1
     e10:	31 83       	std	Z+1, r19	; 0x01
     e12:	20 83       	st	Z, r18
	dataRx.indexR = 0;
     e14:	12 82       	std	Z+2, r1	; 0x02
	dataRx.indexW = 0;
     e16:	13 82       	std	Z+3, r1	; 0x03
	dataRx.header = HEADER_U;
     e18:	10 86       	std	Z+8, r1	; 0x08
	dataRx.mask = RXBUFSIZE - 1;
     e1a:	85 83       	std	Z+5, r24	; 0x05
	
	dataTx.buff = buffTx;
     e1c:	e0 e9       	ldi	r30, 0x90	; 144
     e1e:	f2 e0       	ldi	r31, 0x02	; 2
     e20:	2c ee       	ldi	r18, 0xEC	; 236
     e22:	32 e0       	ldi	r19, 0x02	; 2
     e24:	31 83       	std	Z+1, r19	; 0x01
     e26:	20 83       	st	Z, r18
	dataTx.indexR = 0;
     e28:	12 82       	std	Z+2, r1	; 0x02
	dataTx.indexW = 0;
     e2a:	13 82       	std	Z+3, r1	; 0x03
	dataTx.mask = TXBUFSIZE -1;
     e2c:	84 83       	std	Z+4, r24	; 0x04
	
	boxSizeconfig.smallboxF=Cm15;
     e2e:	e9 e7       	ldi	r30, 0x79	; 121
     e30:	f2 e0       	ldi	r31, 0x02	; 2
     e32:	86 e6       	ldi	r24, 0x66	; 102
     e34:	93 e0       	ldi	r25, 0x03	; 3
     e36:	91 83       	std	Z+1, r25	; 0x01
     e38:	80 83       	st	Z, r24
	boxSizeconfig.smallboxC=Cm13;
     e3a:	82 ef       	ldi	r24, 0xF2	; 242
     e3c:	92 e0       	ldi	r25, 0x02	; 2
     e3e:	93 83       	std	Z+3, r25	; 0x03
     e40:	82 83       	std	Z+2, r24	; 0x02
	boxSizeconfig.mediumboxF=Cm13;
     e42:	95 83       	std	Z+5, r25	; 0x05
     e44:	84 83       	std	Z+4, r24	; 0x04
	boxSizeconfig.mediumboxC=Cm11;
     e46:	8e e7       	ldi	r24, 0x7E	; 126
     e48:	92 e0       	ldi	r25, 0x02	; 2
     e4a:	97 83       	std	Z+7, r25	; 0x07
     e4c:	86 83       	std	Z+6, r24	; 0x06
	boxSizeconfig.largeboxF=Cm11;
     e4e:	91 87       	std	Z+9, r25	; 0x09
     e50:	80 87       	std	Z+8, r24	; 0x08
	boxSizeconfig.largeboxC=Cm9;
     e52:	8a e0       	ldi	r24, 0x0A	; 10
     e54:	92 e0       	ldi	r25, 0x02	; 2
     e56:	93 87       	std	Z+11, r25	; 0x0b
     e58:	82 87       	std	Z+10, r24	; 0x0a
	
	ir_sensor[1].irType = SmallBox;
     e5a:	e0 ea       	ldi	r30, 0xA0	; 160
     e5c:	f2 e0       	ldi	r31, 0x02	; 2
     e5e:	81 e0       	ldi	r24, 0x01	; 1
     e60:	87 83       	std	Z+7, r24	; 0x07
	ir_sensor[2].irType = MediumBox;
     e62:	82 e0       	ldi	r24, 0x02	; 2
     e64:	83 87       	std	Z+11, r24	; 0x0b
	ir_sensor[3].irType = LargeBox;
     e66:	83 e0       	ldi	r24, 0x03	; 3
     e68:	87 87       	std	Z+15, r24	; 0x0f
	
	for (uint8_t i = 0; i < 3; i++) {
     e6a:	80 e0       	ldi	r24, 0x00	; 0
     e6c:	0f c0       	rjmp	.+30     	; 0xe8c <main+0x110>
		for (uint8_t j = 0; j < 20; j++) {
			CajitaArr[i][j] = 0;
     e6e:	24 e1       	ldi	r18, 0x14	; 20
     e70:	82 9f       	mul	r24, r18
     e72:	f0 01       	movw	r30, r0
     e74:	11 24       	eor	r1, r1
     e76:	e0 55       	subi	r30, 0x50	; 80
     e78:	fd 4f       	sbci	r31, 0xFD	; 253
     e7a:	e9 0f       	add	r30, r25
     e7c:	f1 1d       	adc	r31, r1
     e7e:	10 82       	st	Z, r1
	ir_sensor[1].irType = SmallBox;
	ir_sensor[2].irType = MediumBox;
	ir_sensor[3].irType = LargeBox;
	
	for (uint8_t i = 0; i < 3; i++) {
		for (uint8_t j = 0; j < 20; j++) {
     e80:	9f 5f       	subi	r25, 0xFF	; 255
     e82:	01 c0       	rjmp	.+2      	; 0xe86 <main+0x10a>
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	94 31       	cpi	r25, 0x14	; 20
     e88:	90 f3       	brcs	.-28     	; 0xe6e <main+0xf2>
	
	ir_sensor[1].irType = SmallBox;
	ir_sensor[2].irType = MediumBox;
	ir_sensor[3].irType = LargeBox;
	
	for (uint8_t i = 0; i < 3; i++) {
     e8a:	8f 5f       	subi	r24, 0xFF	; 255
     e8c:	83 30       	cpi	r24, 0x03	; 3
     e8e:	d0 f3       	brcs	.-12     	; 0xe84 <main+0x108>
			CajitaArr[i][j] = 0;
		}
	}
	
	/* END User code Init --------------------------------------------------------*/
	sei();
     e90:	78 94       	sei

	while (1){
		/* User Code loop ------------------------------------------------------------*/
		task_HCSR();
     e92:	0e 94 af 00 	call	0x15e	; 0x15e <task_HCSR>
		serialTask(&dataRx,&dataTx);
     e96:	60 e9       	ldi	r22, 0x90	; 144
     e98:	72 e0       	ldi	r23, 0x02	; 2
     e9a:	85 e8       	ldi	r24, 0x85	; 133
     e9c:	92 e0       	ldi	r25, 0x02	; 2
     e9e:	0e 94 13 04 	call	0x826	; 0x826 <serialTask>
		if (IS10MS)
     ea2:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <flag0>
     ea6:	80 ff       	sbrs	r24, 0
     ea8:	f4 cf       	rjmp	.-24     	; 0xe92 <main+0x116>
			every10ms();
     eaa:	0e 94 40 06 	call	0xc80	; 0xc80 <every10ms>
     eae:	f1 cf       	rjmp	.-30     	; 0xe92 <main+0x116>

00000eb0 <addServo>:
static uint8_t ServN = 0;
volatile static uint8_t is20ms=156;
 
void addServo(volatile uint8_t* PORT,uint8_t Pin){
	
	servoHandle[ServN].pin=Pin;
     eb0:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <ServN>
     eb4:	e2 2f       	mov	r30, r18
     eb6:	f0 e0       	ldi	r31, 0x00	; 0
     eb8:	af 01       	movw	r20, r30
     eba:	44 0f       	add	r20, r20
     ebc:	55 1f       	adc	r21, r21
     ebe:	44 0f       	add	r20, r20
     ec0:	55 1f       	adc	r21, r21
     ec2:	e4 0f       	add	r30, r20
     ec4:	f5 1f       	adc	r31, r21
     ec6:	eb 59       	subi	r30, 0x9B	; 155
     ec8:	fe 4f       	sbci	r31, 0xFE	; 254
     eca:	62 83       	std	Z+2, r22	; 0x02
	servoHandle[ServN].port=PORT;
     ecc:	91 83       	std	Z+1, r25	; 0x01
     ece:	80 83       	st	Z, r24
	ServN++;
     ed0:	2f 5f       	subi	r18, 0xFF	; 255
     ed2:	20 93 64 01 	sts	0x0164, r18	; 0x800164 <ServN>
     ed6:	08 95       	ret

00000ed8 <servo_Angle>:
}
void servo_Angle(uint8_t servo,uint8_t angulo){
     ed8:	48 2f       	mov	r20, r24
	
	uint16_t riseValue;
	
	riseValue = (uint16_t)angulo * ANGLE_TO_PWM_SLOPE;
     eda:	85 e7       	ldi	r24, 0x75	; 117
     edc:	68 9f       	mul	r22, r24
     ede:	90 01       	movw	r18, r0
     ee0:	11 24       	eor	r1, r1
	riseValue += ANGLE_TO_PWM_OFFSET;
     ee2:	2e 5c       	subi	r18, 0xCE	; 206
     ee4:	36 4d       	sbci	r19, 0xD6	; 214
	riseValue /= 180;
     ee6:	a3 e8       	ldi	r26, 0x83	; 131
     ee8:	bd e2       	ldi	r27, 0x2D	; 45
     eea:	0e 94 fd 07 	call	0xffa	; 0xffa <__umulhisi3>
     eee:	96 95       	lsr	r25
     ef0:	87 95       	ror	r24
     ef2:	92 95       	swap	r25
     ef4:	82 95       	swap	r24
     ef6:	8f 70       	andi	r24, 0x0F	; 15
     ef8:	89 27       	eor	r24, r25
     efa:	9f 70       	andi	r25, 0x0F	; 15
     efc:	89 27       	eor	r24, r25
	riseValue += ROUNDING_CORRECTION;
     efe:	9c 01       	movw	r18, r24
     f00:	2b 5f       	subi	r18, 0xFB	; 251
     f02:	3f 4f       	sbci	r19, 0xFF	; 255
	riseValue /= 10;
     f04:	ad ec       	ldi	r26, 0xCD	; 205
     f06:	bc ec       	ldi	r27, 0xCC	; 204
     f08:	0e 94 fd 07 	call	0xffa	; 0xffa <__umulhisi3>
     f0c:	96 95       	lsr	r25
     f0e:	87 95       	ror	r24
     f10:	96 95       	lsr	r25
     f12:	87 95       	ror	r24
     f14:	96 95       	lsr	r25
     f16:	87 95       	ror	r24
		
	servoHandle[servo].dutyCycle = (uint8_t)riseValue;
     f18:	24 2f       	mov	r18, r20
     f1a:	30 e0       	ldi	r19, 0x00	; 0
     f1c:	f9 01       	movw	r30, r18
     f1e:	ee 0f       	add	r30, r30
     f20:	ff 1f       	adc	r31, r31
     f22:	ee 0f       	add	r30, r30
     f24:	ff 1f       	adc	r31, r31
     f26:	2e 0f       	add	r18, r30
     f28:	3f 1f       	adc	r19, r31
     f2a:	f9 01       	movw	r30, r18
     f2c:	eb 59       	subi	r30, 0x9B	; 155
     f2e:	fe 4f       	sbci	r31, 0xFE	; 254
     f30:	84 83       	std	Z+4, r24	; 0x04
     f32:	08 95       	ret

00000f34 <writeServo>:
}

void writeServo(){
	is20ms--;
     f34:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <is20ms>
     f38:	81 50       	subi	r24, 0x01	; 1
     f3a:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <is20ms>
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     f3e:	20 e0       	ldi	r18, 0x00	; 0
     f40:	2a c0       	rjmp	.+84     	; 0xf96 <writeServo+0x62>
		servoHandle[counter].cycle--;
     f42:	82 2f       	mov	r24, r18
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	fc 01       	movw	r30, r24
     f48:	ee 0f       	add	r30, r30
     f4a:	ff 1f       	adc	r31, r31
     f4c:	ee 0f       	add	r30, r30
     f4e:	ff 1f       	adc	r31, r31
     f50:	e8 0f       	add	r30, r24
     f52:	f9 1f       	adc	r31, r25
     f54:	eb 59       	subi	r30, 0x9B	; 155
     f56:	fe 4f       	sbci	r31, 0xFE	; 254
     f58:	33 81       	ldd	r19, Z+3	; 0x03
     f5a:	31 50       	subi	r19, 0x01	; 1
     f5c:	33 83       	std	Z+3, r19	; 0x03
		if(!servoHandle[counter].cycle)
     f5e:	33 81       	ldd	r19, Z+3	; 0x03
     f60:	31 11       	cpse	r19, r1
     f62:	18 c0       	rjmp	.+48     	; 0xf94 <writeServo+0x60>
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
     f64:	fc 01       	movw	r30, r24
     f66:	ee 0f       	add	r30, r30
     f68:	ff 1f       	adc	r31, r31
     f6a:	ee 0f       	add	r30, r30
     f6c:	ff 1f       	adc	r31, r31
     f6e:	8e 0f       	add	r24, r30
     f70:	9f 1f       	adc	r25, r31
     f72:	fc 01       	movw	r30, r24
     f74:	eb 59       	subi	r30, 0x9B	; 155
     f76:	fe 4f       	sbci	r31, 0xFE	; 254
     f78:	a0 81       	ld	r26, Z
     f7a:	b1 81       	ldd	r27, Z+1	; 0x01
     f7c:	3c 91       	ld	r19, X
     f7e:	81 e0       	ldi	r24, 0x01	; 1
     f80:	90 e0       	ldi	r25, 0x00	; 0
     f82:	02 80       	ldd	r0, Z+2	; 0x02
     f84:	02 c0       	rjmp	.+4      	; 0xf8a <writeServo+0x56>
     f86:	88 0f       	add	r24, r24
     f88:	99 1f       	adc	r25, r25
     f8a:	0a 94       	dec	r0
     f8c:	e2 f7       	brpl	.-8      	; 0xf86 <writeServo+0x52>
     f8e:	80 95       	com	r24
     f90:	83 23       	and	r24, r19
     f92:	8c 93       	st	X, r24
void writeServo(){
	is20ms--;
	
	uint8_t counter=0;
	
	for(counter = 0; counter < ServN; counter++){
     f94:	2f 5f       	subi	r18, 0xFF	; 255
     f96:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <ServN>
     f9a:	28 17       	cp	r18, r24
     f9c:	90 f2       	brcs	.-92     	; 0xf42 <writeServo+0xe>
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
     f9e:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <is20ms>
     fa2:	99 23       	and	r25, r25
     fa4:	e9 f0       	breq	.+58     	; 0xfe0 <writeServo+0xac>
     fa6:	08 95       	ret
		for(counter = 0; counter < ServN; counter++){
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
     fa8:	e9 2f       	mov	r30, r25
     faa:	f0 e0       	ldi	r31, 0x00	; 0
     fac:	9f 01       	movw	r18, r30
     fae:	22 0f       	add	r18, r18
     fb0:	33 1f       	adc	r19, r19
     fb2:	22 0f       	add	r18, r18
     fb4:	33 1f       	adc	r19, r19
     fb6:	e2 0f       	add	r30, r18
     fb8:	f3 1f       	adc	r31, r19
     fba:	eb 59       	subi	r30, 0x9B	; 155
     fbc:	fe 4f       	sbci	r31, 0xFE	; 254
     fbe:	24 81       	ldd	r18, Z+4	; 0x04
     fc0:	23 83       	std	Z+3, r18	; 0x03
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
     fc2:	a0 81       	ld	r26, Z
     fc4:	b1 81       	ldd	r27, Z+1	; 0x01
     fc6:	4c 91       	ld	r20, X
     fc8:	21 e0       	ldi	r18, 0x01	; 1
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	02 80       	ldd	r0, Z+2	; 0x02
     fce:	02 c0       	rjmp	.+4      	; 0xfd4 <writeServo+0xa0>
     fd0:	22 0f       	add	r18, r18
     fd2:	33 1f       	adc	r19, r19
     fd4:	0a 94       	dec	r0
     fd6:	e2 f7       	brpl	.-8      	; 0xfd0 <writeServo+0x9c>
     fd8:	24 2b       	or	r18, r20
     fda:	2c 93       	st	X, r18
		servoHandle[counter].cycle--;
		if(!servoHandle[counter].cycle)
		*servoHandle[counter].port &= ~(1 << servoHandle[counter].pin);
	}
	if(!is20ms){
		for(counter = 0; counter < ServN; counter++){
     fdc:	9f 5f       	subi	r25, 0xFF	; 255
     fde:	01 c0       	rjmp	.+2      	; 0xfe2 <writeServo+0xae>
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	98 17       	cp	r25, r24
     fe4:	08 f3       	brcs	.-62     	; 0xfa8 <writeServo+0x74>
			servoHandle[counter].cycle = servoHandle[counter].dutyCycle;
			*servoHandle[counter].port |= (1 << servoHandle[counter].pin);
		}
		is20ms = 156;
     fe6:	8c e9       	ldi	r24, 0x9C	; 156
     fe8:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <is20ms>
     fec:	08 95       	ret

00000fee <__tablejump2__>:
     fee:	ee 0f       	add	r30, r30
     ff0:	ff 1f       	adc	r31, r31
     ff2:	05 90       	lpm	r0, Z+
     ff4:	f4 91       	lpm	r31, Z
     ff6:	e0 2d       	mov	r30, r0
     ff8:	09 94       	ijmp

00000ffa <__umulhisi3>:
     ffa:	a2 9f       	mul	r26, r18
     ffc:	b0 01       	movw	r22, r0
     ffe:	b3 9f       	mul	r27, r19
    1000:	c0 01       	movw	r24, r0
    1002:	a3 9f       	mul	r26, r19
    1004:	70 0d       	add	r23, r0
    1006:	81 1d       	adc	r24, r1
    1008:	11 24       	eor	r1, r1
    100a:	91 1d       	adc	r25, r1
    100c:	b2 9f       	mul	r27, r18
    100e:	70 0d       	add	r23, r0
    1010:	81 1d       	adc	r24, r1
    1012:	11 24       	eor	r1, r1
    1014:	91 1d       	adc	r25, r1
    1016:	08 95       	ret

00001018 <malloc>:
    1018:	0f 93       	push	r16
    101a:	1f 93       	push	r17
    101c:	cf 93       	push	r28
    101e:	df 93       	push	r29
    1020:	82 30       	cpi	r24, 0x02	; 2
    1022:	91 05       	cpc	r25, r1
    1024:	10 f4       	brcc	.+4      	; 0x102a <malloc+0x12>
    1026:	82 e0       	ldi	r24, 0x02	; 2
    1028:	90 e0       	ldi	r25, 0x00	; 0
    102a:	e0 91 0c 04 	lds	r30, 0x040C	; 0x80040c <__flp>
    102e:	f0 91 0d 04 	lds	r31, 0x040D	; 0x80040d <__flp+0x1>
    1032:	20 e0       	ldi	r18, 0x00	; 0
    1034:	30 e0       	ldi	r19, 0x00	; 0
    1036:	a0 e0       	ldi	r26, 0x00	; 0
    1038:	b0 e0       	ldi	r27, 0x00	; 0
    103a:	30 97       	sbiw	r30, 0x00	; 0
    103c:	19 f1       	breq	.+70     	; 0x1084 <malloc+0x6c>
    103e:	40 81       	ld	r20, Z
    1040:	51 81       	ldd	r21, Z+1	; 0x01
    1042:	02 81       	ldd	r16, Z+2	; 0x02
    1044:	13 81       	ldd	r17, Z+3	; 0x03
    1046:	48 17       	cp	r20, r24
    1048:	59 07       	cpc	r21, r25
    104a:	c8 f0       	brcs	.+50     	; 0x107e <malloc+0x66>
    104c:	84 17       	cp	r24, r20
    104e:	95 07       	cpc	r25, r21
    1050:	69 f4       	brne	.+26     	; 0x106c <malloc+0x54>
    1052:	10 97       	sbiw	r26, 0x00	; 0
    1054:	31 f0       	breq	.+12     	; 0x1062 <malloc+0x4a>
    1056:	12 96       	adiw	r26, 0x02	; 2
    1058:	0c 93       	st	X, r16
    105a:	12 97       	sbiw	r26, 0x02	; 2
    105c:	13 96       	adiw	r26, 0x03	; 3
    105e:	1c 93       	st	X, r17
    1060:	27 c0       	rjmp	.+78     	; 0x10b0 <malloc+0x98>
    1062:	00 93 0c 04 	sts	0x040C, r16	; 0x80040c <__flp>
    1066:	10 93 0d 04 	sts	0x040D, r17	; 0x80040d <__flp+0x1>
    106a:	22 c0       	rjmp	.+68     	; 0x10b0 <malloc+0x98>
    106c:	21 15       	cp	r18, r1
    106e:	31 05       	cpc	r19, r1
    1070:	19 f0       	breq	.+6      	; 0x1078 <malloc+0x60>
    1072:	42 17       	cp	r20, r18
    1074:	53 07       	cpc	r21, r19
    1076:	18 f4       	brcc	.+6      	; 0x107e <malloc+0x66>
    1078:	9a 01       	movw	r18, r20
    107a:	bd 01       	movw	r22, r26
    107c:	ef 01       	movw	r28, r30
    107e:	df 01       	movw	r26, r30
    1080:	f8 01       	movw	r30, r16
    1082:	db cf       	rjmp	.-74     	; 0x103a <malloc+0x22>
    1084:	21 15       	cp	r18, r1
    1086:	31 05       	cpc	r19, r1
    1088:	f9 f0       	breq	.+62     	; 0x10c8 <malloc+0xb0>
    108a:	28 1b       	sub	r18, r24
    108c:	39 0b       	sbc	r19, r25
    108e:	24 30       	cpi	r18, 0x04	; 4
    1090:	31 05       	cpc	r19, r1
    1092:	80 f4       	brcc	.+32     	; 0x10b4 <malloc+0x9c>
    1094:	8a 81       	ldd	r24, Y+2	; 0x02
    1096:	9b 81       	ldd	r25, Y+3	; 0x03
    1098:	61 15       	cp	r22, r1
    109a:	71 05       	cpc	r23, r1
    109c:	21 f0       	breq	.+8      	; 0x10a6 <malloc+0x8e>
    109e:	fb 01       	movw	r30, r22
    10a0:	93 83       	std	Z+3, r25	; 0x03
    10a2:	82 83       	std	Z+2, r24	; 0x02
    10a4:	04 c0       	rjmp	.+8      	; 0x10ae <malloc+0x96>
    10a6:	90 93 0d 04 	sts	0x040D, r25	; 0x80040d <__flp+0x1>
    10aa:	80 93 0c 04 	sts	0x040C, r24	; 0x80040c <__flp>
    10ae:	fe 01       	movw	r30, r28
    10b0:	32 96       	adiw	r30, 0x02	; 2
    10b2:	44 c0       	rjmp	.+136    	; 0x113c <malloc+0x124>
    10b4:	fe 01       	movw	r30, r28
    10b6:	e2 0f       	add	r30, r18
    10b8:	f3 1f       	adc	r31, r19
    10ba:	81 93       	st	Z+, r24
    10bc:	91 93       	st	Z+, r25
    10be:	22 50       	subi	r18, 0x02	; 2
    10c0:	31 09       	sbc	r19, r1
    10c2:	39 83       	std	Y+1, r19	; 0x01
    10c4:	28 83       	st	Y, r18
    10c6:	3a c0       	rjmp	.+116    	; 0x113c <malloc+0x124>
    10c8:	20 91 0a 04 	lds	r18, 0x040A	; 0x80040a <__brkval>
    10cc:	30 91 0b 04 	lds	r19, 0x040B	; 0x80040b <__brkval+0x1>
    10d0:	23 2b       	or	r18, r19
    10d2:	41 f4       	brne	.+16     	; 0x10e4 <malloc+0xcc>
    10d4:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    10d8:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    10dc:	30 93 0b 04 	sts	0x040B, r19	; 0x80040b <__brkval+0x1>
    10e0:	20 93 0a 04 	sts	0x040A, r18	; 0x80040a <__brkval>
    10e4:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    10e8:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    10ec:	21 15       	cp	r18, r1
    10ee:	31 05       	cpc	r19, r1
    10f0:	41 f4       	brne	.+16     	; 0x1102 <malloc+0xea>
    10f2:	2d b7       	in	r18, 0x3d	; 61
    10f4:	3e b7       	in	r19, 0x3e	; 62
    10f6:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    10fa:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    10fe:	24 1b       	sub	r18, r20
    1100:	35 0b       	sbc	r19, r21
    1102:	e0 91 0a 04 	lds	r30, 0x040A	; 0x80040a <__brkval>
    1106:	f0 91 0b 04 	lds	r31, 0x040B	; 0x80040b <__brkval+0x1>
    110a:	e2 17       	cp	r30, r18
    110c:	f3 07       	cpc	r31, r19
    110e:	a0 f4       	brcc	.+40     	; 0x1138 <malloc+0x120>
    1110:	2e 1b       	sub	r18, r30
    1112:	3f 0b       	sbc	r19, r31
    1114:	28 17       	cp	r18, r24
    1116:	39 07       	cpc	r19, r25
    1118:	78 f0       	brcs	.+30     	; 0x1138 <malloc+0x120>
    111a:	ac 01       	movw	r20, r24
    111c:	4e 5f       	subi	r20, 0xFE	; 254
    111e:	5f 4f       	sbci	r21, 0xFF	; 255
    1120:	24 17       	cp	r18, r20
    1122:	35 07       	cpc	r19, r21
    1124:	48 f0       	brcs	.+18     	; 0x1138 <malloc+0x120>
    1126:	4e 0f       	add	r20, r30
    1128:	5f 1f       	adc	r21, r31
    112a:	50 93 0b 04 	sts	0x040B, r21	; 0x80040b <__brkval+0x1>
    112e:	40 93 0a 04 	sts	0x040A, r20	; 0x80040a <__brkval>
    1132:	81 93       	st	Z+, r24
    1134:	91 93       	st	Z+, r25
    1136:	02 c0       	rjmp	.+4      	; 0x113c <malloc+0x124>
    1138:	e0 e0       	ldi	r30, 0x00	; 0
    113a:	f0 e0       	ldi	r31, 0x00	; 0
    113c:	cf 01       	movw	r24, r30
    113e:	df 91       	pop	r29
    1140:	cf 91       	pop	r28
    1142:	1f 91       	pop	r17
    1144:	0f 91       	pop	r16
    1146:	08 95       	ret

00001148 <free>:
    1148:	cf 93       	push	r28
    114a:	df 93       	push	r29
    114c:	00 97       	sbiw	r24, 0x00	; 0
    114e:	09 f4       	brne	.+2      	; 0x1152 <free+0xa>
    1150:	81 c0       	rjmp	.+258    	; 0x1254 <free+0x10c>
    1152:	fc 01       	movw	r30, r24
    1154:	32 97       	sbiw	r30, 0x02	; 2
    1156:	13 82       	std	Z+3, r1	; 0x03
    1158:	12 82       	std	Z+2, r1	; 0x02
    115a:	a0 91 0c 04 	lds	r26, 0x040C	; 0x80040c <__flp>
    115e:	b0 91 0d 04 	lds	r27, 0x040D	; 0x80040d <__flp+0x1>
    1162:	10 97       	sbiw	r26, 0x00	; 0
    1164:	81 f4       	brne	.+32     	; 0x1186 <free+0x3e>
    1166:	20 81       	ld	r18, Z
    1168:	31 81       	ldd	r19, Z+1	; 0x01
    116a:	82 0f       	add	r24, r18
    116c:	93 1f       	adc	r25, r19
    116e:	20 91 0a 04 	lds	r18, 0x040A	; 0x80040a <__brkval>
    1172:	30 91 0b 04 	lds	r19, 0x040B	; 0x80040b <__brkval+0x1>
    1176:	28 17       	cp	r18, r24
    1178:	39 07       	cpc	r19, r25
    117a:	51 f5       	brne	.+84     	; 0x11d0 <free+0x88>
    117c:	f0 93 0b 04 	sts	0x040B, r31	; 0x80040b <__brkval+0x1>
    1180:	e0 93 0a 04 	sts	0x040A, r30	; 0x80040a <__brkval>
    1184:	67 c0       	rjmp	.+206    	; 0x1254 <free+0x10c>
    1186:	ed 01       	movw	r28, r26
    1188:	20 e0       	ldi	r18, 0x00	; 0
    118a:	30 e0       	ldi	r19, 0x00	; 0
    118c:	ce 17       	cp	r28, r30
    118e:	df 07       	cpc	r29, r31
    1190:	40 f4       	brcc	.+16     	; 0x11a2 <free+0x5a>
    1192:	4a 81       	ldd	r20, Y+2	; 0x02
    1194:	5b 81       	ldd	r21, Y+3	; 0x03
    1196:	9e 01       	movw	r18, r28
    1198:	41 15       	cp	r20, r1
    119a:	51 05       	cpc	r21, r1
    119c:	f1 f0       	breq	.+60     	; 0x11da <free+0x92>
    119e:	ea 01       	movw	r28, r20
    11a0:	f5 cf       	rjmp	.-22     	; 0x118c <free+0x44>
    11a2:	d3 83       	std	Z+3, r29	; 0x03
    11a4:	c2 83       	std	Z+2, r28	; 0x02
    11a6:	40 81       	ld	r20, Z
    11a8:	51 81       	ldd	r21, Z+1	; 0x01
    11aa:	84 0f       	add	r24, r20
    11ac:	95 1f       	adc	r25, r21
    11ae:	c8 17       	cp	r28, r24
    11b0:	d9 07       	cpc	r29, r25
    11b2:	59 f4       	brne	.+22     	; 0x11ca <free+0x82>
    11b4:	88 81       	ld	r24, Y
    11b6:	99 81       	ldd	r25, Y+1	; 0x01
    11b8:	84 0f       	add	r24, r20
    11ba:	95 1f       	adc	r25, r21
    11bc:	02 96       	adiw	r24, 0x02	; 2
    11be:	91 83       	std	Z+1, r25	; 0x01
    11c0:	80 83       	st	Z, r24
    11c2:	8a 81       	ldd	r24, Y+2	; 0x02
    11c4:	9b 81       	ldd	r25, Y+3	; 0x03
    11c6:	93 83       	std	Z+3, r25	; 0x03
    11c8:	82 83       	std	Z+2, r24	; 0x02
    11ca:	21 15       	cp	r18, r1
    11cc:	31 05       	cpc	r19, r1
    11ce:	29 f4       	brne	.+10     	; 0x11da <free+0x92>
    11d0:	f0 93 0d 04 	sts	0x040D, r31	; 0x80040d <__flp+0x1>
    11d4:	e0 93 0c 04 	sts	0x040C, r30	; 0x80040c <__flp>
    11d8:	3d c0       	rjmp	.+122    	; 0x1254 <free+0x10c>
    11da:	e9 01       	movw	r28, r18
    11dc:	fb 83       	std	Y+3, r31	; 0x03
    11de:	ea 83       	std	Y+2, r30	; 0x02
    11e0:	49 91       	ld	r20, Y+
    11e2:	59 91       	ld	r21, Y+
    11e4:	c4 0f       	add	r28, r20
    11e6:	d5 1f       	adc	r29, r21
    11e8:	ec 17       	cp	r30, r28
    11ea:	fd 07       	cpc	r31, r29
    11ec:	61 f4       	brne	.+24     	; 0x1206 <free+0xbe>
    11ee:	80 81       	ld	r24, Z
    11f0:	91 81       	ldd	r25, Z+1	; 0x01
    11f2:	84 0f       	add	r24, r20
    11f4:	95 1f       	adc	r25, r21
    11f6:	02 96       	adiw	r24, 0x02	; 2
    11f8:	e9 01       	movw	r28, r18
    11fa:	99 83       	std	Y+1, r25	; 0x01
    11fc:	88 83       	st	Y, r24
    11fe:	82 81       	ldd	r24, Z+2	; 0x02
    1200:	93 81       	ldd	r25, Z+3	; 0x03
    1202:	9b 83       	std	Y+3, r25	; 0x03
    1204:	8a 83       	std	Y+2, r24	; 0x02
    1206:	e0 e0       	ldi	r30, 0x00	; 0
    1208:	f0 e0       	ldi	r31, 0x00	; 0
    120a:	12 96       	adiw	r26, 0x02	; 2
    120c:	8d 91       	ld	r24, X+
    120e:	9c 91       	ld	r25, X
    1210:	13 97       	sbiw	r26, 0x03	; 3
    1212:	00 97       	sbiw	r24, 0x00	; 0
    1214:	19 f0       	breq	.+6      	; 0x121c <free+0xd4>
    1216:	fd 01       	movw	r30, r26
    1218:	dc 01       	movw	r26, r24
    121a:	f7 cf       	rjmp	.-18     	; 0x120a <free+0xc2>
    121c:	8d 91       	ld	r24, X+
    121e:	9c 91       	ld	r25, X
    1220:	11 97       	sbiw	r26, 0x01	; 1
    1222:	9d 01       	movw	r18, r26
    1224:	2e 5f       	subi	r18, 0xFE	; 254
    1226:	3f 4f       	sbci	r19, 0xFF	; 255
    1228:	82 0f       	add	r24, r18
    122a:	93 1f       	adc	r25, r19
    122c:	20 91 0a 04 	lds	r18, 0x040A	; 0x80040a <__brkval>
    1230:	30 91 0b 04 	lds	r19, 0x040B	; 0x80040b <__brkval+0x1>
    1234:	28 17       	cp	r18, r24
    1236:	39 07       	cpc	r19, r25
    1238:	69 f4       	brne	.+26     	; 0x1254 <free+0x10c>
    123a:	30 97       	sbiw	r30, 0x00	; 0
    123c:	29 f4       	brne	.+10     	; 0x1248 <free+0x100>
    123e:	10 92 0d 04 	sts	0x040D, r1	; 0x80040d <__flp+0x1>
    1242:	10 92 0c 04 	sts	0x040C, r1	; 0x80040c <__flp>
    1246:	02 c0       	rjmp	.+4      	; 0x124c <free+0x104>
    1248:	13 82       	std	Z+3, r1	; 0x03
    124a:	12 82       	std	Z+2, r1	; 0x02
    124c:	b0 93 0b 04 	sts	0x040B, r27	; 0x80040b <__brkval+0x1>
    1250:	a0 93 0a 04 	sts	0x040A, r26	; 0x80040a <__brkval>
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	08 95       	ret

0000125a <printf>:
    125a:	a0 e0       	ldi	r26, 0x00	; 0
    125c:	b0 e0       	ldi	r27, 0x00	; 0
    125e:	e3 e3       	ldi	r30, 0x33	; 51
    1260:	f9 e0       	ldi	r31, 0x09	; 9
    1262:	0c 94 eb 0b 	jmp	0x17d6	; 0x17d6 <__prologue_saves__+0x20>
    1266:	ae 01       	movw	r20, r28
    1268:	4b 5f       	subi	r20, 0xFB	; 251
    126a:	5f 4f       	sbci	r21, 0xFF	; 255
    126c:	fa 01       	movw	r30, r20
    126e:	61 91       	ld	r22, Z+
    1270:	71 91       	ld	r23, Z+
    1272:	af 01       	movw	r20, r30
    1274:	80 91 10 04 	lds	r24, 0x0410	; 0x800410 <__iob+0x2>
    1278:	90 91 11 04 	lds	r25, 0x0411	; 0x800411 <__iob+0x3>
    127c:	0e 94 4a 09 	call	0x1294	; 0x1294 <vfprintf>
    1280:	e2 e0       	ldi	r30, 0x02	; 2
    1282:	0c 94 07 0c 	jmp	0x180e	; 0x180e <__epilogue_restores__+0x20>

00001286 <putchar>:
    1286:	60 91 10 04 	lds	r22, 0x0410	; 0x800410 <__iob+0x2>
    128a:	70 91 11 04 	lds	r23, 0x0411	; 0x800411 <__iob+0x3>
    128e:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    1292:	08 95       	ret

00001294 <vfprintf>:
    1294:	ab e0       	ldi	r26, 0x0B	; 11
    1296:	b0 e0       	ldi	r27, 0x00	; 0
    1298:	e0 e5       	ldi	r30, 0x50	; 80
    129a:	f9 e0       	ldi	r31, 0x09	; 9
    129c:	0c 94 db 0b 	jmp	0x17b6	; 0x17b6 <__prologue_saves__>
    12a0:	6c 01       	movw	r12, r24
    12a2:	7b 01       	movw	r14, r22
    12a4:	8a 01       	movw	r16, r20
    12a6:	fc 01       	movw	r30, r24
    12a8:	17 82       	std	Z+7, r1	; 0x07
    12aa:	16 82       	std	Z+6, r1	; 0x06
    12ac:	83 81       	ldd	r24, Z+3	; 0x03
    12ae:	81 ff       	sbrs	r24, 1
    12b0:	cc c1       	rjmp	.+920    	; 0x164a <vfprintf+0x3b6>
    12b2:	ce 01       	movw	r24, r28
    12b4:	01 96       	adiw	r24, 0x01	; 1
    12b6:	3c 01       	movw	r6, r24
    12b8:	f6 01       	movw	r30, r12
    12ba:	93 81       	ldd	r25, Z+3	; 0x03
    12bc:	f7 01       	movw	r30, r14
    12be:	93 fd       	sbrc	r25, 3
    12c0:	85 91       	lpm	r24, Z+
    12c2:	93 ff       	sbrs	r25, 3
    12c4:	81 91       	ld	r24, Z+
    12c6:	7f 01       	movw	r14, r30
    12c8:	88 23       	and	r24, r24
    12ca:	09 f4       	brne	.+2      	; 0x12ce <vfprintf+0x3a>
    12cc:	ba c1       	rjmp	.+884    	; 0x1642 <vfprintf+0x3ae>
    12ce:	85 32       	cpi	r24, 0x25	; 37
    12d0:	39 f4       	brne	.+14     	; 0x12e0 <vfprintf+0x4c>
    12d2:	93 fd       	sbrc	r25, 3
    12d4:	85 91       	lpm	r24, Z+
    12d6:	93 ff       	sbrs	r25, 3
    12d8:	81 91       	ld	r24, Z+
    12da:	7f 01       	movw	r14, r30
    12dc:	85 32       	cpi	r24, 0x25	; 37
    12de:	29 f4       	brne	.+10     	; 0x12ea <vfprintf+0x56>
    12e0:	b6 01       	movw	r22, r12
    12e2:	90 e0       	ldi	r25, 0x00	; 0
    12e4:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    12e8:	e7 cf       	rjmp	.-50     	; 0x12b8 <vfprintf+0x24>
    12ea:	91 2c       	mov	r9, r1
    12ec:	21 2c       	mov	r2, r1
    12ee:	31 2c       	mov	r3, r1
    12f0:	ff e1       	ldi	r31, 0x1F	; 31
    12f2:	f3 15       	cp	r31, r3
    12f4:	d8 f0       	brcs	.+54     	; 0x132c <vfprintf+0x98>
    12f6:	8b 32       	cpi	r24, 0x2B	; 43
    12f8:	79 f0       	breq	.+30     	; 0x1318 <vfprintf+0x84>
    12fa:	38 f4       	brcc	.+14     	; 0x130a <vfprintf+0x76>
    12fc:	80 32       	cpi	r24, 0x20	; 32
    12fe:	79 f0       	breq	.+30     	; 0x131e <vfprintf+0x8a>
    1300:	83 32       	cpi	r24, 0x23	; 35
    1302:	a1 f4       	brne	.+40     	; 0x132c <vfprintf+0x98>
    1304:	23 2d       	mov	r18, r3
    1306:	20 61       	ori	r18, 0x10	; 16
    1308:	1d c0       	rjmp	.+58     	; 0x1344 <vfprintf+0xb0>
    130a:	8d 32       	cpi	r24, 0x2D	; 45
    130c:	61 f0       	breq	.+24     	; 0x1326 <vfprintf+0x92>
    130e:	80 33       	cpi	r24, 0x30	; 48
    1310:	69 f4       	brne	.+26     	; 0x132c <vfprintf+0x98>
    1312:	23 2d       	mov	r18, r3
    1314:	21 60       	ori	r18, 0x01	; 1
    1316:	16 c0       	rjmp	.+44     	; 0x1344 <vfprintf+0xb0>
    1318:	83 2d       	mov	r24, r3
    131a:	82 60       	ori	r24, 0x02	; 2
    131c:	38 2e       	mov	r3, r24
    131e:	e3 2d       	mov	r30, r3
    1320:	e4 60       	ori	r30, 0x04	; 4
    1322:	3e 2e       	mov	r3, r30
    1324:	2a c0       	rjmp	.+84     	; 0x137a <vfprintf+0xe6>
    1326:	f3 2d       	mov	r31, r3
    1328:	f8 60       	ori	r31, 0x08	; 8
    132a:	1d c0       	rjmp	.+58     	; 0x1366 <vfprintf+0xd2>
    132c:	37 fc       	sbrc	r3, 7
    132e:	2d c0       	rjmp	.+90     	; 0x138a <vfprintf+0xf6>
    1330:	20 ed       	ldi	r18, 0xD0	; 208
    1332:	28 0f       	add	r18, r24
    1334:	2a 30       	cpi	r18, 0x0A	; 10
    1336:	40 f0       	brcs	.+16     	; 0x1348 <vfprintf+0xb4>
    1338:	8e 32       	cpi	r24, 0x2E	; 46
    133a:	b9 f4       	brne	.+46     	; 0x136a <vfprintf+0xd6>
    133c:	36 fc       	sbrc	r3, 6
    133e:	81 c1       	rjmp	.+770    	; 0x1642 <vfprintf+0x3ae>
    1340:	23 2d       	mov	r18, r3
    1342:	20 64       	ori	r18, 0x40	; 64
    1344:	32 2e       	mov	r3, r18
    1346:	19 c0       	rjmp	.+50     	; 0x137a <vfprintf+0xe6>
    1348:	36 fe       	sbrs	r3, 6
    134a:	06 c0       	rjmp	.+12     	; 0x1358 <vfprintf+0xc4>
    134c:	8a e0       	ldi	r24, 0x0A	; 10
    134e:	98 9e       	mul	r9, r24
    1350:	20 0d       	add	r18, r0
    1352:	11 24       	eor	r1, r1
    1354:	92 2e       	mov	r9, r18
    1356:	11 c0       	rjmp	.+34     	; 0x137a <vfprintf+0xe6>
    1358:	ea e0       	ldi	r30, 0x0A	; 10
    135a:	2e 9e       	mul	r2, r30
    135c:	20 0d       	add	r18, r0
    135e:	11 24       	eor	r1, r1
    1360:	22 2e       	mov	r2, r18
    1362:	f3 2d       	mov	r31, r3
    1364:	f0 62       	ori	r31, 0x20	; 32
    1366:	3f 2e       	mov	r3, r31
    1368:	08 c0       	rjmp	.+16     	; 0x137a <vfprintf+0xe6>
    136a:	8c 36       	cpi	r24, 0x6C	; 108
    136c:	21 f4       	brne	.+8      	; 0x1376 <vfprintf+0xe2>
    136e:	83 2d       	mov	r24, r3
    1370:	80 68       	ori	r24, 0x80	; 128
    1372:	38 2e       	mov	r3, r24
    1374:	02 c0       	rjmp	.+4      	; 0x137a <vfprintf+0xe6>
    1376:	88 36       	cpi	r24, 0x68	; 104
    1378:	41 f4       	brne	.+16     	; 0x138a <vfprintf+0xf6>
    137a:	f7 01       	movw	r30, r14
    137c:	93 fd       	sbrc	r25, 3
    137e:	85 91       	lpm	r24, Z+
    1380:	93 ff       	sbrs	r25, 3
    1382:	81 91       	ld	r24, Z+
    1384:	7f 01       	movw	r14, r30
    1386:	81 11       	cpse	r24, r1
    1388:	b3 cf       	rjmp	.-154    	; 0x12f0 <vfprintf+0x5c>
    138a:	98 2f       	mov	r25, r24
    138c:	9f 7d       	andi	r25, 0xDF	; 223
    138e:	95 54       	subi	r25, 0x45	; 69
    1390:	93 30       	cpi	r25, 0x03	; 3
    1392:	28 f4       	brcc	.+10     	; 0x139e <vfprintf+0x10a>
    1394:	0c 5f       	subi	r16, 0xFC	; 252
    1396:	1f 4f       	sbci	r17, 0xFF	; 255
    1398:	9f e3       	ldi	r25, 0x3F	; 63
    139a:	99 83       	std	Y+1, r25	; 0x01
    139c:	0d c0       	rjmp	.+26     	; 0x13b8 <vfprintf+0x124>
    139e:	83 36       	cpi	r24, 0x63	; 99
    13a0:	31 f0       	breq	.+12     	; 0x13ae <vfprintf+0x11a>
    13a2:	83 37       	cpi	r24, 0x73	; 115
    13a4:	71 f0       	breq	.+28     	; 0x13c2 <vfprintf+0x12e>
    13a6:	83 35       	cpi	r24, 0x53	; 83
    13a8:	09 f0       	breq	.+2      	; 0x13ac <vfprintf+0x118>
    13aa:	59 c0       	rjmp	.+178    	; 0x145e <vfprintf+0x1ca>
    13ac:	21 c0       	rjmp	.+66     	; 0x13f0 <vfprintf+0x15c>
    13ae:	f8 01       	movw	r30, r16
    13b0:	80 81       	ld	r24, Z
    13b2:	89 83       	std	Y+1, r24	; 0x01
    13b4:	0e 5f       	subi	r16, 0xFE	; 254
    13b6:	1f 4f       	sbci	r17, 0xFF	; 255
    13b8:	88 24       	eor	r8, r8
    13ba:	83 94       	inc	r8
    13bc:	91 2c       	mov	r9, r1
    13be:	53 01       	movw	r10, r6
    13c0:	13 c0       	rjmp	.+38     	; 0x13e8 <vfprintf+0x154>
    13c2:	28 01       	movw	r4, r16
    13c4:	f2 e0       	ldi	r31, 0x02	; 2
    13c6:	4f 0e       	add	r4, r31
    13c8:	51 1c       	adc	r5, r1
    13ca:	f8 01       	movw	r30, r16
    13cc:	a0 80       	ld	r10, Z
    13ce:	b1 80       	ldd	r11, Z+1	; 0x01
    13d0:	36 fe       	sbrs	r3, 6
    13d2:	03 c0       	rjmp	.+6      	; 0x13da <vfprintf+0x146>
    13d4:	69 2d       	mov	r22, r9
    13d6:	70 e0       	ldi	r23, 0x00	; 0
    13d8:	02 c0       	rjmp	.+4      	; 0x13de <vfprintf+0x14a>
    13da:	6f ef       	ldi	r22, 0xFF	; 255
    13dc:	7f ef       	ldi	r23, 0xFF	; 255
    13de:	c5 01       	movw	r24, r10
    13e0:	0e 94 36 0b 	call	0x166c	; 0x166c <strnlen>
    13e4:	4c 01       	movw	r8, r24
    13e6:	82 01       	movw	r16, r4
    13e8:	f3 2d       	mov	r31, r3
    13ea:	ff 77       	andi	r31, 0x7F	; 127
    13ec:	3f 2e       	mov	r3, r31
    13ee:	16 c0       	rjmp	.+44     	; 0x141c <vfprintf+0x188>
    13f0:	28 01       	movw	r4, r16
    13f2:	22 e0       	ldi	r18, 0x02	; 2
    13f4:	42 0e       	add	r4, r18
    13f6:	51 1c       	adc	r5, r1
    13f8:	f8 01       	movw	r30, r16
    13fa:	a0 80       	ld	r10, Z
    13fc:	b1 80       	ldd	r11, Z+1	; 0x01
    13fe:	36 fe       	sbrs	r3, 6
    1400:	03 c0       	rjmp	.+6      	; 0x1408 <vfprintf+0x174>
    1402:	69 2d       	mov	r22, r9
    1404:	70 e0       	ldi	r23, 0x00	; 0
    1406:	02 c0       	rjmp	.+4      	; 0x140c <vfprintf+0x178>
    1408:	6f ef       	ldi	r22, 0xFF	; 255
    140a:	7f ef       	ldi	r23, 0xFF	; 255
    140c:	c5 01       	movw	r24, r10
    140e:	0e 94 2b 0b 	call	0x1656	; 0x1656 <strnlen_P>
    1412:	4c 01       	movw	r8, r24
    1414:	f3 2d       	mov	r31, r3
    1416:	f0 68       	ori	r31, 0x80	; 128
    1418:	3f 2e       	mov	r3, r31
    141a:	82 01       	movw	r16, r4
    141c:	33 fc       	sbrc	r3, 3
    141e:	1b c0       	rjmp	.+54     	; 0x1456 <vfprintf+0x1c2>
    1420:	82 2d       	mov	r24, r2
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	88 16       	cp	r8, r24
    1426:	99 06       	cpc	r9, r25
    1428:	b0 f4       	brcc	.+44     	; 0x1456 <vfprintf+0x1c2>
    142a:	b6 01       	movw	r22, r12
    142c:	80 e2       	ldi	r24, 0x20	; 32
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    1434:	2a 94       	dec	r2
    1436:	f4 cf       	rjmp	.-24     	; 0x1420 <vfprintf+0x18c>
    1438:	f5 01       	movw	r30, r10
    143a:	37 fc       	sbrc	r3, 7
    143c:	85 91       	lpm	r24, Z+
    143e:	37 fe       	sbrs	r3, 7
    1440:	81 91       	ld	r24, Z+
    1442:	5f 01       	movw	r10, r30
    1444:	b6 01       	movw	r22, r12
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    144c:	21 10       	cpse	r2, r1
    144e:	2a 94       	dec	r2
    1450:	21 e0       	ldi	r18, 0x01	; 1
    1452:	82 1a       	sub	r8, r18
    1454:	91 08       	sbc	r9, r1
    1456:	81 14       	cp	r8, r1
    1458:	91 04       	cpc	r9, r1
    145a:	71 f7       	brne	.-36     	; 0x1438 <vfprintf+0x1a4>
    145c:	e8 c0       	rjmp	.+464    	; 0x162e <vfprintf+0x39a>
    145e:	84 36       	cpi	r24, 0x64	; 100
    1460:	11 f0       	breq	.+4      	; 0x1466 <vfprintf+0x1d2>
    1462:	89 36       	cpi	r24, 0x69	; 105
    1464:	41 f5       	brne	.+80     	; 0x14b6 <vfprintf+0x222>
    1466:	f8 01       	movw	r30, r16
    1468:	37 fe       	sbrs	r3, 7
    146a:	07 c0       	rjmp	.+14     	; 0x147a <vfprintf+0x1e6>
    146c:	60 81       	ld	r22, Z
    146e:	71 81       	ldd	r23, Z+1	; 0x01
    1470:	82 81       	ldd	r24, Z+2	; 0x02
    1472:	93 81       	ldd	r25, Z+3	; 0x03
    1474:	0c 5f       	subi	r16, 0xFC	; 252
    1476:	1f 4f       	sbci	r17, 0xFF	; 255
    1478:	08 c0       	rjmp	.+16     	; 0x148a <vfprintf+0x1f6>
    147a:	60 81       	ld	r22, Z
    147c:	71 81       	ldd	r23, Z+1	; 0x01
    147e:	07 2e       	mov	r0, r23
    1480:	00 0c       	add	r0, r0
    1482:	88 0b       	sbc	r24, r24
    1484:	99 0b       	sbc	r25, r25
    1486:	0e 5f       	subi	r16, 0xFE	; 254
    1488:	1f 4f       	sbci	r17, 0xFF	; 255
    148a:	f3 2d       	mov	r31, r3
    148c:	ff 76       	andi	r31, 0x6F	; 111
    148e:	3f 2e       	mov	r3, r31
    1490:	97 ff       	sbrs	r25, 7
    1492:	09 c0       	rjmp	.+18     	; 0x14a6 <vfprintf+0x212>
    1494:	90 95       	com	r25
    1496:	80 95       	com	r24
    1498:	70 95       	com	r23
    149a:	61 95       	neg	r22
    149c:	7f 4f       	sbci	r23, 0xFF	; 255
    149e:	8f 4f       	sbci	r24, 0xFF	; 255
    14a0:	9f 4f       	sbci	r25, 0xFF	; 255
    14a2:	f0 68       	ori	r31, 0x80	; 128
    14a4:	3f 2e       	mov	r3, r31
    14a6:	2a e0       	ldi	r18, 0x0A	; 10
    14a8:	30 e0       	ldi	r19, 0x00	; 0
    14aa:	a3 01       	movw	r20, r6
    14ac:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <__ultoa_invert>
    14b0:	88 2e       	mov	r8, r24
    14b2:	86 18       	sub	r8, r6
    14b4:	45 c0       	rjmp	.+138    	; 0x1540 <vfprintf+0x2ac>
    14b6:	85 37       	cpi	r24, 0x75	; 117
    14b8:	31 f4       	brne	.+12     	; 0x14c6 <vfprintf+0x232>
    14ba:	23 2d       	mov	r18, r3
    14bc:	2f 7e       	andi	r18, 0xEF	; 239
    14be:	b2 2e       	mov	r11, r18
    14c0:	2a e0       	ldi	r18, 0x0A	; 10
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    14c4:	25 c0       	rjmp	.+74     	; 0x1510 <vfprintf+0x27c>
    14c6:	93 2d       	mov	r25, r3
    14c8:	99 7f       	andi	r25, 0xF9	; 249
    14ca:	b9 2e       	mov	r11, r25
    14cc:	8f 36       	cpi	r24, 0x6F	; 111
    14ce:	c1 f0       	breq	.+48     	; 0x1500 <vfprintf+0x26c>
    14d0:	18 f4       	brcc	.+6      	; 0x14d8 <vfprintf+0x244>
    14d2:	88 35       	cpi	r24, 0x58	; 88
    14d4:	79 f0       	breq	.+30     	; 0x14f4 <vfprintf+0x260>
    14d6:	b5 c0       	rjmp	.+362    	; 0x1642 <vfprintf+0x3ae>
    14d8:	80 37       	cpi	r24, 0x70	; 112
    14da:	19 f0       	breq	.+6      	; 0x14e2 <vfprintf+0x24e>
    14dc:	88 37       	cpi	r24, 0x78	; 120
    14de:	21 f0       	breq	.+8      	; 0x14e8 <vfprintf+0x254>
    14e0:	b0 c0       	rjmp	.+352    	; 0x1642 <vfprintf+0x3ae>
    14e2:	e9 2f       	mov	r30, r25
    14e4:	e0 61       	ori	r30, 0x10	; 16
    14e6:	be 2e       	mov	r11, r30
    14e8:	b4 fe       	sbrs	r11, 4
    14ea:	0d c0       	rjmp	.+26     	; 0x1506 <vfprintf+0x272>
    14ec:	fb 2d       	mov	r31, r11
    14ee:	f4 60       	ori	r31, 0x04	; 4
    14f0:	bf 2e       	mov	r11, r31
    14f2:	09 c0       	rjmp	.+18     	; 0x1506 <vfprintf+0x272>
    14f4:	34 fe       	sbrs	r3, 4
    14f6:	0a c0       	rjmp	.+20     	; 0x150c <vfprintf+0x278>
    14f8:	29 2f       	mov	r18, r25
    14fa:	26 60       	ori	r18, 0x06	; 6
    14fc:	b2 2e       	mov	r11, r18
    14fe:	06 c0       	rjmp	.+12     	; 0x150c <vfprintf+0x278>
    1500:	28 e0       	ldi	r18, 0x08	; 8
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	05 c0       	rjmp	.+10     	; 0x1510 <vfprintf+0x27c>
    1506:	20 e1       	ldi	r18, 0x10	; 16
    1508:	30 e0       	ldi	r19, 0x00	; 0
    150a:	02 c0       	rjmp	.+4      	; 0x1510 <vfprintf+0x27c>
    150c:	20 e1       	ldi	r18, 0x10	; 16
    150e:	32 e0       	ldi	r19, 0x02	; 2
    1510:	f8 01       	movw	r30, r16
    1512:	b7 fe       	sbrs	r11, 7
    1514:	07 c0       	rjmp	.+14     	; 0x1524 <vfprintf+0x290>
    1516:	60 81       	ld	r22, Z
    1518:	71 81       	ldd	r23, Z+1	; 0x01
    151a:	82 81       	ldd	r24, Z+2	; 0x02
    151c:	93 81       	ldd	r25, Z+3	; 0x03
    151e:	0c 5f       	subi	r16, 0xFC	; 252
    1520:	1f 4f       	sbci	r17, 0xFF	; 255
    1522:	06 c0       	rjmp	.+12     	; 0x1530 <vfprintf+0x29c>
    1524:	60 81       	ld	r22, Z
    1526:	71 81       	ldd	r23, Z+1	; 0x01
    1528:	80 e0       	ldi	r24, 0x00	; 0
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	0e 5f       	subi	r16, 0xFE	; 254
    152e:	1f 4f       	sbci	r17, 0xFF	; 255
    1530:	a3 01       	movw	r20, r6
    1532:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <__ultoa_invert>
    1536:	88 2e       	mov	r8, r24
    1538:	86 18       	sub	r8, r6
    153a:	fb 2d       	mov	r31, r11
    153c:	ff 77       	andi	r31, 0x7F	; 127
    153e:	3f 2e       	mov	r3, r31
    1540:	36 fe       	sbrs	r3, 6
    1542:	0d c0       	rjmp	.+26     	; 0x155e <vfprintf+0x2ca>
    1544:	23 2d       	mov	r18, r3
    1546:	2e 7f       	andi	r18, 0xFE	; 254
    1548:	a2 2e       	mov	r10, r18
    154a:	89 14       	cp	r8, r9
    154c:	58 f4       	brcc	.+22     	; 0x1564 <vfprintf+0x2d0>
    154e:	34 fe       	sbrs	r3, 4
    1550:	0b c0       	rjmp	.+22     	; 0x1568 <vfprintf+0x2d4>
    1552:	32 fc       	sbrc	r3, 2
    1554:	09 c0       	rjmp	.+18     	; 0x1568 <vfprintf+0x2d4>
    1556:	83 2d       	mov	r24, r3
    1558:	8e 7e       	andi	r24, 0xEE	; 238
    155a:	a8 2e       	mov	r10, r24
    155c:	05 c0       	rjmp	.+10     	; 0x1568 <vfprintf+0x2d4>
    155e:	b8 2c       	mov	r11, r8
    1560:	a3 2c       	mov	r10, r3
    1562:	03 c0       	rjmp	.+6      	; 0x156a <vfprintf+0x2d6>
    1564:	b8 2c       	mov	r11, r8
    1566:	01 c0       	rjmp	.+2      	; 0x156a <vfprintf+0x2d6>
    1568:	b9 2c       	mov	r11, r9
    156a:	a4 fe       	sbrs	r10, 4
    156c:	0f c0       	rjmp	.+30     	; 0x158c <vfprintf+0x2f8>
    156e:	fe 01       	movw	r30, r28
    1570:	e8 0d       	add	r30, r8
    1572:	f1 1d       	adc	r31, r1
    1574:	80 81       	ld	r24, Z
    1576:	80 33       	cpi	r24, 0x30	; 48
    1578:	21 f4       	brne	.+8      	; 0x1582 <vfprintf+0x2ee>
    157a:	9a 2d       	mov	r25, r10
    157c:	99 7e       	andi	r25, 0xE9	; 233
    157e:	a9 2e       	mov	r10, r25
    1580:	09 c0       	rjmp	.+18     	; 0x1594 <vfprintf+0x300>
    1582:	a2 fe       	sbrs	r10, 2
    1584:	06 c0       	rjmp	.+12     	; 0x1592 <vfprintf+0x2fe>
    1586:	b3 94       	inc	r11
    1588:	b3 94       	inc	r11
    158a:	04 c0       	rjmp	.+8      	; 0x1594 <vfprintf+0x300>
    158c:	8a 2d       	mov	r24, r10
    158e:	86 78       	andi	r24, 0x86	; 134
    1590:	09 f0       	breq	.+2      	; 0x1594 <vfprintf+0x300>
    1592:	b3 94       	inc	r11
    1594:	a3 fc       	sbrc	r10, 3
    1596:	11 c0       	rjmp	.+34     	; 0x15ba <vfprintf+0x326>
    1598:	a0 fe       	sbrs	r10, 0
    159a:	06 c0       	rjmp	.+12     	; 0x15a8 <vfprintf+0x314>
    159c:	b2 14       	cp	r11, r2
    159e:	88 f4       	brcc	.+34     	; 0x15c2 <vfprintf+0x32e>
    15a0:	28 0c       	add	r2, r8
    15a2:	92 2c       	mov	r9, r2
    15a4:	9b 18       	sub	r9, r11
    15a6:	0e c0       	rjmp	.+28     	; 0x15c4 <vfprintf+0x330>
    15a8:	b2 14       	cp	r11, r2
    15aa:	60 f4       	brcc	.+24     	; 0x15c4 <vfprintf+0x330>
    15ac:	b6 01       	movw	r22, r12
    15ae:	80 e2       	ldi	r24, 0x20	; 32
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    15b6:	b3 94       	inc	r11
    15b8:	f7 cf       	rjmp	.-18     	; 0x15a8 <vfprintf+0x314>
    15ba:	b2 14       	cp	r11, r2
    15bc:	18 f4       	brcc	.+6      	; 0x15c4 <vfprintf+0x330>
    15be:	2b 18       	sub	r2, r11
    15c0:	02 c0       	rjmp	.+4      	; 0x15c6 <vfprintf+0x332>
    15c2:	98 2c       	mov	r9, r8
    15c4:	21 2c       	mov	r2, r1
    15c6:	a4 fe       	sbrs	r10, 4
    15c8:	10 c0       	rjmp	.+32     	; 0x15ea <vfprintf+0x356>
    15ca:	b6 01       	movw	r22, r12
    15cc:	80 e3       	ldi	r24, 0x30	; 48
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    15d4:	a2 fe       	sbrs	r10, 2
    15d6:	17 c0       	rjmp	.+46     	; 0x1606 <vfprintf+0x372>
    15d8:	a1 fc       	sbrc	r10, 1
    15da:	03 c0       	rjmp	.+6      	; 0x15e2 <vfprintf+0x34e>
    15dc:	88 e7       	ldi	r24, 0x78	; 120
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	02 c0       	rjmp	.+4      	; 0x15e6 <vfprintf+0x352>
    15e2:	88 e5       	ldi	r24, 0x58	; 88
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	b6 01       	movw	r22, r12
    15e8:	0c c0       	rjmp	.+24     	; 0x1602 <vfprintf+0x36e>
    15ea:	8a 2d       	mov	r24, r10
    15ec:	86 78       	andi	r24, 0x86	; 134
    15ee:	59 f0       	breq	.+22     	; 0x1606 <vfprintf+0x372>
    15f0:	a1 fe       	sbrs	r10, 1
    15f2:	02 c0       	rjmp	.+4      	; 0x15f8 <vfprintf+0x364>
    15f4:	8b e2       	ldi	r24, 0x2B	; 43
    15f6:	01 c0       	rjmp	.+2      	; 0x15fa <vfprintf+0x366>
    15f8:	80 e2       	ldi	r24, 0x20	; 32
    15fa:	a7 fc       	sbrc	r10, 7
    15fc:	8d e2       	ldi	r24, 0x2D	; 45
    15fe:	b6 01       	movw	r22, r12
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    1606:	89 14       	cp	r8, r9
    1608:	38 f4       	brcc	.+14     	; 0x1618 <vfprintf+0x384>
    160a:	b6 01       	movw	r22, r12
    160c:	80 e3       	ldi	r24, 0x30	; 48
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    1614:	9a 94       	dec	r9
    1616:	f7 cf       	rjmp	.-18     	; 0x1606 <vfprintf+0x372>
    1618:	8a 94       	dec	r8
    161a:	f3 01       	movw	r30, r6
    161c:	e8 0d       	add	r30, r8
    161e:	f1 1d       	adc	r31, r1
    1620:	80 81       	ld	r24, Z
    1622:	b6 01       	movw	r22, r12
    1624:	90 e0       	ldi	r25, 0x00	; 0
    1626:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    162a:	81 10       	cpse	r8, r1
    162c:	f5 cf       	rjmp	.-22     	; 0x1618 <vfprintf+0x384>
    162e:	22 20       	and	r2, r2
    1630:	09 f4       	brne	.+2      	; 0x1634 <vfprintf+0x3a0>
    1632:	42 ce       	rjmp	.-892    	; 0x12b8 <vfprintf+0x24>
    1634:	b6 01       	movw	r22, r12
    1636:	80 e2       	ldi	r24, 0x20	; 32
    1638:	90 e0       	ldi	r25, 0x00	; 0
    163a:	0e 94 41 0b 	call	0x1682	; 0x1682 <fputc>
    163e:	2a 94       	dec	r2
    1640:	f6 cf       	rjmp	.-20     	; 0x162e <vfprintf+0x39a>
    1642:	f6 01       	movw	r30, r12
    1644:	86 81       	ldd	r24, Z+6	; 0x06
    1646:	97 81       	ldd	r25, Z+7	; 0x07
    1648:	02 c0       	rjmp	.+4      	; 0x164e <vfprintf+0x3ba>
    164a:	8f ef       	ldi	r24, 0xFF	; 255
    164c:	9f ef       	ldi	r25, 0xFF	; 255
    164e:	2b 96       	adiw	r28, 0x0b	; 11
    1650:	e2 e1       	ldi	r30, 0x12	; 18
    1652:	0c 94 f7 0b 	jmp	0x17ee	; 0x17ee <__epilogue_restores__>

00001656 <strnlen_P>:
    1656:	fc 01       	movw	r30, r24
    1658:	05 90       	lpm	r0, Z+
    165a:	61 50       	subi	r22, 0x01	; 1
    165c:	70 40       	sbci	r23, 0x00	; 0
    165e:	01 10       	cpse	r0, r1
    1660:	d8 f7       	brcc	.-10     	; 0x1658 <strnlen_P+0x2>
    1662:	80 95       	com	r24
    1664:	90 95       	com	r25
    1666:	8e 0f       	add	r24, r30
    1668:	9f 1f       	adc	r25, r31
    166a:	08 95       	ret

0000166c <strnlen>:
    166c:	fc 01       	movw	r30, r24
    166e:	61 50       	subi	r22, 0x01	; 1
    1670:	70 40       	sbci	r23, 0x00	; 0
    1672:	01 90       	ld	r0, Z+
    1674:	01 10       	cpse	r0, r1
    1676:	d8 f7       	brcc	.-10     	; 0x166e <strnlen+0x2>
    1678:	80 95       	com	r24
    167a:	90 95       	com	r25
    167c:	8e 0f       	add	r24, r30
    167e:	9f 1f       	adc	r25, r31
    1680:	08 95       	ret

00001682 <fputc>:
    1682:	0f 93       	push	r16
    1684:	1f 93       	push	r17
    1686:	cf 93       	push	r28
    1688:	df 93       	push	r29
    168a:	fb 01       	movw	r30, r22
    168c:	23 81       	ldd	r18, Z+3	; 0x03
    168e:	21 fd       	sbrc	r18, 1
    1690:	03 c0       	rjmp	.+6      	; 0x1698 <fputc+0x16>
    1692:	8f ef       	ldi	r24, 0xFF	; 255
    1694:	9f ef       	ldi	r25, 0xFF	; 255
    1696:	2c c0       	rjmp	.+88     	; 0x16f0 <fputc+0x6e>
    1698:	22 ff       	sbrs	r18, 2
    169a:	16 c0       	rjmp	.+44     	; 0x16c8 <fputc+0x46>
    169c:	46 81       	ldd	r20, Z+6	; 0x06
    169e:	57 81       	ldd	r21, Z+7	; 0x07
    16a0:	24 81       	ldd	r18, Z+4	; 0x04
    16a2:	35 81       	ldd	r19, Z+5	; 0x05
    16a4:	42 17       	cp	r20, r18
    16a6:	53 07       	cpc	r21, r19
    16a8:	44 f4       	brge	.+16     	; 0x16ba <fputc+0x38>
    16aa:	a0 81       	ld	r26, Z
    16ac:	b1 81       	ldd	r27, Z+1	; 0x01
    16ae:	9d 01       	movw	r18, r26
    16b0:	2f 5f       	subi	r18, 0xFF	; 255
    16b2:	3f 4f       	sbci	r19, 0xFF	; 255
    16b4:	31 83       	std	Z+1, r19	; 0x01
    16b6:	20 83       	st	Z, r18
    16b8:	8c 93       	st	X, r24
    16ba:	26 81       	ldd	r18, Z+6	; 0x06
    16bc:	37 81       	ldd	r19, Z+7	; 0x07
    16be:	2f 5f       	subi	r18, 0xFF	; 255
    16c0:	3f 4f       	sbci	r19, 0xFF	; 255
    16c2:	37 83       	std	Z+7, r19	; 0x07
    16c4:	26 83       	std	Z+6, r18	; 0x06
    16c6:	14 c0       	rjmp	.+40     	; 0x16f0 <fputc+0x6e>
    16c8:	8b 01       	movw	r16, r22
    16ca:	ec 01       	movw	r28, r24
    16cc:	fb 01       	movw	r30, r22
    16ce:	00 84       	ldd	r0, Z+8	; 0x08
    16d0:	f1 85       	ldd	r31, Z+9	; 0x09
    16d2:	e0 2d       	mov	r30, r0
    16d4:	09 95       	icall
    16d6:	89 2b       	or	r24, r25
    16d8:	e1 f6       	brne	.-72     	; 0x1692 <fputc+0x10>
    16da:	d8 01       	movw	r26, r16
    16dc:	16 96       	adiw	r26, 0x06	; 6
    16de:	8d 91       	ld	r24, X+
    16e0:	9c 91       	ld	r25, X
    16e2:	17 97       	sbiw	r26, 0x07	; 7
    16e4:	01 96       	adiw	r24, 0x01	; 1
    16e6:	17 96       	adiw	r26, 0x07	; 7
    16e8:	9c 93       	st	X, r25
    16ea:	8e 93       	st	-X, r24
    16ec:	16 97       	sbiw	r26, 0x06	; 6
    16ee:	ce 01       	movw	r24, r28
    16f0:	df 91       	pop	r29
    16f2:	cf 91       	pop	r28
    16f4:	1f 91       	pop	r17
    16f6:	0f 91       	pop	r16
    16f8:	08 95       	ret

000016fa <__ultoa_invert>:
    16fa:	fa 01       	movw	r30, r20
    16fc:	aa 27       	eor	r26, r26
    16fe:	28 30       	cpi	r18, 0x08	; 8
    1700:	51 f1       	breq	.+84     	; 0x1756 <__ultoa_invert+0x5c>
    1702:	20 31       	cpi	r18, 0x10	; 16
    1704:	81 f1       	breq	.+96     	; 0x1766 <__ultoa_invert+0x6c>
    1706:	e8 94       	clt
    1708:	6f 93       	push	r22
    170a:	6e 7f       	andi	r22, 0xFE	; 254
    170c:	6e 5f       	subi	r22, 0xFE	; 254
    170e:	7f 4f       	sbci	r23, 0xFF	; 255
    1710:	8f 4f       	sbci	r24, 0xFF	; 255
    1712:	9f 4f       	sbci	r25, 0xFF	; 255
    1714:	af 4f       	sbci	r26, 0xFF	; 255
    1716:	b1 e0       	ldi	r27, 0x01	; 1
    1718:	3e d0       	rcall	.+124    	; 0x1796 <__ultoa_invert+0x9c>
    171a:	b4 e0       	ldi	r27, 0x04	; 4
    171c:	3c d0       	rcall	.+120    	; 0x1796 <__ultoa_invert+0x9c>
    171e:	67 0f       	add	r22, r23
    1720:	78 1f       	adc	r23, r24
    1722:	89 1f       	adc	r24, r25
    1724:	9a 1f       	adc	r25, r26
    1726:	a1 1d       	adc	r26, r1
    1728:	68 0f       	add	r22, r24
    172a:	79 1f       	adc	r23, r25
    172c:	8a 1f       	adc	r24, r26
    172e:	91 1d       	adc	r25, r1
    1730:	a1 1d       	adc	r26, r1
    1732:	6a 0f       	add	r22, r26
    1734:	71 1d       	adc	r23, r1
    1736:	81 1d       	adc	r24, r1
    1738:	91 1d       	adc	r25, r1
    173a:	a1 1d       	adc	r26, r1
    173c:	20 d0       	rcall	.+64     	; 0x177e <__ultoa_invert+0x84>
    173e:	09 f4       	brne	.+2      	; 0x1742 <__ultoa_invert+0x48>
    1740:	68 94       	set
    1742:	3f 91       	pop	r19
    1744:	2a e0       	ldi	r18, 0x0A	; 10
    1746:	26 9f       	mul	r18, r22
    1748:	11 24       	eor	r1, r1
    174a:	30 19       	sub	r19, r0
    174c:	30 5d       	subi	r19, 0xD0	; 208
    174e:	31 93       	st	Z+, r19
    1750:	de f6       	brtc	.-74     	; 0x1708 <__ultoa_invert+0xe>
    1752:	cf 01       	movw	r24, r30
    1754:	08 95       	ret
    1756:	46 2f       	mov	r20, r22
    1758:	47 70       	andi	r20, 0x07	; 7
    175a:	40 5d       	subi	r20, 0xD0	; 208
    175c:	41 93       	st	Z+, r20
    175e:	b3 e0       	ldi	r27, 0x03	; 3
    1760:	0f d0       	rcall	.+30     	; 0x1780 <__ultoa_invert+0x86>
    1762:	c9 f7       	brne	.-14     	; 0x1756 <__ultoa_invert+0x5c>
    1764:	f6 cf       	rjmp	.-20     	; 0x1752 <__ultoa_invert+0x58>
    1766:	46 2f       	mov	r20, r22
    1768:	4f 70       	andi	r20, 0x0F	; 15
    176a:	40 5d       	subi	r20, 0xD0	; 208
    176c:	4a 33       	cpi	r20, 0x3A	; 58
    176e:	18 f0       	brcs	.+6      	; 0x1776 <__ultoa_invert+0x7c>
    1770:	49 5d       	subi	r20, 0xD9	; 217
    1772:	31 fd       	sbrc	r19, 1
    1774:	40 52       	subi	r20, 0x20	; 32
    1776:	41 93       	st	Z+, r20
    1778:	02 d0       	rcall	.+4      	; 0x177e <__ultoa_invert+0x84>
    177a:	a9 f7       	brne	.-22     	; 0x1766 <__ultoa_invert+0x6c>
    177c:	ea cf       	rjmp	.-44     	; 0x1752 <__ultoa_invert+0x58>
    177e:	b4 e0       	ldi	r27, 0x04	; 4
    1780:	a6 95       	lsr	r26
    1782:	97 95       	ror	r25
    1784:	87 95       	ror	r24
    1786:	77 95       	ror	r23
    1788:	67 95       	ror	r22
    178a:	ba 95       	dec	r27
    178c:	c9 f7       	brne	.-14     	; 0x1780 <__ultoa_invert+0x86>
    178e:	00 97       	sbiw	r24, 0x00	; 0
    1790:	61 05       	cpc	r22, r1
    1792:	71 05       	cpc	r23, r1
    1794:	08 95       	ret
    1796:	9b 01       	movw	r18, r22
    1798:	ac 01       	movw	r20, r24
    179a:	0a 2e       	mov	r0, r26
    179c:	06 94       	lsr	r0
    179e:	57 95       	ror	r21
    17a0:	47 95       	ror	r20
    17a2:	37 95       	ror	r19
    17a4:	27 95       	ror	r18
    17a6:	ba 95       	dec	r27
    17a8:	c9 f7       	brne	.-14     	; 0x179c <__ultoa_invert+0xa2>
    17aa:	62 0f       	add	r22, r18
    17ac:	73 1f       	adc	r23, r19
    17ae:	84 1f       	adc	r24, r20
    17b0:	95 1f       	adc	r25, r21
    17b2:	a0 1d       	adc	r26, r0
    17b4:	08 95       	ret

000017b6 <__prologue_saves__>:
    17b6:	2f 92       	push	r2
    17b8:	3f 92       	push	r3
    17ba:	4f 92       	push	r4
    17bc:	5f 92       	push	r5
    17be:	6f 92       	push	r6
    17c0:	7f 92       	push	r7
    17c2:	8f 92       	push	r8
    17c4:	9f 92       	push	r9
    17c6:	af 92       	push	r10
    17c8:	bf 92       	push	r11
    17ca:	cf 92       	push	r12
    17cc:	df 92       	push	r13
    17ce:	ef 92       	push	r14
    17d0:	ff 92       	push	r15
    17d2:	0f 93       	push	r16
    17d4:	1f 93       	push	r17
    17d6:	cf 93       	push	r28
    17d8:	df 93       	push	r29
    17da:	cd b7       	in	r28, 0x3d	; 61
    17dc:	de b7       	in	r29, 0x3e	; 62
    17de:	ca 1b       	sub	r28, r26
    17e0:	db 0b       	sbc	r29, r27
    17e2:	0f b6       	in	r0, 0x3f	; 63
    17e4:	f8 94       	cli
    17e6:	de bf       	out	0x3e, r29	; 62
    17e8:	0f be       	out	0x3f, r0	; 63
    17ea:	cd bf       	out	0x3d, r28	; 61
    17ec:	09 94       	ijmp

000017ee <__epilogue_restores__>:
    17ee:	2a 88       	ldd	r2, Y+18	; 0x12
    17f0:	39 88       	ldd	r3, Y+17	; 0x11
    17f2:	48 88       	ldd	r4, Y+16	; 0x10
    17f4:	5f 84       	ldd	r5, Y+15	; 0x0f
    17f6:	6e 84       	ldd	r6, Y+14	; 0x0e
    17f8:	7d 84       	ldd	r7, Y+13	; 0x0d
    17fa:	8c 84       	ldd	r8, Y+12	; 0x0c
    17fc:	9b 84       	ldd	r9, Y+11	; 0x0b
    17fe:	aa 84       	ldd	r10, Y+10	; 0x0a
    1800:	b9 84       	ldd	r11, Y+9	; 0x09
    1802:	c8 84       	ldd	r12, Y+8	; 0x08
    1804:	df 80       	ldd	r13, Y+7	; 0x07
    1806:	ee 80       	ldd	r14, Y+6	; 0x06
    1808:	fd 80       	ldd	r15, Y+5	; 0x05
    180a:	0c 81       	ldd	r16, Y+4	; 0x04
    180c:	1b 81       	ldd	r17, Y+3	; 0x03
    180e:	aa 81       	ldd	r26, Y+2	; 0x02
    1810:	b9 81       	ldd	r27, Y+1	; 0x01
    1812:	ce 0f       	add	r28, r30
    1814:	d1 1d       	adc	r29, r1
    1816:	0f b6       	in	r0, 0x3f	; 63
    1818:	f8 94       	cli
    181a:	de bf       	out	0x3e, r29	; 62
    181c:	0f be       	out	0x3f, r0	; 63
    181e:	cd bf       	out	0x3d, r28	; 61
    1820:	ed 01       	movw	r28, r26
    1822:	08 95       	ret

00001824 <_exit>:
    1824:	f8 94       	cli

00001826 <__stop_program>:
    1826:	ff cf       	rjmp	.-2      	; 0x1826 <__stop_program>
